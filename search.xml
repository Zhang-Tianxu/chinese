<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SGX的验证</title>
    <url>/chinese/2020/06/24/SGX%E7%9A%84%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<p>Intel SGX可以很好的保证enclave（安全区域）内代码和数据的隐私性和完整性。但是如果需要多个enclave合作的话，在合作之前需要确认对方时SGX enclave。这种验证机制并不简单，分为本地验证和远程验证两种，下面会分别介绍。SGX的验证机制有很多细节，这里不会涉及太多的细节，重在帮助大家理解SGX的验证机制，更好的理解SGX的安全性以及它可能存在的弱点。</p>
<a id="more"></a>

<h2 id="本地验证-Local-Attestation"><a href="#本地验证-Local-Attestation" class="headerlink" title="本地验证 Local Attestation"></a>本地验证 <em>Local Attestation</em></h2><p><strong>SGX的本地验证用于一个enclave（称之为被验证enclave）向同一机器上的另一个enclave（称之为目标enclave）证明它的身份。</strong></p>
<p>本地验证流程：</p>
<ol>
<li>被验证enclave调用<strong>EREPORT</strong>指令，，生成验证报告并发送给目标enclave</li>
<li>目标enclave收到验证报告后，判断验证报告是否可信</li>
</ol>
<p><strong>EREPORT</strong>产生的<strong>验证报告</strong>中包含以下信息：</p>
<ul>
<li><p><strong>MAC（Message Authentication Code）标签</strong></p>
<p>由MAC加密系统产生的标签。</p>
<blockquote>
<p>MAC加密系统：</p>
<p>发送者利用MAC算法读取对称密钥和一个变长的消息，产生一个定长的MAC标签。接受者只要提供原始消息、对称密钥和MAC标签，就可以验证消息的真实性。</p>
</blockquote>
</li>
<li><p>enclave当前的身份信息</p>
<ul>
<li>enclave的measurement</li>
<li>基于证书的身份信息（比如软件开发商的安全版本号等）</li>
</ul>
</li>
<li><p>SGX实现的安全版本号（CPUSVN）</p>
</li>
<li><p>enclave提供的64-byte（512-bit）的消息</p>
</li>
<li><p><strong>KEYID</strong></p>
<p>enclave初始化时产生的一个随机数。</p>
</li>
</ul>
<p>验证报告的详细内容如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg3hm2b6arj30ic10kgof.jpg" alt="image-20200624170332771"></p>
<p>目标enclave想要通过MAC标签验证消息是由SGX实现发出的，那么<strong>生成MAC标签的对称密钥只能SGX实现和目标enclave知道</strong>。被验证enclave是不可以知道这个对称密钥的，<strong>一旦这个对称密钥泄露，验证报告就可能被伪造</strong>。</p>
<p>这个对称密钥成为<em>Report Key</em>，由<strong>EGETKEY</strong>指令产生。<strong>EGETKEY</strong>指令生成密钥的依据包括：</p>
<ul>
<li>嵌入到处理器中的一个秘密</li>
<li>包括<strong>目标enclave</strong>的measurement在内的一些信息</li>
</ul>
<p>目标enclave可以自己生成相应的对称密钥，验证报告中的信息。</p>
<p>目标enclave可以确定验证报告中的MAC标签是由SGX实现生成的，原因有二：</p>
<ol>
<li><strong>EGETKEY</strong>生成密钥的算法和MAC加密系统的MAC算法都是保密的，只有SGX实现才能产生这个MAC标签</li>
<li>只有SGX实现可以读取内嵌在处理器中的秘密</li>
</ol>
<h2 id="远程验证-Remote-Attestation"><a href="#远程验证-Remote-Attestation" class="headerlink" title="远程验证 Remote Attestation"></a>远程验证 <em>Remote Attestation</em></h2><p>相比于本地验证，远程验证要更加复杂。在介绍远程验证前，先介绍将会涉及到的一些内容：</p>
<p>在生产的过程中，处理器中的一个叫做e-fuse存储器中烧有两个秘密，我们称这两个秘密为<em>Provisioning Secret</em>和<em>Seal Secret</em>。</p>
<p><em>Provisioning Secret</em>是intel的密钥生成工具产生的，处理器生产过程中与intel的密钥生成工具通信，获取<em>Provisioning Secret</em>。在烧入处理器e-fuse的同时也会被intel保存在数据库。</p>
<p><em>Seal Secret</em>是在处理器芯片中生成的，所以Intel不知道这个秘密是什么。<em>Seal Secret</em>存在的好处在于，即便攻击者攻破了intel的密钥生成工具，也没办法生成<strong>EGETKEY</strong>生成的密钥。<em>Seal Secret</em>只有被<strong>EGETKEY</strong>做为密钥生成依据时才可以被访问，而不会暴露给任何软件。</p>
<p>远程验证流程：</p>
<ol>
<li><p>被验证enclave利用<strong>EGETKEY</strong>指令生成<em>Provisioning Key</em>，生成<em>Provisioning Key</em>的依据包括：</p>
<ul>
<li><em>Provisioning Secret</em></li>
<li>enclave当前以证书为基础的身份信息</li>
<li>SGX实现的安全版本号</li>
</ul>
</li>
<li><p>被验证enclave利用<em>Provisioning Key</em>向intel的<em>Provisioning</em>服务证明自己是可信的。</p>
<p>上面提过，intel记录了<em>Provisioning Secret</em>，同时拥有生成密钥的算法。</p>
</li>
<li><p>通过验证后，intel的<em>Provisioning</em>服务会生成一个<em>Attestation Key</em>并返还给被验证enclave</p>
</li>
<li><p>被验证enclave再利用<strong>EGETKEY</strong>指令以<em>Seal Secret</em>等信息为依据生成<em>Provisioning Seal key</em>，用这个密钥加密<em>Attestation Key</em>后存入计算机内存或磁盘。</p>
</li>
<li><p><em>Quoting Enclave<em>通过*</em>EGETKEY*<em>获得</em>Provisioning Seal key<em>，从内存中读取并解密</em>Attestation Key</em></p>
</li>
<li><p>被验证enclave向同一机器上的一个成为<em>Quoting Enclave</em>的特殊enclave执行本地验证</p>
</li>
<li><p><em>Quoting Enclave</em>将收到的本地验证的验证报告中的MAC标签换成由<em>Attestation Key</em>产生的签名（一种intel的特殊签名机制）</p>
</li>
<li><p><em>Quoting Enclave</em>将远程验证报告发送给目标enclave</p>
</li>
</ol>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li>Costan, Victor, Ilia Lebedev, and Srinivas Devadas. “Secure processors part I: background, taxonomy for secure enclaves and Intel SGX architecture.” <em>Foundations and Trends in Electronic Design Automation</em> 11.1-2 (2017): 1-248.</li>
</ol>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>安全</category>
        <category>可信执行环境</category>
      </categories>
      <tags>
        <tag>SGX</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语：如何说的更快（二）</title>
    <url>/chinese/2020/04/14/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AF%B4%E7%9A%84%E6%9B%B4%E5%BF%AB%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>内容参考<a href="https://youtu.be/5wr44LGmIaw" target="_blank" rel="noopener">How to speak English fast and understand natives (Part II)</a> From <a href="https://www.youtube.com/channel/UCAQg09FkoobmLquNNoO4ulg" target="_blank" rel="noopener">linguamarina</a></p>
<p>要点：</p>
<ul>
<li>口语中的简化：<ul>
<li>Want to -&gt; wanna</li>
<li>Going to -&gt; gonna</li>
<li>Don’t know -&gt; dunno know</li>
<li>got to -&gt; gotta</li>
</ul>
</li>
<li>忽略无意义词句</li>
<li>使用缩写</li>
<li>重音、俚语和习语<a id="more"></a>

</li>
</ul>
<h2 id="口语中的简化："><a href="#口语中的简化：" class="headerlink" title="口语中的简化："></a>口语中的简化：</h2><ol>
<li>Want to会连读称wanna，比如<br>I want to go to london -&gt;I wanna go to london<br>I want to study in the US -&gt; I wanna study in the US</li>
<li>going to读成 gonna<br>I’m going to wash the car -&gt;I’m gonna wash the car</li>
<li>don’t know读成dunno know<br>I don’t know -&gt; I dunno know</li>
<li>got to 读成 gotta<br>I got to do my homework -&gt; I gotta do my homework</li>
</ol>
<h2 id="忽略口语中的一些无意义词句（fillers），比如："><a href="#忽略口语中的一些无意义词句（fillers），比如：" class="headerlink" title="忽略口语中的一些无意义词句（fillers），比如："></a>忽略口语中的一些无意义词句（fillers），比如：</h2><ol>
<li>actually</li>
<li>anyway</li>
<li>basically</li>
<li>By the way</li>
<li>Erm（象声词）</li>
</ol>
<p>当然反过来我们说的时候也可以插入一些这些句子，给自己多些时间思考</p>
<ol>
<li>I mean</li>
<li>incidentally</li>
<li>in fact</li>
<li>obviously</li>
<li>well</li>
<li>you know</li>
</ol>
<p>比如下面这个句子，去掉斜体字对意思是没有影响的：</p>
<p><em>By the way</em>, I saw Mark yesterday. <em>Erm, so obviously</em> I said ‘hello’ to him but he <em>basically</em> ignored me!</p>
<h2 id="使用缩写"><a href="#使用缩写" class="headerlink" title="使用缩写"></a>使用缩写</h2><table>
<thead>
<tr>
<th align="center">缩写规则</th>
<th>例句</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td align="center">I am -&gt; I’m</td>
<td>I am hungry -&gt; I’m hungry</td>
<td>无</td>
</tr>
<tr>
<td align="center">I will -&gt; I’ll</td>
<td>I will do that -&gt; I’ll do that<br />I will pick it up -&gt; I’ll pick it up</td>
<td>缩写不能用在人名后面<br />Kate will do that $\ne $  Kate’ll do that</td>
</tr>
<tr>
<td align="center">do not = don’t</td>
<td>I do not like it =&gt; I don’t like it</td>
<td></td>
</tr>
<tr>
<td align="center">I have =&gt; I’ve</td>
<td>I have got your back -&gt; I’ve got your back<br />I have done this befor -&gt; I’ve done this before</td>
<td></td>
</tr>
<tr>
<td align="center">I would =&gt; I’d</td>
<td>I would like to join you =&gt; I’d like to join you<br />I would like to stay home -&gt; I’d like to stay home</td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>另外在口语中注意一些几点可以提升听力：</p>
<ul>
<li>在注意口语中的重音能帮助理解口语</li>
<li>学习俚语</li>
<li>学习英语习语</li>
</ul>
]]></content>
      <categories>
        <category>语言</category>
        <category>英语</category>
        <category>英语口语</category>
      </categories>
      <tags>
        <tag>English</tag>
        <tag>英语</tag>
        <tag>Spoken English</tag>
        <tag>英语口语</tag>
        <tag>English Native Speaker</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语：如何说的更快</title>
    <url>/chinese/2020/04/13/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AF%B4%E7%9A%84%E6%9B%B4%E5%BF%AB/</url>
    <content><![CDATA[<p><img src="https://i.ytimg.com/vi/MiebCHmiszs/hqdefault.jpg?sqp=-oaymwEZCNACELwBSFXyq4qpAwsIARUAAIhCGAFwAQ==&rs=AOn4CLAqpOOb7VavDJ4Reu3nzoseweLxcw" alt="封面"></p>
<p>内容参考<a href="https://youtu.be/MiebCHmiszs" target="_blank" rel="noopener">How to speak English fast and understand natives (Part I)</a> From <a href="https://www.youtube.com/channel/UCAQg09FkoobmLquNNoO4ulg" target="_blank" rel="noopener">linguamarina</a></p>
<p>要点：</p>
<ul>
<li>我们感觉English Native Speaker说得快，所以听上去很地道。但实际上他们不是说得快，而是把单词连起来了。</li>
<li>the 读成 duh</li>
<li>you 读成 yuh</li>
<li>以t结尾的单词后接以d开头的单词时，两者字母连读为chu。</li>
<li>Something读成Sumpthin</li>
<li>字母t出现在单词中间时，有时需要读成d</li>
</ul>
<a id="more"></a>
<p>对于句式What do you …，比如What do you do?美国人不会一个单词一个单词的读，而是读成Whudduhyuh do?句式I’m going to …，比如I’m going to do some shopping，美国人会读成I’m gonna do some shopping。甚至有人进一步简化为Ahmma do shopping。这样是为了让平时说话时更容易，更流畅。</p>
<p><strong>the 读成 duh</strong><br>比如句子：<br>What’s the weather today?<br>美国人会读成：<br>What’s duh weather today?<br><strong>you 读成 yuh</strong><br>比如句子：<br>Do you want to go?<br>会被读成：<br>Do yuh wanna go?<br><strong>t结尾的单词后接d开头的单词</strong><br>比如<br>What do you do?<br>会被读成<br>Whutchuhyuh do?<br>这也是为了让口语更顺畅<br>另外几个例子:<br>what you do for a living?<br>读成<br>Whutchuhyuh do for a living?<br>I’m goint to go out to WalMar<strong>t. D</strong>o you need anything?<br>会读成<br>Ahmma go ou’tuh Walmartchuh nee danything?<br><strong>something 读成 sumpthin</strong><br>Can you give me something?<br>读成<br>Can you give me sumpthin?<br>Let me give you something<br>读成<br>Lemmee givyuh sumpthin<br><strong>单词中的t有时会读成d</strong></p>
<table>
<thead>
<tr>
<th align="center">单词</th>
<th align="center">口语发音</th>
</tr>
</thead>
<tbody><tr>
<td align="center">letter</td>
<td align="center">ledder</td>
</tr>
<tr>
<td align="center">city</td>
<td align="center">siddy</td>
</tr>
<tr>
<td align="center">bitter</td>
<td align="center">bidder</td>
</tr>
<tr>
<td align="center">bottle</td>
<td align="center">bodduhl</td>
</tr>
<tr>
<td align="center">butter</td>
<td align="center">budder</td>
</tr>
<tr>
<td align="center">computer</td>
<td align="center">compyooder</td>
</tr>
<tr>
<td align="center">daughter</td>
<td align="center">dawdder</td>
</tr>
<tr>
<td align="center">eighty</td>
<td align="center">ayddy</td>
</tr>
<tr>
<td align="center">forty</td>
<td align="center">fordy</td>
</tr>
<tr>
<td align="center">little</td>
<td align="center">lidduhl</td>
</tr>
<tr>
<td align="center">settle</td>
<td align="center">sedduhl</td>
</tr>
<tr>
<td align="center">thirty</td>
<td align="center">thurdy</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>语言</category>
        <category>英语</category>
        <category>英语口语</category>
      </categories>
      <tags>
        <tag>English</tag>
        <tag>英语</tag>
        <tag>Spoken English</tag>
        <tag>英语口语</tag>
        <tag>English Native Speaker</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序：如何把公众号后台上传的视频链接插入到小程序</title>
    <url>/chinese/2020/04/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E6%8A%8A%E5%85%AC%E4%BC%97%E5%8F%B7%E5%90%8E%E5%8F%B0%E4%B8%8A%E4%BC%A0%E7%9A%84%E8%A7%86%E9%A2%91%E9%93%BE%E6%8E%A5%E6%8F%92%E5%85%A5%E5%88%B0%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="微信小程序视频链接"><a href="#微信小程序视频链接" class="headerlink" title="微信小程序视频链接"></a>微信小程序视频链接</h1><p>微信小程序对链接的过滤很严格，很多视频链接都没办法直接插入到小程序的video组件。但是腾讯自己的视频还是没问题的。我是现有的微信公众号，再为其开发小程序。所以希望将之前上传到微信公众号的视频在小程序中直接复用而不占用小程序云开发的存储空间。</p>
<a id="more"></a>

<p>获取微信公众号文章中视频链接的方法：</p>
<ol>
<li>用浏览器打开公众号文章，在浏览器（以chrome为例）中打开开发者工具<sup><a href="#foot_note_1">[1]</a></sup></li>
<li>选择network并选择Media过滤其<br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdm9yjomrhj30u00vn0vv.jpg" alt=""></li>
<li>点击播放视频，这时会出现一个包，包头部中红框部分就是我们想要的链接了。<br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdm9z0moluj31ln0u0aii.jpg" alt=""></li>
</ol>
<p><span id="foot_note_1"><sub>[1]:在chrome浏览器页面部分单击右键，选择“检查”</sub></span></p>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>前端</category>
        <category>小程序</category>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>微信小程序</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序：scroll-view与swiper</title>
    <url>/chinese/2020/04/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%9Ascroll-view%E4%B8%8Eswiper/</url>
    <content><![CDATA[<h1 id="scroll-view与swiper的区别"><a href="#scroll-view与swiper的区别" class="headerlink" title="scroll-view与swiper的区别"></a>scroll-view与swiper的区别</h1><p>在做小程序的时候有一个需求:主要内容做成卡片，然后通过划动在卡片之间切换。划动的内容，第一反应就想到scroll-view组件，没细想就开始做了，但是做的差不多了总出现一些小毛病：</p>
<ol>
<li>划动时会停在两个卡片中间，而不是想要的一个卡片一个卡片的划动。</li>
<li>scroll-view带惯性感性，大力划动会连续跳过好几个卡片。还是没达到一个卡片一个卡片的划动。</li>
</ol>
<p>为了解决这个问题，我尝试了很多方法。第1个问题，我通过用js设置scroll-view的划动距离，强行让划到中间的卡片复位。废了九牛二虎之力才解决了，第2个问题怎么也解决不了。最后才发现<strong>更符合我需求的组件是swiper！</strong></p>
<a id="more"></a>

<p>参考：</p>
<ul>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html" target="_blank" rel="noopener">scroll-view</a><ul>
<li>滚动视图容器</li>
</ul>
</li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html" target="_blank" rel="noopener">swiper</a><ul>
<li>滑块视图容器</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>前端</category>
        <category>小程序</category>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>微信小程序</tag>
        <tag>小程序</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>强大的反爬虫机制</title>
    <url>/chinese/2020/04/08/%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%8F%8D%E7%88%AC%E8%99%AB%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>需求：拥有招聘网站的招聘者账户，爬取求职者们的简历信息。（不过这个好像是违法的，还好我失败了，不建议尝试)</p>
<p>尝试过的工具：</p>
<ul>
<li><a href="https://docs.scrapy.org/en/latest/" target="_blank" rel="noopener">Scrapy</a></li>
<li><a href="https://splash.readthedocs.io/en/3.4.1/" target="_blank" rel="noopener">Splash</a></li>
<li><a href="https://www.selenium.dev/documentation/en/" target="_blank" rel="noopener">selenium</a></li>
</ul>
<a id="more"></a>
<p>在尝试的过程中遇到了如下几个问题：</p>
<ol>
<li>动态网站，直接使用Scrapy爬的话，只能爬静态网页。需要用到splash渲染</li>
<li>splash渲染过的网页(和浏览器看源码得到的内容一样)和实际网页内容不符，前者body中是一些js脚本。</li>
<li>使用selenium自动化控制得到正常网页，但是会被反爬虫机制发现，提示账户存在风险。</li>
</ol>
<p>爬虫经常遇到的问题，我基本都遇到了……</p>
<p><strong>解决方案</strong></p>
<ol>
<li>现在的动态网页越来越多，可以借助splash完成渲染，这个问题不大。</li>
<li>确实会有遇到某些url是经过js处理然后再生成的情况（比如某些url的加密解密，id的运算等），这样的情况下你直接看网页源代码是找不到直接的url的，而通过检查是可以看到经过处理的url的。一般遇到这个情况，除非你了解这些url的生成方式，自行设计算法来破解，不然直接用requests库就显得力不从心了。当然，遇到这种情况也有一个“曲线救国”的办法，就是借助selenium或者splinter来模拟浏览器访问，既然是模拟浏览器，当然它们都是可以处理js程序的，所以你看到的也是直接可以访问的url。(<a href="https://fishc.com.cn/thread-82644-1-1.html" target="_blank" rel="noopener">参考</a></li>
<li>按照2中的解决方案，改用selenium。通过添加cookies可以正常登录，但是尝试通过定位网页元素点击时，就出出现下图中的提示，我猜是因为定位不小心，定位到了隐藏元素，被判定为爬虫。<br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdm65nf0zbj31hb0o1dj2.jpg" alt="警告"></li>
</ol>
<p>到这之后就放弃了，毕竟只是好奇，想试一下。</p>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>编程语言</category>
        <category>Python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
        <tag>Splash</tag>
        <tag>scrapy_splash</tag>
        <tag>爬虫</tag>
        <tag>反爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币和区块链的运行原理</title>
    <url>/chinese/2019/11/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%92%8C%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>比特币和区块链技术出现很久了，大家或多或少都有耳闻。不管是对比特币暴涨的羡慕，还是对背后技术的科普。笔者也是一样多少看过一些相关资料，但最近读区块链支付领域的顶会<sup><a href="#foot_note_1">[1]</a></sup>论文<sup><a href="#foot_note_2">[2]</a></sup>时还是发现自己对技术细节了解太少，甚至存在一些误解。</p>
<p>本文会介绍一些比特区块链的技术细节，同时尽力使其容易理解。</p>
<a id="more"></a>

<h2 id="比特币-bitcoin"><a href="#比特币-bitcoin" class="headerlink" title="比特币 bitcoin"></a>比特币 bitcoin</h2><p>所谓的比特币其实是<strong>交易</strong>组成的链。每个<strong>交易</strong>中包含大概信息就是<strong><em>谁把这个比特币转账给了谁，并且由转出比特币的人签字画押（数字签名<sup><a href="#foot_note_3">[3]</a></sup>）</em></strong>，具体来说如<a href="#pic_1">图1</a>，每个交易中包含</p>
<ul>
<li>收到比特币的人的公钥</li>
<li>由<strong>上一个交易</strong>和<strong>收到比特币的人的公钥</strong>组成的数据的哈希</li>
<li><strong>转出比特币的人的数字签名</strong>。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g91yo948kjj30lw0crab5.jpg" alt=""></p>
<center><span id="pic_1"><sub>图1： 交易链</sub></span></center>

<p>这样做的话，应该收到比特币的人就可以验证转出比特币的人是不是真的拥有这个比特币。方法就是用<strong>上一个</strong>交易中所有者的公钥去验证<strong>这次</strong>交易中的数字签名，这样就能知道这个比特币上一次被转账给了这次的转出者。</p>
<p>这里有个问题是转出比特币的人可能将同一个比特币转账给多个人，这样上面的交易链就会分叉。然而其实只有最早的那次转账是有效的，后面的转账都是非法的。为了验证交易是不是最早的一次转账，就需要一个<strong>公认的顺序</strong>。传统的方法是由中心节点指定一个顺序，大家被动接受。而比特币是通过多数人同意来认定一个顺序是不是<strong>公认</strong>的，这似乎也更符合<strong>公认</strong>这个词的含义。想要让（比特币系统所有参与者中的）多数人<strong>公认</strong>一个顺序，需要：</p>
<ul>
<li>向所有参与者广播所有的交易</li>
<li>多数参与者同意一个顺序</li>
</ul>
<p>在每次交易时，交易的接收者需要证明多数节点同意这次交易是最先收到的交易，这样接收者就能安心的完成交易了。</p>
<p><strong><em>区块链的主要任务就是达成这样的一个公认的顺序</em></strong>。</p>
<h2 id="区块链-blockchain"><a href="#区块链-blockchain" class="headerlink" title="区块链 blockchain"></a>区块链 blockchain</h2><p>区块链的基础是<strong>时间戳服务器</strong>，如<a href="#pic_2">图2</a>。</p>
<h3 id="时间戳服务器"><a href="#时间戳服务器" class="headerlink" title="时间戳服务器"></a>时间戳服务器</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g926rnfzp5j30om07gq38.jpg" alt=""></p>
<center><span id="pic_2"><sub>图2： 时间戳服务器</sub></span></center>

<blockquote>
<p>时间戳服务器计算包含多个需要被打时间戳的数据项的区块的哈希值并广泛地发布这个哈希值。时间戳能证明要得到这个哈希值，显然这些数据当时一定是存在的。每个时间戳的哈希值都纳入了上一个时间戳，形成一条链，后面的时间戳进一步增强前一个时间戳。</p>
<p><em>Bitcoin: A Peer-to-Peer Electronic Cash System<sup><a href="#foot_note_4">[4]</a></sup></em></p>
</blockquote>
<p>系统参与者通过在某个时间戳之后计算哈希来表示对某个顺序的认同，这样最长的链就是最多人认同的链，也就是我们想要的公认的顺序。</p>
<p>如果某个恶意参与者想要修改链中某个区块的内容，那必须把这个区块之后的哈希全部重算一遍，并且快速计算使自己这条链成为最长的，在所有人之前将最新哈希广播出去。这看上去是个比较难的任务，但并非不可完成，只要有足够快的计算机就可能做到。<strong>解决方法就是为计算哈希增加难度</strong>。</p>
<h3 id="工作量证明-Proof-of-Work"><a href="#工作量证明-Proof-of-Work" class="headerlink" title="工作量证明 Proof-of-Work"></a>工作量证明 Proof-of-Work</h3><p><a href="#pic_3">图3</a>是区块链中区块的内容：</p>
<ul>
<li>上一个区块的哈希</li>
<li>上面提到的比特币交易</li>
<li>一个随机数（这个随机数是用来调整计算哈希的难度的，也是工作量证明的关键）</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9281qoyhej30ow06smxl.jpg" alt=""></p>
<center><span id="pic_3"><sub>图3： 区块链</sub></span></center>

<blockquote>
<p>工作量证明采取搜索一个随机数，使得被哈希时，如使用 SHA-256，得到的哈希值以数个 0 比特开始。平均所需工作 量将随所需 0 比特呈指数级增长而验证却只需执行一次哈希。</p>
<p><em>Bitcoin: A Peer-to-Peer Electronic Cash System<sup><a href="#foot_note_4">[4]</a></sup></em></p>
</blockquote>
<p>比特币运行的步骤：</p>
<blockquote>
<ol>
<li>向所有节点广播<strong>新交易</strong></li>
<li>区块链节点将收集的新交易组成一个区块（如<a href="#pic_3">图3</a>）</li>
<li>计算满足要求（<em>工作量证明</em>）的哈希，既得到某个随机数</li>
<li>将这个区块（包含了满足要求的随机数）广播</li>
<li>其他节点确认区块中所有交易都没有被支付过，而且区块确实能够计算出满足要求的哈希</li>
<li>节点通过在这个区块之上继续计算表示对这个区块的接受</li>
</ol>
</blockquote>
<p>这样计算哈希的难度大大增加，恶意节点想要赶上并超过其他所有节点计算哈希的速度，就必须拥有巨量的计算力，而如果拥有这样的计算力，用作正常贡献获得的激励会超过作恶，这样就从动机上消除了作恶。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><span id="foot_note_1"><sub>[1]: SOSP</sub></span><br><span id="foot_note_2"><sub>[2]: Lind, J., Naor, O., Eyal, I., Kelbert, F., Sirer, E. G., &amp; Pietzuch, P. (2019, October). Teechain: a secure payment network with asynchronous blockchain access. In <em>Proceedings of the 27th ACM Symposium on Operating Systems Principles</em> (pp. 63-79). ACM.</sub></span></p>
<p><span id="foot_note_3"><sub>[3]: 可以通过我另一片博客了解：<a href="[https://zhang-tianxu.github.io/chinese/2019/11/15/%E7%94%A8%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E8%A7%A3%E9%87%8ARSA%E5%8E%9F%E7%90%86/](https://zhang-tianxu.github.io/chinese/2019/11/15/用一个例子解释RSA原理/)">《用一个例子解释RSA原理》</a></sub></span></p>
<p><span id="foot_note_4"><sub>[4]: Bitcoin: A Peer-to-Peer Electronic Cash System. Satoshi Nakamoto.<a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener">https://bitcoin.org/bitcoin.pdf</a></sub></span></p>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>安全</category>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>bitcoin</tag>
        <tag>blockchain</tag>
        <tag>比特币</tag>
        <tag>区块链</tag>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title>用一个例子解释RSA原理</title>
    <url>/chinese/2019/11/15/%E7%94%A8%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E8%A7%A3%E9%87%8ARSA%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>RSA是一种非对称加密算法，是以三位发明者（Ron <strong>R</strong>ivest、Adi <strong>S</strong>hamir、Leonard <strong>A</strong>dleman）的last name的首字母组成的。（来自：<a href="[https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95](https://zh.wikipedia.org/wiki/RSA加密演算法)">维基百科，RSA加密算法</a>）</p>
<p>目前RSA被广泛使用，尤其在web server的密钥、SSH等领域。因其应用广泛，所以值得学习一下。我主要用一个简单的例子来解释RSA的运行原理，以及怎么（理论上）破解它。</p>
<p>但是讲解之前还是要强调，大家都在用并不代表就是安全的。抛去各种因素不考虑，单是计算机计算能力的快速提升就让RSA加密算法越来越不安全了。看完大家就有大概的了解了。</p>
<a id="more"></a>

<h2 id="概念解释（来自：维基百科，RSA加密算法）"><a href="#概念解释（来自：维基百科，RSA加密算法）" class="headerlink" title="概念解释（来自：维基百科，RSA加密算法）"></a>概念解释（来自：<a href="[https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95](https://zh.wikipedia.org/wiki/RSA加密演算法)">维基百科，RSA加密算法</a>）</h2><blockquote>
<p><strong>公钥与私钥的产生</strong></p>
<ol>
<li>随意选择两个大的素数$p$和$q$，$p$不等于$q$，计算$N=pq$。</li>
<li>$r =(p-1)(q-1)$</li>
<li>选择一个小于$r$的整数$e$，使$e$与$r$互质。</li>
<li>求得$e$关于$r$的模逆元，命名为$d$（既$(e \times d)\ \ mod\ \ 1 = r$）</li>
<li>将$p$和$q$的记录销毁。</li>
<li>$(N,e)$是公钥，$(N,d)$是私钥。Alice将她的公钥$(N,e)$传给Bob，而将她的私钥$(N,d)$藏起来。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>加密消息</strong><br>$密文 = 明文^e\ mod\ \ N\ $</p>
</blockquote>
<blockquote>
<p><strong>解密消息</strong></p>
<p>$明文 = 密文^d\ mod\ \ N$</p>
</blockquote>
<blockquote>
<p><strong>签名</strong></p>
<p>签名过程其实就是用私钥加密，公钥解密的过程，因为公钥智能解密对应私钥加密的消息，而私钥（理论上）不会被泄露，所以能够确定就是拥有私钥的人签的名。</p>
</blockquote>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>假设Alice想要通过一个不可靠的媒体接收Bob的一条私密消息，假设这个私密消息是99（如果像发送其他格式的消息，也需要转化为整数才行，这是不难的），那么详细过程如下：</p>
<ol>
<li>生成共私钥：<ol>
<li>选择两个素数11和17，那么$N = 11 \times 17 = 187$</li>
<li>$r = (11 -1) \times (17 -1) = 160$</li>
<li>找到一个与$r$互质的整数$e = 3$</li>
<li>由$( 3 \times d)\  mod\ \ 1 = 160$的$d$可为107。</li>
<li>将$N = 187$和$e = 3$作为公钥发给Bob，自己保留$N=187$和$d = 107$</li>
</ol>
</li>
<li>加密消息<ol>
<li>Bob想要发送私密消息99</li>
<li>$密文 = 99^e\  mod\ \ N = 99^3\ mod\ \ 187 = 143$</li>
<li>将密文143发送给Alice</li>
</ol>
</li>
<li>解密消息<ol>
<li>Alice拿到密文143</li>
<li>$明文 = 143^d\ mod\ \ N = 143^{107}\ mod\ \ 187 = 99$</li>
<li>这样Alice拿到了私密消息99</li>
</ol>
</li>
</ol>
<h2 id="破解RSA"><a href="#破解RSA" class="headerlink" title="破解RSA"></a>破解RSA</h2><p>从上面加解密的过程可以意识到开始时选择的两个素数的重要性。</p>
<p>拥有公钥（$N$和$e$）再算出开始时使用的两个素数，很容易就可以算出私钥：<br>$$<br>私钥d = ((11 - 1) \times (17 - 1) \times n + 1) \div e\<br> = (160 \times n + 1) \div 3\<br> = (160 \times 2 + 1) \div 3\<br> = 107<br>$$<br>其中$n$为正整数。</p>
<p><strong>所以将N分解为两个素数就等同于破解了密码</strong>，好在大素数分解目前还没有多项式时间算法，只能用暴力法试。但是只要算力和时间足够，这并没有想象中的困难，而且密钥生成的过程中有很多因素会削弱密钥的安全性。想具体了解，大家可以看 <strong><em>trailofbits</em></strong> 的博客 <em><a href="https://blog.trailofbits.com/2019/07/08/fuck-rsa/" target="_blank" rel="noopener">Seriously, stop using RSA</a></em></p>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>安全</category>
      </categories>
      <tags>
        <tag>encryption</tag>
        <tag>加密</tag>
        <tag>secure</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title>C与Python中的socket</title>
    <url>/chinese/2019/11/15/C%E4%B8%8EPython%E4%B8%AD%E7%9A%84socket/</url>
    <content><![CDATA[<h1 id="C与Python中的socket"><a href="#C与Python中的socket" class="headerlink" title="C与Python中的socket"></a>C与Python中的socket</h1><p>本文主要是想实现一下C与Python的socket通信，顺便说一下两者各自的socket编程。所以全篇结构如下：</p>
<ul>
<li>C中的socket</li>
<li>Python中的socket</li>
<li>C与Python的socket通信</li>
</ul>
<a id="more"></a>

<h2 id="C-中的socket"><a href="#C-中的socket" class="headerlink" title="C 中的socket"></a>C 中的socket</h2><p>这部分主要参考《UNIX环境高级编程（第3版）》</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOST <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 65432</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG <span class="meta-string">"Hello FROM C Server"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_fd;</span><br><span class="line">    <span class="keyword">int</span> client_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[BUFF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">local_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">remote_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;local_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(local_addr)); <span class="comment">//清零local_addr</span></span><br><span class="line">    local_addr.sin_family = AF_INET;</span><br><span class="line">    local_addr.sin_addr.s_addr = inet_addr(HOST);</span><br><span class="line">    local_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((server_fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span> ) <span class="comment">// 新建socket</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((bind(server_fd, (struct sockaddr *)&amp;local_addr, <span class="keyword">sizeof</span>(struct sockaddr))) &lt; <span class="number">0</span>) <span class="comment">// 绑定socket</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    listen(server_fd, <span class="number">10</span>); <span class="comment">// 监听socket</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sin_size = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">        <span class="keyword">if</span>( (client_fd = accept(server_fd, (struct sockaddr *)&amp;remote_addr, &amp;sin_size )) &lt;<span class="number">0</span> ) <span class="comment">// 接受client的链接请求</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"accept:"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">pid_t</span> handle_pid;</span><br><span class="line">        handle_pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(handle_pid == <span class="number">0</span>) <span class="comment">// 子进程处理请求</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(close(server_fd) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"close:"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> len = send(client_fd, MSG, <span class="keyword">sizeof</span>(MSG),<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"len = %d\n"</span>,len);</span><br><span class="line">            <span class="keyword">if</span>(len != <span class="keyword">sizeof</span>(MSG))</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"send:"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(close(client_fd) &lt; <span class="number">0</span>) <span class="comment">// 父进程关闭client的socket，继续监听。</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"close:"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(close(client_fd) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"close:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOST <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 65432</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFF_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(HOST);</span><br><span class="line">    server_addr.sin_port = htons(PORT);</span><br><span class="line">    <span class="keyword">if</span>((server_fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span> ) <span class="comment">// 新建socket</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((connect(server_fd, (struct sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(struct sockaddr)) &lt; <span class="number">0</span>) ) <span class="comment">// 连接server</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"connect:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = recv(server_fd, buf, BUFF_SIZE, <span class="number">0</span>); <span class="comment">//连接成功后接收信息</span></span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">        len = recv(server_fd, buf, BUFF_SIZE, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(server_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Python-中的socket"><a href="#Python-中的socket" class="headerlink" title="Python 中的socket"></a>Python 中的socket</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#server.py</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">65432</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">  s.bind((HOST, PORT))</span><br><span class="line">  s.listen(<span class="number">5</span>)</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, addr = s.accept()</span><br><span class="line">    <span class="keyword">with</span> conn:</span><br><span class="line">      conn.send(<span class="string">b"Hello From Python Server!"</span>)</span><br><span class="line">      conn.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#client.py</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">65432</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">  s.connect((HOST, PORT))</span><br><span class="line">  msg_part = s.recv(<span class="number">10</span>)</span><br><span class="line">  msg = msg_part</span><br><span class="line">  <span class="keyword">while</span> len(msg_parg) == <span class="number">10</span>:</span><br><span class="line">    msg += msg_parg</span><br><span class="line">    msg_parg = s.recv(<span class="number">10</span>)</span><br><span class="line">  msg += msg_part</span><br><span class="line">  print(msg)</span><br></pre></td></tr></table></figure>



<h2 id="C与Python的socket通信"><a href="#C与Python的socket通信" class="headerlink" title="C与Python的socket通信"></a>C与Python的socket通信</h2><p>C和Python通过套接字是可以直接通信的。需要注意的是消息的格式。socket传输的内容是byte流，C中可以使用强制类型转换，Python中则需要<code>pack()</code>与<code>unpack()</code>。</p>
<p>比如：</p>
<p>在C写的server端发送：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> msg = htonl(<span class="number">999</span>);</span><br><span class="line">send(client_fd, (<span class="keyword">const</span> <span class="keyword">void</span> *)&amp;msg, <span class="keyword">sizeof</span>(msg),<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>Python端接收：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> *</span><br><span class="line">(msg,) = unpack(<span class="string">'&gt;1I'</span>,socket.socket.recv(<span class="number">4</span>))</span><br><span class="line">print(msg)</span><br></pre></td></tr></table></figure>

<p><code>unpack()</code>的第一个参数表示格式，<code>&gt;1I</code>中的<code>&gt;</code>表示大端（相应的<code>&lt;</code>就表示小端），<code>1I</code>表示一个整数。</p>
<p><code>pack()</code>与<code>unpack()</code>的详细操作见<em>博主 *</em>三月沙** 的《<a href="https://sanyuesha.com/2018/03/10/why-pack-unpack/" target="_blank" rel="noopener">Python 中的 pack 和 unpack</a>》*。</p>
<hr>
<p>反过来也是一样：</p>
<p>在Python写的server中发送</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conn.send(pack(<span class="string">'&gt;I'</span>,<span class="number">999</span>))</span><br></pre></td></tr></table></figure>

<p>C写的client中接收：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> msg;</span><br><span class="line"><span class="keyword">int</span> len = recv(server_fd, (<span class="keyword">int</span> *)&amp;msg, <span class="keyword">sizeof</span>(<span class="keyword">int</span>),<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ntohl(*msg));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>专业学习</category>
        <category>后端</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Python</tag>
        <tag>socket</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记——Scaling Intel SGX Apps with Intel SGX Card</title>
    <url>/chinese/2019/07/08/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Scaling-Intel-SGE-Apps-with-Intel-SGX-Card/</url>
    <content><![CDATA[<h1 id="Scaling-Intel-SGX-Apps-with-Intel-SGX-Card"><a href="#Scaling-Intel-SGX-Apps-with-Intel-SGX-Card" class="headerlink" title="Scaling Intel SGX Apps with Intel SGX Card"></a>Scaling Intel SGX Apps with Intel SGX Card</h1><p>这边笔记完全来自下面这篇论文：</p>
<p>Chakrabarti S, Hoekstra M, Kuvaiskii D, et al. Scaling Intel® Software Guard Extensions Applications with Intel® SGX Card[C]//Proceedings of the 8th International Workshop on Hardware and Architectural Support for Security and Privacy. ACM, 2019: 6.</p>
<h2 id="太长不看版"><a href="#太长不看版" class="headerlink" title="太长不看版"></a>太长不看版</h2><p>本文介绍了一个Intel 提出的一个新硬件——Intel SGX Card，这个SGX Card可以直接插在普通服务器的PCIe插槽上，有了这个新硬件带来一下好处：</p>
<ol>
<li>使得普通服务器据有SGX特性</li>
<li>突破SGX的128MB的内存限制，使SGX应用程序得到扩展。但是在维持SGX特性的同时实现这种扩展是要在一定程度上牺牲性能的。</li>
</ol>
<p>本文演示了在不可信数据中心中利用Intel SGX Card部署Intel SGX应用程序的四种方法。 为了加速Intel SGX应用程序的内存扩展部署，论文作者们开发了一个内存共享库，用于主机和SGX Card之间的快速异步通信，并通过VNF用例突出显示SGX Card的能力。</p>
<a id="more"></a>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>云计算的出现彻底改变了大型互联网应用部署和扩展的方式。但是很多公司还是不想将IT基础设施迁移到云上，原因有二：</p>
<ol>
<li>通常意义上的安全考量</li>
<li>对于商业机密数据的保护</li>
</ol>
<p>Intel SGX技术针对在不可信公共云上计算隐私数据这种情况，提供了一种硬件强制实现的可信执行环境。但是到目前为止Intel SGX还是有两个限制：</p>
<ol>
<li>只支持<strong>单插槽平台</strong>（<em>single-socket platforms</em>）</li>
<li>安全内存被限制在128MB以内</li>
</ol>
<p>本文介绍了一个硬件——SGX Card，SGX Card的特性如下：</p>
<ul>
<li>有三个独立的CPU，用于处理需要安全保证的任务。</li>
<li>多个SGX Card可以通过PCI Express总线连接到服务器主机上，提升服务器的额外CPU数量。</li>
</ul>
<p>有了额外的SGX Card，云服务提供商（CSP）可以使他们现有的服务平台具有Intel SGX的防护能力。随着隐私数据计算需求的增加，CSP们可以逐步为他们的数据中心增加SGX Card。</p>
<p>本文主要描述了在云环境下如何通过SGX Card在保持既定服务器形式的情况下扩展资源密集型SGX应用。我们将展示如何跨SGX Card节点横向扩展SGX应用程序，同时将对性能的影响降至最低。</p>
<p>SGX Card使得Intel SGX</p>
<ul>
<li>支持双插槽服务器平台（<em>dual-socket server platforms</em>），并且可以很容易地和现有数据中心基础架构整合。</li>
<li>通过软件支持，使得应用程序可以在SGX Card上的三个$Intel^® Xeon^® E3$处理器横向扩展，以获得更多的安全内存。</li>
</ul>
<p>本文还有如下贡献：</p>
<ul>
<li>对SGX Card的分析</li>
<li>SGX Card的内存共享库</li>
<li>提出了四种能够高效利用SGX Card的软件架构</li>
<li>展示了一个SGX Card的应用案例</li>
</ul>
<h2 id="Intel-SGX"><a href="#Intel-SGX" class="headerlink" title="Intel SGX"></a>Intel SGX</h2><p>本问讨论如何提升应用程序的<strong>安全性</strong>和<strong>可扩展性</strong>，前者由Intel SGX保证，后者由SGX Card保证。</p>
<h3 id="Intel-SGX架构"><a href="#Intel-SGX架构" class="headerlink" title="Intel SGX架构"></a>Intel SGX架构</h3><p>Intel SGX是对Intel CPU的一个ISA（指令集架构）扩展，它提供了提升应用程序机密部分机密性和完整性的能力。尽管应用程序的非机密部分处在不可信内存，但是机密部分被放在SGX的enclave中，enclave是一段对包括操作系统和hypervisor在内的其他任意软件都是不透明的内存空间。出于enclave中的代码可以执行几乎所有的CPU指令，并且可以读取enclave内外的数据。然而enclave外的特权/非特权软件对enclave数据的直接读取都会失败。enclave数据离开CPU芯片时，Intel SGX都会对数据作额外的加密。所以尝试直接读取RAM数据的硬件攻击也是无法成功的。</p>
<p>在硬件层面上引入了一些新的x86指令，用于对enclave做initialize、enter、resume和exit操作。当处于enclave模式时，CPU禁止对kernel的上下文切换。所以想要执行系统调用就必须先离开enclave，执行完系统调用后再重新进入SGX。离开enclave时会刷新TLB（Translation Lookaside Buffer），但是TLB对性能来说是很重要的，所以对于I/O密集型应用（需要经常离开enclave）来说，Intel SGX会有比较高的性能开销。</p>
<p>为了实现enclave数据的私密性和完整性，增加了一个硬件——EPC（Enclave Page Cache）。EPC是物理内存中的一个区域，这块区域不能被对应enclave以外的任何软件存取。所有从CPU发送到EPC的数据都会被CPU-secific的临时密钥加密。将数据从EPC移动到CPU会对数据进行解密并确保其完整性。目前，EPC大小为128M，其中只有大约96MB可以被用户数据使用。这么大的内存对某些应用（比如KMS）是足够的，但是如果enclave的工作量超出EPC的大小，就必须执行代价高昂的分页。在现有版本的Intel SGX上想要达到好的性能，就必须通过限制代码和数据大小来避免分页。</p>
<h3 id="建立Intel-SGX架构"><a href="#建立Intel-SGX架构" class="headerlink" title="建立Intel SGX架构"></a>建立Intel SGX架构</h3><p>Intel SGX为应用程序提供了熟悉的构建环境。开发过程中的一个根本不同在于要把程序分为可信与不可信两部分，前者放在enclave中。一些类似于Intel SGX SDK的工具需要手动分割代码，但是可以自动生成一些用于两部分代码通信的粘合代码（glue code）。已经有人提出根据开发者提供的代码注释来分割现有应用的自动分割工具。另外还有一些工具允许直接重用现有程序，只需很少甚至不需要任何修改。所有用户代码都在enclave中执行，只有不受信任的I/O系统调用执行在外面。</p>
<p>应用程序不受信的任部分必须将数据传输到安全区，以便enclave对这些数据执行私密计算。 类似地，在安全区完成计算之后，它必须将结果传递回不受信任的应用程序（然后通过不受信任的I/O将这些结果转发给最终用户）。Intel SGX中enclave和不受信任部分代码之间唯一的通信方式是共享不受信任的应用程序内存（enclave可以不受信任内存中的数据）。将通过不受信任内存进行通信分为<strong>同步通信</strong>和<strong>异步通信</strong>两种。</p>
<p><strong>同步通信：</strong></p>
<p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190707190211447.png" alt="image-20190707190211447"></p>
<p>在同步模式中（如上图），不被信任的部分想要对私密数据执行私密操作时步骤如下：</p>
<ol>
<li>它必须把数据放在与enclave共享的内存中</li>
<li>然后进入enclave（也就是所谓的ECALL）</li>
<li>然后读取共享内存中的数据进行相应操作。</li>
</ol>
<p>同样的，enclave想要执行不可信操作时的过程也是：</p>
<ol>
<li>必须将该操作所需要的数据放入共享内存</li>
<li>然后离开（exits）enclave</li>
<li>然后该操作被不被信任的部分执行（这就是所谓的OCALL）</li>
</ol>
<p><strong>异步通信：</strong></p>
<p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190707190234316.png" alt="image-20190707190234316"></p>
<p>在异步模式下，不被信任的部分和enclave利用共享内存以生产者-消费者的模式独立执行。比如，不被信任的部分可能执行I/O操作并且在共享队列中存储网络包，同时enclave按照自己的节奏接受这些包。</p>
<p>不管是异步模式还是同步模式，不被信任的部分和enclave都可以运行在独立的地址空间。通过RPC和共享内存实现ECALLs和OCALLs</p>
<h2 id="Intel-SGX-Card"><a href="#Intel-SGX-Card" class="headerlink" title="Intel SGX Card"></a>Intel SGX Card</h2><p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190707223636636.png" alt="image-20190707223636636"></p>
<p>上图是SGX Card的硬件架构，其中PCH指平台路径控制器<em>Platform Controller Hub</em>，DIMM指双线存储器模块<em>Dual In-line Memory ModuleSP</em>指<em>Scable Processor</em>。从图中我们可以看出每个SGX Card有三个Intel Xeon E3 CPU，每个CPU有其自己的本地RAM和完整的软件堆栈，所以每个Card节点运行其自己的操作系统并且通过自己的网络与外界通信。这在单个机架中提供了更多的计算能力，从而增加了云密度。</p>
<p>SGX Card通过非透明的PCIe Bridge与主机（通常是Intel Xeon Scable Processor）。SGX Card中的每个处理器都连接着自己的PCH、Flash、DIMM，单个处理器独立工作并且可以被用作三个独立服务器。在本文中SGX Card每个Card节点（card node）。也就是说每个SGX Card包含三个Card节点，每个Card节点像独立计算机一样处理数据，被自己的操作系统管理。</p>
<p>将三个Card节点放在一个PCIe Card上的优点是在Card和主机之间移动数据时能够提供高吞吐量和低延迟，这是Intel SGX Card的显着特征，我们用这种特征来构建内存共享库并高效地扩展Intel SGX应用程序。</p>
<h3 id="从软件视角看SGX-Card"><a href="#从软件视角看SGX-Card" class="headerlink" title="从软件视角看SGX Card"></a>从软件视角看SGX Card</h3><p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190707230800302.png" alt="image-20190707230800302"></p>
<p>上图是Intel SGX Card的软件架构，可以看出，SGX Card通过建立在PCIe上的虚拟网络和块I/O与主机进行通信。所以每个Card节点有其独立的网络和文件系统。</p>
<p>主机通过专用的带外接口启动并管理每个Card节点，主机也会配置Card节点的网络。Card节点通过专用虚拟以太网链路与主机连接。Card节点的IP地址由主机或者外部DHCP服务器分配。Card节点的虚拟以太网接口和主机网络之间的虚拟桥接器使得Card节点能够与外部网络进行通信。</p>
<h3 id="Memory-access-model"><a href="#Memory-access-model" class="headerlink" title="Memory access model"></a>Memory access model</h3><p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190708093633782.png" alt="image-20190708093633782"></p>
<p>从途中可以看出SGX Card的每个CPU都运行在自己的内存空间中。这就意味之每个Card节点都有完全独立于主机和其他Card节点的DRMA内存。</p>
<p>如同之前的图2所示，Card上的CPU和主机上的CPU都连接到同一个PCI主线上。这种拓扑逻辑下CPU可以做到通过DMA对其他CPU物理地址的读写，PCI bridges在两边都会暴露一个DMA窗口，通过这个DMA窗口就能调用远程数据。在软件层面，通过正确的内存映射，运行在其中一个CPU上的应用程序可以存取运行在其他CPU上的应用程序的内存。要注意共享内存区域必须是固定的，以防止其他CPU通过DMA读取内存页时，该内存页的拥有者CPU上的操作系统将该页调出内存。</p>
<p>SGX Card在主机侧和Card侧都会暴露DMA engine，DMA engine在两侧可以存取的内存数量是由PCI配置空间寄存器来配置的。远程内存范围可以映射到相应CPU访问范围的MMIO（Memory-Mapped I/O）地址空间。由于主机和Card节点可以具有不同的存储量，因此主机和Card上的DMA窗口大小可以不同。 将DMA窗口映射到MMIO空间后，该范围将显示为系统物理地址空间的一部分，并且可以映射给任何打算访问远程内存的应用程序。</p>
<p>在Card上，只需要将MMIO内存空间映射给应用程序就足够了。此外，DMA还必须被编程为能够成为两侧物理地址空间的桥梁。需要注意的是，利用DMA窗口从主机到Card的通信和从Card到主机的通信是不同的。</p>
<p>Card上的PCI bridges仅桥接Card节点和主机之间的PCI通信，但不桥接多个Card节点之间的PCI通信。 这样做在保证安全的同时也是的Card节点不能通过共享存储器直接相互通信。 如果需要在Card节点之间共享存储器，则可以以两个或更多个Card节点共享主机上的一系列物理存储器，当然这样做会增加内存访问延迟。</p>
<h3 id="Cache-Coherency"><a href="#Cache-Coherency" class="headerlink" title="Cache Coherency"></a>Cache Coherency</h3><p>尽管主机和Card节点可以共享内存，但是它们的内存空间还是存在Cache Coherency的问题。因为PCI总线不是Cache Coherent的，所以在其中一个内存空间更改内存，并不会自动在另一个内存空间反映为dirty cache line。而且，因为缺少snooping机制，cache line的更新也不会反映在其他内存空间中。造成这些的主要原因是没有能够用来运行cache coherency协议的额外连接。另外对于相同物理地址的地址映射在不同的地址空间可能不同。</p>
<p>所以，运行在主机上的应用程序和运行在Card节点的应用程序的进程间通信会有额外的性能开销。在需要Coherency时为了保证正确性，CPU每次都必须直接（ 绕过Cache）读写远程内存。</p>
<p>为了减轻这个问题，为远程内存映射选取合适的缓存技术变得非常重要。一个明显但是错误的选择是使用默认的写回策略，因为写回策略不会吧Cache line刷到远端（只能由应用程序明确的指定刷新），这回引发应用程序的一些错误行为。另一种常见选择就是写穿策略。</p>
<p>不幸的是，写穿策略不能提供高效的写性能，因为每次写都将分别在PCI总线上发送。所以，为了正确且高效，如果应用想要写到远程内存，这是必须使用<em>write-combine</em>缓存：</p>
<p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190708141304500.png" alt="image-20190708141304500"></p>
<p><em>write-combine</em>缓存是Intel架构为了高效PCI总线传输而支持的一类内存缓存，它允许数据暂时存放在被称为WCB（<em>Write-Combine Buffer</em>）的缓存区，以burst的模式一起释放，而不是将数据作为单个bits/bytes传输。一旦WCB满了，或者明确的刷新时间发生，就会对远程内存执行一次<em>combine</em>写。<em>Write-Combine</em>提高了PCI总线的利用率，进而提升了性能。</p>
<h2 id="Intel-SGX应用运行在SGX-Card上"><a href="#Intel-SGX应用运行在SGX-Card上" class="headerlink" title="Intel SGX应用运行在SGX Card上"></a>Intel SGX应用运行在SGX Card上</h2><p>本文提出四种在SGX Card上设计安全SGX应用的方法：</p>
<ol>
<li>对于非资源密集型的单enclave SGX应用程序，可以将整个应用程序放入SGX Card节点。</li>
<li>只将应用程序的可信任部分加载到Card节点，其他部分运行在主机上。</li>
<li>如果是资源密集型应用程序、多enclave SGX应用程序，可以<em>network scale-out</em>的方法将应用程序部署在Card节点上，然后通过它们之间的虚拟网络实现通信。</li>
<li>最后主机和Card可以使用共享内存而不是网络I/O来实现通信。</li>
</ol>
<p>一般来说，现代数据中心的服务器都有一些（超过10个）PCIe插口，所以可以容纳多个SGX Card。不过下面的介绍中我们假设只有一个SGX Card。</p>
<p>下面对上面说的4种方法逐个介绍</p>
<h3 id="整个应用程序加载到SGX-Card节点"><a href="#整个应用程序加载到SGX-Card节点" class="headerlink" title="整个应用程序加载到SGX Card节点"></a>整个应用程序加载到SGX Card节点</h3><p>对SGX Card的最简单的使用就是将整个应用程序都运行在Card节点上。因为每个Card节点有它自己的操作系统、文件系统以及网络。这种部署不需要对SGX应用进行修改。</p>
<p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190708143911796.png" alt="image-20190708143911796"></p>
<p>此类部署通过与已部署的主机服务器共享空间和电源，解决了云密度问题并很好地适应现有数据中心。 每个主机可以继续执行自己的资源密集型计算，并且Card上的Card节点可以托管多个独立的SGX应用程序。</p>
<h3 id="只加载可信任部分"><a href="#只加载可信任部分" class="headerlink" title="只加载可信任部分"></a>只加载可信任部分</h3><p>前面提到过SGX应用程序的可信部分和不可信部分不能在同一地址空间执行。这使得应用程序的不可信部分运行在主机CPU，可信部分运行在Card节点这种部署方式成为可能。</p>
<p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190708144302939.png" alt="image-20190708144302939"></p>
<p>在这种部署方式下，应用程序的不可信部分运行在高性能的服务器上，另一方面，可信部分可以使用Card处理器的所有内核执行enclave中的计算，也可以向外扩展到同一主机上的其他Card节点。</p>
<p>这种部署方式所需要的人工划分的工作应该是最少的。如果原SGX应用程序的可信部分和非可信部分的通信是同步的，那么只有OCALL/ECALL层必须修改，用RPC替换原来的函数调用。如果通信是异步的，那么在应用程序启动期间，必须实例化主机和Card节点之间的共享内存区域。</p>
<h3 id="利用Network-Scale-Out"><a href="#利用Network-Scale-Out" class="headerlink" title="利用Network Scale-Out"></a>利用Network Scale-Out</h3><p>上面两种部署方式的一个主要缺陷就是单enclave SGX应用程序会被Card节点的EPC大小所限制。目前Intel SGX服务器的EPC内存是有限的，超过这个内存限制就会出现代价高昂的换页。</p>
<p>有了SGX Card，应用程序可以扩展到多个enclave上执行，比如计算和数据被分开不晒在Card节点上运行的几个enclave上。因此，一个SGX Card就可以将EPC内存扩大原来的3倍，如果有个更多SGX Card则可以将EPC内存扩展到更大。这种部署方式的另外一个好处就是所有enclave共享主机上的不可信RAM。</p>
<p>然而想要采用这种部署方式，原来的SGX应用程序必须经过修改以支持执行在独立EPC内存区域上的多个enclave。特别的，应用程序需要可信部分与不可信部分之间的高效通信方式：要么通过TCP/IP网络消息实现同步通信，要么通过共享内存实现异步通信。</p>
<p>前者比较简单，每个Card节点运行自己的TCP/IP网络栈，并且有自己独立的IP地址，对应用程序的修改和<em>只加载可信任部分</em>部署方式类似，用RPC替代直接的OCALL/ECALL。</p>
<p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190708151514478.png" alt="image-20190708151514478"></p>
<h3 id="利用内存扩展"><a href="#利用内存扩展" class="headerlink" title="利用内存扩展"></a>利用内存扩展</h3><p>应用程序的可信部分和非可信部分也可以通过共享内存通信。在启动时，不可信部分会在不可信RAM中实例化一个共享内存区域，然后告诉所有的enclave。在运行时，应用程序的不可信部分和可信部分都遵从一个应用程序指定协议，安全一致地存储/加载数据</p>
<p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190708152648689.png" alt="image-20190708152648689"></p>
<p>虽然我们主要使用内存扩展设计来实现主机和Card之间的共享内存通信，但我们也可以使用主机的共享内存作为每个Card节点几乎无限的不可信存储。 但是，Card节点上的enclave必须小心将其私有数据存储在不受信任的主机RAM中，并对其进行适当加密和完整性保护。<br>可以在PCIe总线上模拟主机和卡之间的共享内存。 由于Intel SGX Card节点与主机之间的共享内存不具有Cache Coherency，因此我们开发了一个库，可缓解Cache Coherency问题，并为不受信任的部分和enclave之间的通信提供高级别API。</p>
<h2 id="其他贡献"><a href="#其他贡献" class="headerlink" title="其他贡献"></a>其他贡献</h2><h3 id="威胁模型"><a href="#威胁模型" class="headerlink" title="威胁模型"></a>威胁模型</h3><p>在本文中我们使用和普通Intel SGX相同的威胁模型，可信基只有enclave以及主机和Card上的CPU。不被信任的包括SGX 应用的不可信部分、其他应用、所有的特权软件、主机和不可信SGX Card上的所有的硬件，主机和Card节点的通信也是不被信任的。</p>
<p>理论上，使用Intel SGX Card的部署具有与普通Intel SGX环境相同的威胁模型。用作通信的PCIe总线必须被看作不可信硬件组件，所以enclave必须保护所有的出入数据，用HMAC（<em>Hash-based Message Authentication Code</em>）保证完整性，用加密保证私密性，用版本号防止回滚。在两个Card节点的enclave与enclave通信时也需要同样的保护，因为它们的通信需要通过主机内存。如果通过PCIe发送的数据的pattern必须隐藏，那么就必须采用某种混淆计算来消除pattern。</p>
<h3 id="enclave的远程验证"><a href="#enclave的远程验证" class="headerlink" title="enclave的远程验证"></a>enclave的远程验证</h3><p>SGX应用程序的客户端在向enclave传输私密数据之前必须执行远程证明，以获得对enclave内和Intel SGX平台本身执行的代码的信任。对于SGX Card上的部署，远程验证有一下几个选择：</p>
<ol>
<li>一种简单的方法就是将Card节点暴露在外部网络中，进而暴露给最终用户。然后，客户端对在三个Card节点上运行的三个enclave进行远程证明。 这种方法的缺点是客户必须知道SGX Card上的所有enclave并执行多轮网络通信。</li>
<li>用户将整个服务器看作一个黑盒。每个用户只需要验证作为信任根的那个enclave。这个enclave在去验证其他enclave。如果有多个SGX Card，可以利用信任链验证所有的enclave。</li>
<li>数据中心可能有一个类似OpenStack Barbican的运行在enclave内的密钥管理器，可以证明数据中心所有SGX Card上的所有enclave。因此，该密钥管理器成为信任和供应的单一根。</li>
</ol>
<h2 id="内存共享库"><a href="#内存共享库" class="headerlink" title="内存共享库"></a>内存共享库</h2><p>如同上面提到的，SGX Card允许应用程序通过共享内存实现扩展。大量数据可以在运行在主机上的不可信部分和运行在SGX Card上的可信部分间快速传输。</p>
<p>对于Intel SGX应用程序，尽管不可信部分和可信部分运行在不同的计算平台上，但在Card节点上运行的enclave可以直接与主机上的不可信应用程序通信，而不会离开enclave这种模式能够提供性能上的提升。 应用程序的不受信任部分可以在主机平台上进行扩展，而可信部分可以在多个Card节点上进行扩展以满足性能要求。</p>
<h3 id="库的设计"><a href="#库的设计" class="headerlink" title="库的设计"></a>库的设计</h3><p>我们设计并且建立了一个内存共享库，它为应用程序提供用来利用PCIe主线远程共享内存的高级别API。</p>
<p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190708161348110.png" alt="image-20190708161348110"></p>
<p>这个库有三个级别的API：</p>
<ol>
<li>使用<em>Write-Combine</em>的低级别的共享内存访问原语API</li>
<li>为主机和Card节点通信提供的异步队列API</li>
<li>为主机和Card节点之间任务分配提供的任务队列API</li>
</ol>
<p>低级别API提供了初始化主机和Card节点上的共享内存区域的功能。 初始化内存区域后，开发人员可以调用低级别API函数来读取和写入远程内存（使用写入组合缓存策略）。</p>
<p>异步队列API提供函数在主机和Card节点之间建立一个SPSC（<em>Single Producer Single Consumer</em>）共享队列，并且提供两个函数来实现出列和入列。通常，应用程序开发人员将创建与Card节点一样多的队列，以便主机将对特定Card节点的请求放入相应队列进行排队。</p>
<p>任务队列API提供函数建立SPMC（<em>Single Producer Multiple Consumer</em>）队列，其他和异步队列API类似。这当主机将可由任何可用Card节点执行的请求排入队列时，这个API对于任务分发非常有用。</p>
<h3 id="库的实现"><a href="#库的实现" class="headerlink" title="库的实现"></a>库的实现</h3><p>内存共享库的基础是使用SGX Card PCIe驱动提供的API任意编程DMA引擎的能力，该库利用Sysfs等抽象用户空间接口进行DMA引擎编程。</p>
<p>要调度应用程序请求，库必须与远程端的对应方通信。 该通信发生在现有的虚拟网络接口或基于PCI的通信协议上。</p>
<p>在我们的实现远行中在主机上的不可信应用程序存储一块内存然后告诉SGX Card驱动它打算和指定Card节点共享这块内存。同时Card节点上的enclave也会请求驱动将远程内存映射到它的地址空间。结果，主机上的驱动向Card节点上的驱动提供物理地址（或物理地址范围）。 然后，SGX Card上的驱动通过这些远程物理地址之间的映射对DMA引擎进行编程，并将MMIO范围映射到SGX Card上应用程序的地址空间中。</p>
<p>这个基础通信渠道一旦建立，异步通信原语和任务队列就可用于主机上的不可信应用程序和Card节点上的enclave之间的高级别数据交换。</p>
<p>注意到如果应用程序为内存共享保留4KB的页，那内存共享库可能需要在DAM引擎中创建多个映射，因为物理地址可能是不连续的。在理想状态下，应用程序应该使用2MB到1GB的巨页来保留共享内存。使用巨页可确保连续的物理地址范围。 由于操作系统永远都不会讲巨页换出，所以巨页还具有确保内存永久固定的好处。</p>
<h3 id="总体性能"><a href="#总体性能" class="headerlink" title="总体性能"></a>总体性能</h3><p>通常情况下CPU和DRAM之间的存取时间大约是100ns，而CPU和PCI寄存器之间的存取时间大约在400ns-500ns之间。远程内存读取因为增加了PCI和DRAM之间的存取，所以会额外增加大约100ns的开销。通常，与本地内存相比访问远程内存时开销可能达到约5倍，因此应用程序的吞吐量会下降。然而，吞吐量的这种下降可以通过并行计算来补偿。 通过在Intel SGX Card上的多个Card节点上使用多个Intel SGX enclave，并将请求分配给这些enclave（使用内存共享），我们可以提高应用程序的整体吞吐量。</p>
<h2 id="用例——VNF（Virtual-Network-Function）"><a href="#用例——VNF（Virtual-Network-Function）" class="headerlink" title="用例——VNF（Virtual Network Function）"></a>用例——VNF（Virtual Network Function）</h2><p>为了展示Intel SGX Card的能力，我们从零开发了可扩展的支持Intel SGX的安全监控VNF。我们的安全监视器检查网络上的所有数据包，并根据远程管理员提供的预定义规则进行转发。</p>
<h3 id="VNF的架构"><a href="#VNF的架构" class="headerlink" title="VNF的架构"></a>VNF的架构</h3><p>我们的VNF运行在enclave中，包含L2/L3网络功能，支持Cuckoo哈希查找表和IPSec，关闭TLS/SSL以实现和远程管理员控制台的安全通信。远程管理员与enclave建立安全的SSL通道，执行远程证明，然后将协议规则和哈希表条目发送到enclave。 初始化后，enclave会连续运行安全监视器VNF，并将统计信息发送回远程管理员。</p>
<p>在将VNF一直到enclave的过程中遇到了一些挑战：</p>
<ol>
<li>在Intel SGX中ECALL/OCALL的代价高昂，所以我们希望尽量减少进出enclave的次数。</li>
<li>EPC换页在当前的Intel SGX实现下代价高昂，所以我们力争尽量减小VNF占用的内存大小。</li>
</ol>
<p>基于上面的设计要求，我们把VNF切分，运行在两个核上：</p>
<p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190708190831527.png" alt="image-20190708190831527"></p>
<p>数据包I/O发生在第一个核生的不可信内存中，而安全监控则在第二个内核的enclave内运行。在第一个核上的不可信部分接受来自NIC的数据包，将指向数据的指针通过RX ring转发给第二个核，然后第二个核上的enclave执行真正的VNF处理所有数据包。第一个核从第二个核接受信息并且将被准许的修改过的数据包通过TX ring发回给NIC。安全监视器VNF永远不会离开enclave，其内存占用空间仅包含带有规则的哈希表，而不包括网络数据包。</p>
<p>这个设计在保证监视器规则隐私性和完整性的同时，性能下降少于10%。（注意我们是要保护远程配置的规则/策略，而不是网络数据包内容。）在我们的实验中，我们不会被SGX限制，而是被NIC 40Gbps的容量限制。为了扩展到40Gbps以上，我们将安全监视器VNF移植到Intel SGX Card上。</p>
<h3 id="在Intel-SGX上扩展VNF"><a href="#在Intel-SGX上扩展VNF" class="headerlink" title="在Intel SGX上扩展VNF"></a>在Intel SGX上扩展VNF</h3><p>我们在安全监视器用例中使用了内存扩展。为此，我们修改了VNF的receive/transmit rings以在内存共享库上运行。这使我们能够利用主机CPU上的四个核协助NIC将数据包转发到一个Card节点上的四个核。一旦使用内存共享库提供的API初始化底层生产者/消费者异步队列，我们的安全监视器就可以无缝地工作了。在内存扩展的过程中我们没有遇到具体问题。<br>我们用五个NIC和五个Card节点评估了我们的原型。为了维持吞吐量，我们在主机CPU上使用了20个内核来处理数据包I/O.在实验中，我们使用Cuckoo哈希表执行5元组查找，在384B大小的TCP/IP数据包上有100K条目;每个enclave使用8个超线程。我们的实验表明完美的可扩展性：我们的基于SGX Card的安全监控器在零数据包丢失的情况下实现了200Gbps的吞吐量，是单个Intel SGX enclave的整整五倍。</p>
<p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190708195153068.png" alt="image-20190708195153068"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们演示了在不受信任的数据中心中使用Intel SGX Card部署Intel SGX应用程序的四种方法。 为了促进Intel SGX应用程序的内存扩展部署，我们开发了一个内存共享库，用于主机和SGX Card之间的快速异步通信，并通过VNF用例突出显示SGX Card的能力。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>Chakrabarti S, Hoekstra M, Kuvaiskii D, et al. Scaling Intel® Software Guard Extensions Applications with Intel® SGX Card[C]//Proceedings of the 8th International Workshop on Hardware and Architectural Support for Security and Privacy. ACM, 2019: 6.</li>
<li>Ittai Anati, Shay Gueron, Simon Johnson, Vincent Scarlata. Innovative technology for CPU based attestation and sealing. HASP’2013 </li>
<li>Victor Costan, Srinivas Devadas. Intel® SGX Explained.IACR Cryptology ePrint Archive, 2016 </li>
<li>Meni Orenbach, Pavel Lifshits, Marina Minkin, Mark Silberstein. Eleos: ExitLess OS Services for SGX Enclaves. EuroSys’2017 </li>
<li>Sergei Arnautov, Bohdan Trach, Franz Gregor, Thomas Knauth, Andre Martin, Christian Priebe, Joshua Lind, Divya Muthukumaran, Dan O’Keeffe, Mark L. Stillwell, David Goltzsche, David Eyers, Rüdiger Kapitza, Peter Pietzuch, Christof Fetzer. SCONE: secure Linux containers with Intel® SGX. OSDI’2016 </li>
<li><a href="https://github.com/intel/linux-sgx" target="_blank" rel="noopener">https://github.com/intel/linux-sgx</a>. Intel SGX for Linux. Accessed: 2019 </li>
<li>Andrew Baumann, Marcus Peinado, Galen Hunt. Shielding applications from an untrusted cloud with Haven. OSDI’2014 </li>
<li>Chia-Che Tsai, Mona Vij, Donald Porter. Graphene-SGX: A Practical Library OS for Unmodified Applications on SGX. USENIX ATC’2017 </li>
<li>Joshua Lind, Christian Priebe, Divya Muthukumaran, Dan O’Keeffe, Pierre-Louis Aublin, Florian Kelbert, Tobias Reiher, David Goltzsche, David Eyers, Rudiger Kapitza, Christof Fetzer, Peter Pietzuch. Glamdring: Automatic Application Partitioning for Intel SGX. ATC’2017 </li>
<li>Ofir Weisse, Valeria Bertacco, Todd Austin. Regaining Lost Cycles with HotCalls: A Fast Interface for SGX Secure Enclaves. ISCA’2017 </li>
<li>Dmitrii Kuvaiskii, Somnath Chakrabarti, Mona Vij. Snort Intrusion Detection System with Intel Software Guard Extension (Intel SGX). arXiv:1802.00508, 2018 </li>
<li>Bohdan Trach, Alfred Krohmer, Sergei Arnautov, Franz Gregor, Pramod Bhatotia, Christof Fetzer. Slick: Secure Middleboxes using Shielded Execution. arXiv:1709.04226, 2017 </li>
<li>Hagit Attiya, Amotz Bar-Noy, Danny Dolev. 1995. Sharing memory robustly in message-passing systems. J. ACM 42, 1 1995 </li>
<li><a href="https://asylo.dev" target="_blank" rel="noopener">https://asylo.dev</a>. Google Asylo. Accessed: 2019 </li>
<li>Wenting Zheng, Ankur Dave, Jethro G. Beekman, Raluca Ada Popa, Joseph E. Gonzalez, Ion Stoica. Opaque: an oblivious and encrypted distributed analytics platform. NSDI’2017 </li>
<li>sajin Sasy, Sergey Gorbunov, Christopher Fletcher. ZeroTrace:  Oblivious Memory Primitives from Intel SGX. Cryptology ePrint Archive, 2017 </li>
<li><a href="https://redis.io" target="_blank" rel="noopener">https://redis.io</a>. Redis. Accessed: 2019</li>
<li>Felix Schuster, Manuel Costa, Cédric Fournet, Christos Gkantsidis, Marcus Peinado, Gloria Mainar-Ruiz, Mark Russinovich. VC3: Trustworthy Data Analytics in the Cloud Using SGX. SP’2015 </li>
<li>Olga Ohrimenko, Felix Schuster, Cédric Fournet, Aastha Mehta, Sebastian Nowozin, Kapil Vaswani, Manuel Costa. Oblivious Multi-Party Machine Learning on Trusted Processors. USENIX Security’2016 </li>
<li>Tyler Hunt, Zhiting Zhu, Yuanzhong Xu, Simon Peter, Emmett Witchel. Ryoan: a distributed sandbox for untrusted computation on secret data. OSDI’2016 </li>
<li>Seongmin Kim, Juhyeng Han, Jaehyeong Ha, Taesoo Kim, Dongsu Han. Enhancing security and privacy of tor’s ecosystem by using trusted execution environments. NSDI’2017 </li>
<li>Shweta Shinde, Dat Le Tien, Shruti Tople, Prateek Saxena. Panoply: Low-TCB Linux Applications with SGX Enclaves. NDSS’2017 </li>
<li>Ming-Wei Shih, Mohan Kumar, Taesoo Kim, and Ada Gavrilovska. S-NFV: Securing NFV states by using SGX. SDN-NFV Security’2016 </li>
<li>David Goltzsche, Signe Rüsch, Manuel Nieke, Sébastien Vaucher, Nico Weichbrodt, Valerio Schiavoni, Pierre-Louis Aublin, Paolo Costa, Christof Fetzer, Pascal Felber, Peter Pietzuch, Rüdiger Kapitza. EndBox: Scalable Middlebox Functions Using Client-Side Trusted Execution. DSN’2018 </li>
<li>Michael Coughlin, Eric Keller, Eric Wustrow. Trusted Click: Overcoming Security issues of NFV in the Cloud. SDN- NFVSec’2017 </li>
<li>Huayi Duan, Xingliang Yuan, Cong Wang. LightBox: SGX-assisted Secure Network Functions at Near-native Speed. arXiv:1706.06261, 2017 </li>
<li>Alexey Gribov, Dhinakaran Vinayagamurthy, Sergey Gorbunov. StealthDB: a Scalable Encrypted Database with Full SQL Query Support. arXiv:1711.02279, 2017 </li>
<li>Saba Eskandarian, Matei Zaharia. ObliDB: Oblivious Query Processing using Hardware Enclaves. arXiv:1710.00458, 2018 </li>
<li>Christian Priebe, Kapil Vaswani, Manuel Costa. EnclaveDB: A Secure Database using SGX. SP’2018 </li>
<li>Rohit Sinha, Mihai Christodorescu. VeritasDB: High Throughput Key-Value Store with Integrity. Cryptology ePrint Archive 2018/251, 2018 </li>
<li><a href="https://www.intel.com/content/www/us/en/products/servers/accelerat" target="_blank" rel="noopener">https://www.intel.com/content/www/us/en/products/servers/accelerat</a> ors/visual-compute-accelerator-SGX accelerator1585lmv.html. Intel Visual Compute accelerator (Intel SGX Card). Accessed: 2018 </li>
<li><a href="https://redis.io/topics/cluster-spec" target="_blank" rel="noopener">https://redis.io/topics/cluster-spec</a>. Redis Cluster Specification. Accessed: 2019 </li>
<li><a href="https://github.com/twitter/twemproxy" target="_blank" rel="noopener">https://github.com/twitter/twemproxy</a>. twitter/twemproxy. Accessed: 2019 </li>
<li>Yelick, Bonachea, Chen, Colella, Datta, Duell, Graham, Hargrove, Hilfinger, Husbands, and Iancu. Productivity and performance using partitioned global address space languages. PASCO’2007 </li>
<li>Aaftab Munshi, Benedict Gaster, Timothy G. Mattson, and Dan Ginsburg. OpenCL programming guide. Pearson Education, 2011 </li>
<li>Marcus Brandenburger, Christian Cachin, Rüdiger Kapitza, Alessandro Sorniotti. Blockchain and Trusted Computing: Problems, Pitfalls, and Solution for Hyperledger Fabric. arXiv:1805.08541, 2018</li>
<li>Rolf Neugebauer, Gianni Antichi, José Fernando Zazo, Yury Audzevich, Sergio López-Buedo, Andrew W. Moore. Understanding  PCIe performance for end host networking. SIGCOMM ‘2018 </li>
<li>Somnath Chakrabarti, Brandon Baker, Mona Vij. Intel SGX Enabled Key Manager Service with OpenStack Barbican. ArXiv:1712.07694, 2017</li>
<li>Jack Regula. Using non-transparent bridging in PCI Express systems. PLX Technology white paper, 2004 </li>
<li><a href="http://www.cpushack.com/tag/knights-corner" target="_blank" rel="noopener">http://www.cpushack.com/tag/knights-corner</a>. CPU of the Day: The 61 Knights of the Intel Xeon Phi. Accessed: 2019 </li>
</ol>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>学术</category>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>SGX</tag>
        <tag>paper</tag>
        <tag>论文</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>在k8s上部署Jenkins</title>
    <url>/chinese/2019/06/26/%E5%9C%A8k8s%E4%B8%8A%E9%83%A8%E7%BD%B2Jenkins/</url>
    <content><![CDATA[<h1 id="在k8s上部署Jenkins"><a href="#在k8s上部署Jenkins" class="headerlink" title="在k8s上部署Jenkins"></a>在k8s上部署Jenkins</h1><p>谷歌在k8s上部署Jenkins的方法，都写的很复杂，各种配置文件一堆，还都失败了！<strong>最终部署成功后发现只需要一句命令就可以了。</strong></p>
<a id="more"></a>

<p>这个命令就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl run jenkins --image&#x3D;jenkinsci&#x2F;blueocean --port 5000</span><br></pre></td></tr></table></figure>

<p>命令解释</p>
<ol>
<li><code>--image=jenkinsci/blueocean</code>用来指定镜像，<a href="https://hub.docker.com/r/jenkinsci/blueocean/" target="_blank" rel="noopener"><code>jenkinsci/blueocean</code> image</a>(来自 the <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub repository</a>)。 该镜像包含当前的<a href="https://jenkins.io/download" target="_blank" rel="noopener">长期支持 (LTS) 的Jenkins版本</a> （可以投入使用） ，捆绑了所有Blue Ocean插件和功能。这意味着你不需要单独安装Blue Ocean插件。</li>
<li><code>--port 端口号</code>用于指定deployment的端口号，可以随便指定.</li>
</ol>
<p>通过<code>kubectl get deployments</code>可以看到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME       READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">jenkins    1&#x2F;1     1            1           10s</span><br></pre></td></tr></table></figure>

<p>显示READY说明deployment创建成功。这是在本地集群已经可以访问，如果想要在外部访问，需要将deployment暴露未service：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment jenkins --type&#x3D;NodePort --target-port&#x3D;8080</span><br></pre></td></tr></table></figure>

<p>命令解释：</p>
<ol>
<li><code>--type=NodePort</code>是将service的类型设置为NodePort，这样才能被外部看到</li>
<li><code>--target-port=8080</code>是映射（例如“发布”）<code>jenkinsci/blueocean</code> 容器的端口8080到主机上的端口8080</li>
</ol>
<p>这一步完成后执行<code>kubectl get service</code>查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)           AGE</span><br><span class="line">jenkins     NodePort    10.107.210.195   &lt;none&gt;        5000:30509&#x2F;TCP    6m35s</span><br></pre></td></tr></table></figure>

<p>可以看出service对外暴露的端口是30509，可以通过<code>kubectl edit service jenkins</code>命令将配置中的<code>- nodePort</code>修改为你想要暴露出去的端口即可。</p>
<p>浏览器访问得</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/DevOps/jenkins/unlock_jenkins.png" alt="image-20190626205811349"></p>
<p>这里要求<strong><em>Administrator password</em></strong>，正常来说是通过<code>/var/jenkins_home/secrets/initialAdminPassword</code>来查看，但是因为运行在docker中，所以需要查看docker的log。我们这里更进一步又把docker放到了k8s中，所以要查看jenkins的docker对应的pod的log，方法如下：</p>
<ol>
<li><p><code>kubectl get pods</code>，找到jenkins对应的pod的NAME，我的对应的名称为jenkins-747ddfbdb6-4msmw</p>
</li>
<li><p><code>kubectl logs jenkins-747ddfbdb6-4msmw</code>查看pod的log</p>
</li>
<li><p>在显示的log中就有我们需要的<strong><em>Administrator password</em></strong>，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jenkins.install.SetupWizard init</span><br><span class="line">INFO:</span><br><span class="line"></span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br><span class="line"></span><br><span class="line">Jenkins initial setup is required. An admin user has been created and a password generated.</span><br><span class="line">Please use the following password to proceed to installation:</span><br><span class="line"></span><br><span class="line">7f54c6c500e242e9bbc804c169c52a3c</span><br><span class="line"></span><br><span class="line">This may also be found at: &#x2F;var&#x2F;jenkins_home&#x2F;secrets&#x2F;initialAdminPassword</span><br><span class="line"></span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br></pre></td></tr></table></figure>

<p>输入上面的password就能进入注册界面：</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/DevOps/jenkins/create_admin_user.png" alt="image-20190626210358399"></p>
</li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>Jenkins官方文档：<a href="https://jenkins.io/zh/doc/book/installing/#setup-wizard" target="_blank" rel="noopener">https://jenkins.io/zh/doc/book/installing/#setup-wizard</a></p>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>DevOps</category>
        <category>CI&amp;CD</category>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>环境配置</tag>
        <tag>DevOps</tag>
        <tag>Jenkins</tag>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title>为k8s配置可视化</title>
    <url>/chinese/2019/06/24/%E4%B8%BAk8s%E9%85%8D%E7%BD%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<h1 id="为k8s配置可视化"><a href="#为k8s配置可视化" class="headerlink" title="为k8s配置可视化"></a>为k8s配置可视化</h1><p>K8s dashboard是k8s集群的web-based UI工具，用户可以通过dashboard管理运行在集群上的应用以及集群自身。</p>
<p>安装本身非常容易，只需要下面一条语句就可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;dashboard&#x2F;v1.10.1&#x2F;src&#x2F;deploy&#x2F;recommended&#x2F;kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure>

<p>但是再次由于墙的原因，国内执行这条语句会出现<code>ErrImagePull</code>的错误。如果你已经执行了，就需要删除这个pod。但是如果直接用<code>kubectl delete pods &lt;pod name&gt; --namespace=&lt;namespace&gt;</code>的话，通过<code>kubectl get pods --all-namespaces</code>查看会发现它马上就会重新建立。这是因为要直接删除<code>kubectl delete deployment &lt;deployment name&gt;</code>。</p>
<a id="more"></a>

<p>所以在国内还得需要镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull registry.cn-qingdao.aliyuncs.com&#x2F;wangxiaoke&#x2F;kubernetes-dashboard-amd64:v1.10.0</span><br><span class="line">docker tag registry.cn-qingdao.aliyuncs.com&#x2F;wangxiaoke&#x2F;kubernetes-dashboard-amd64:v1.10.0 k8s.gcr.io&#x2F;kubernetes-dashboard-amd64:v1.10.0</span><br><span class="line">docker image rm registry.cn-qingdao.aliyuncs.com&#x2F;wangxiaoke&#x2F;kubernetes-dashboard-amd64:v1.10.0</span><br></pre></td></tr></table></figure>

<p>下载完镜像后执行<code>kubectl apply -f http://mirror.faasx.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml</code>就部署完成了，可以通过命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;kubectl get pods --namespace&#x3D;kube-system&#96;</span><br></pre></td></tr></table></figure>

<p>查看，然后可以通过<code>kubectl get service --namespace=kube-system</code>查看dashboard的外网暴露端口。如果发现暴露的端口类型是<code>ClusterIP</code>，可以运行<code>kubectl edit service  kubernetes-dashboard --namespace=kube-system</code>大概配置文件，找到type，将ClusterIP改成NodePort。同时也可以通过这个命令修改<code>NodePort</code>以达到修改暴露端口的目的。</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/DevOps/k8s/kubectl_edit_service.png" alt="image-20190624073355080"></p>
<p>现在在本级上通过访问<code>localhost:端口</code>就能访问图形界面了。但是想要在其他机器访问，需要SSL证书，通过https来访问。</p>
<ol>
<li><p>生成私钥和证书签名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl genrsa -des3 -passout pass:x -out dashboard.pass.key 2048</span><br><span class="line">openssl rsa -passin pass:x -in dashboard.pass.key -out dashboard.key</span><br><span class="line">rm dashboard.pass.key</span><br><span class="line">openssl req -new -key dashboard.key -out dashboard.csr</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成SSL证书</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -sha256 -days 365 -in dashboard.csr -signkey dashboard.key -out dashboard.crt</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建dashboard用户</p>
<p>执行<code>kubectl create -f dashboard-user-role.yaml</code>命令，其中<code>dashboard-user-role.yaml</code>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: ClusterRoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io&#x2F;v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: admin</span><br><span class="line">  annotations:</span><br><span class="line">    rbac.authorization.kubernetes.io&#x2F;autoupdate: &quot;true&quot;</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin</span><br><span class="line">  namespace: kube-system</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    kubernetes.io&#x2F;cluster-service: &quot;true&quot;</span><br><span class="line">    addonmanager.kubernetes.io&#x2F;mode: Reconcile</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取登陆dashboard的token</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl describe secret&#x2F;$(kubectl get secret -nkube-system |grep admin|awk &#39;&#123;print $1&#125;&#39;) -nkube-system</span><br></pre></td></tr></table></figure>

<p>该语句返回的结果中会包含token</p>
</li>
<li><p>登陆</p>
<p>在其他机器浏览器访问<code>https://master的ip:暴露端口</code>，比如我的例子中就是<code>https://10.0.0.23:30502</code>。登陆时选择token登陆，粘贴上面命令返回的token就可以成功登陆。</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/DevOps/k8s/k8s_dashboard.png" alt="image-20190623211428221"></p>
</li>
</ol>
<h2 id="部署官方用例"><a href="#部署官方用例" class="headerlink" title="部署官方用例"></a>部署官方用例</h2><p>官方给出了用于测试的用例，如果k8s部署正确的话，可以直接通过下面的两条命令部署：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create namespace sock-shop</span><br><span class="line"></span><br><span class="line">kubectl apply -n sock-shop -f &quot;https:&#x2F;&#x2F;github.com&#x2F;microservices-demo&#x2F;microservices-demo&#x2F;blob&#x2F;master&#x2F;deploy&#x2F;kubernetes&#x2F;complete-demo.yaml?raw&#x3D;true&quot;</span><br></pre></td></tr></table></figure>

<p><code>kubectl edit service  front-end --namespace=sock-shop</code>来编辑服务的配置，主要是端口。</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/DevOps/k8s/kubectl_edit_service_2.png" alt="image-20190624073309186"></p>
<p>部署完成后通过<code>NodePort:端口</code>可以直接访问，是一个袜子购物网站，支持购物车等功能：</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/DevOps/k8s/sock_shop.png" alt="image-20190624073545125"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>k8s dashboard官方：<a href="https://github.com/kubernetes/dashboard#kubernetes-dashboard" target="_blank" rel="noopener">https://github.com/kubernetes/dashboard#kubernetes-dashboard</a></li>
<li>K8s heapster官方：<a href="https://github.com/kubernetes-retired/heapster" target="_blank" rel="noopener">https://github.com/kubernetes-retired/heapster</a></li>
</ol>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>DevOps</category>
        <category>容器</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
        <tag>环境配置</tag>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>centos安装和配置Jenkins</title>
    <url>/chinese/2019/03/21/centos%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEJenkins/</url>
    <content><![CDATA[<h1 id="centOS-安装配置Jenkins"><a href="#centOS-安装配置Jenkins" class="headerlink" title="centOS 安装配置Jenkins"></a>centOS 安装配置Jenkins</h1><p><img src="data:image/png;base64,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" alt="jenkins"></p>
<p>我是在阿里云的ECS上部署Jenkins的，ECS无法提供图形界面的显示，这带来了几个问题：</p>
<ol>
<li><p>文件下载和传输不方便<br>采用Xftp等ftp工具。</p>
</li>
<li><p>配置Jenkins要访问localhost，ECS上没办法使用浏览器</p>
<p>利用公网IP，在其他机器上访问和控制。</p>
</li>
</ol>
<a id="more"></a>

<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p><a href="https://jenkins.io/zh/doc/pipeline/tour/getting-started/" target="_blank" rel="noopener">官网</a>给出的依赖要求：</p>
<blockquote>
<p>第一次使用 Jenkins，您需要：</p>
<ul>
<li>机器要求：<ul>
<li>256 MB 内存，建议大于 512 MB</li>
<li>10 GB 的硬盘空间（用于 Jenkins 和 Docker 镜像）</li>
</ul>
</li>
<li>需要安装以下软件：<ul>
<li>Java 8 ( JRE 或者 JDK 都可以)</li>
<li><a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a> （导航到网站顶部的Get Docker链接以访问适合您平台的Docker下载）</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="安装java"><a href="#安装java" class="headerlink" title="安装java"></a>安装java</h3><ol>
<li><p>去<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">官网</a>下载相应版本，对于centos是 Linux x64的<code>.tar.gz</code>版本。（因为官方需要点击<em>Accept License Agreement</em>才能下载，利用<code>wget</code>是默认不同意，虽然可以下载，但是不能实现解压。）</p>
</li>
<li><p>利用xftp将下载的<code>.tar.gz</code>发送到CSE中，然后解压。</p>
</li>
<li><p>修改环境变量。<br><code>vim /etc/profile</code><br>在该文件末尾添加配置内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_HOME&#x3D;&#x2F;解压目录&#x2F;jdk1.8.0_161 </span><br><span class="line">export CLASSPATH&#x3D;$:CLASSPATH:$JAVA_HOME&#x2F;lib&#x2F; </span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用<code>source /etc/profile</code>重新加载配置文件</p>
</li>
<li><p>已经完成，可以利用<code>java -version</code>查看是否成功。</p>
</li>
</ol>
<h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>安装docker的教程很多，大家可以自行参考。这个给出<a href="http://www.runoob.com/docker/centos-docker-install.html" target="_blank" rel="noopener">菜鸟教程</a>的安装教程。</p>
<h2 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h2><h3 id="jenkins-war方法"><a href="#jenkins-war方法" class="headerlink" title="jenkins.war方法"></a>jenkins.war方法</h3><p><a href="http://mirrors.jenkins.io/war-stable/latest/jenkins.war" target="_blank" rel="noopener">直接下载jenkins.war</a>，然后传入ECS，利用命令<code>java -jar jenkins.war --httpPort=8080</code>启动命令。然后就可以通过ECS公网ip加8080端口访问并配置了。</p>
<p>不过这样存在的问题是，当你断开与ECS的连接时，服务就中断了。这是无法接受的。所以我们希望jenkins能够以服务的形式长久存在。</p>
<h3 id="服务方法"><a href="#服务方法" class="headerlink" title="服务方法"></a>服务方法</h3><p>利用yum安装jenkins，只需三行命令</p>
<ol>
<li><code>sudo wget -O /etc/yum.repos.d/jenkins.repo &lt;http://jenkins-ci.org/redhat/jenkins.repo&gt;</code></li>
<li><code>sudo rpm --import &lt;http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key&gt;</code></li>
<li><code>yum install jenkins</code></li>
</ol>
<p>安装完成后直接<code>sudo service jenkins start</code>是有问题的，需要配置一些东西。</p>
<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><h3 id="启动服务失败"><a href="#启动服务失败" class="headerlink" title="启动服务失败"></a>启动服务失败</h3><p>我直接启动后显示失败报错如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Starting jenkins (via systemctl):  Job for jenkins.service failed because the control process exited with error code. See &quot;systemctl status jenkins.service&quot; and &quot;journalctl -xe&quot; for details.</span><br><span class="line">                                                           [FAILED]</span><br></pre></td></tr></table></figure>

<p>出错是因为你的java地址和jenkins给出的默认路径不符，需要手动配置。</p>
<p>配置过程：</p>
<ol>
<li>编辑<code>/etc/init.d/jenkins</code></li>
<li>将你的java安装地址加入<code>candidates</code>中。如<code>/opt/oracle/product/java/jdk1.8.0_45/bin/java</code></li>
<li>重新启动服务<br><code>sudo service jenkins restart</code></li>
</ol>
<h3 id="启动服务成功但不能访问"><a href="#启动服务成功但不能访问" class="headerlink" title="启动服务成功但不能访问"></a>启动服务成功但不能访问</h3><p>完成这几步骤后服务成功启动，但是又出现了新的问题，就是利用ip和端口访问时出现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Jenkins Can&#39;t finish HTTP request</span><br></pre></td></tr></table></figure>

<p>利用<code>systemctl status jenkins</code>查看服务状态发现jenkins的状态出入<code>exited</code>，而不是<code>running</code>。</p>
<p>google了之后发现是jenkins的配置文件中关于用户的默认配置是’jenkins’，将用户改为’root’访问成功。</p>
<h2 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h2><p>至于Jenkins的入门配置，官方给出了教程，放出<a href="https://jenkins.io/zh/doc/pipeline/tour/hello-world/" target="_blank" rel="noopener">传送门</a>供大家参考。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Jenkins官方文档：<a href="https://www.runoob.com/docker/centos-docker-install.html" target="_blank" rel="noopener">https://www.runoob.com/docker/centos-docker-install.html</a></li>
<li>菜鸟教程：<a href="https://www.runoob.com/docker/centos-docker-install.html" target="_blank" rel="noopener">https://www.runoob.com/docker/centos-docker-install.html</a></li>
<li>java官网：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>DevOps</category>
        <category>CI&amp;CD</category>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>Jenkins</tag>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 53 Maximum SubArray</title>
    <url>/chinese/2019/02/26/leetcode-53-Maximum-SubArray/</url>
    <content><![CDATA[<h1 id="leetcode-53-Maximum-Subarray"><a href="#leetcode-53-Maximum-Subarray" class="headerlink" title="leetcode 53 Maximum Subarray"></a>leetcode 53 Maximum Subarray</h1><p><strong>最大子序列和</strong>问题是用于讲解<strong>分治策略</strong>的一个经典例题，这个例题可以帮助我们很好的理解分治策略。但对于这个问题，分治策略并不是最高效的算法。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个整数数组 <code>nums</code> ，找到<strong>其中一个</strong>具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],</p>
<p>输出: 6</p>
<p>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
</blockquote>
<a id="more"></a>

<h2 id="解体思路"><a href="#解体思路" class="headerlink" title="解体思路"></a>解体思路</h2><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>暴力法的思路很简单，就是尝试所有可能的子序列起始点，根据排列组合知识很容易知道一共有$A^2_n = n \times (n - 1)$种可能。遍历所有可能并找出最大和，时间复杂度为$\Theta(n^2)$。</p>
<h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>分治策略的思想就是递归的解决一个问题，《算法导论》中给出了分治策略的三个步骤：</p>
<ol>
<li>分解（Divide）：<br>将原问题划分为一些子问题，这些子问题和原问题一样，只不过规模更下。</li>
<li>解决（Conquer）：<br>递归地解决这些子问题，如果子问题的规模足够小，就停止递归，直接求解。</li>
<li>合并（Combine）：<br>将子问题的解合并为原问题的解。</li>
</ol>
<p><strong>最大子序列和</strong>问题的分治策略也可以对应上面三步：</p>
<ol>
<li><p>分解：<br>将整个数组划分为左右两个子数组，分别求两个子数组的最大子序列和。这样两个子问题和原问题一样，规模变为原来一半。</p>
</li>
<li><p>解决：<br>递归地分解数组，知道数组中只有一个元素时，可以直接把这个元素作为最大子序列和，返回给上一层。</p>
</li>
<li><p>合并：<br>合并过程是这个问题的<strong>关键</strong>。在分解步骤中你可能已经发现，两个子数组的最大子序列和中较大的那个并不一定就是原问题的最大子序列和。这是因为在划分数组的时候将两个子数组完全隔开了，而最大子序列可能会跨越两个子数组，所以要考虑这种情况。<br>所以原问题的最大子序列和一共有<strong>三种</strong>可能的情况：</p>
<ol>
<li>完全在左边子数组中</li>
<li>完全在右边子数组中</li>
<li>跨越左右两个子数组</li>
</ol>
<p>上面两种情况只需要递归的解决就可以，而第3种情况需要仔细考虑，想要找出跨越两个数组的最大子序列和需要遍历整个数组，所以这一过程的时间复杂度是$\Theta(n)$。那么可以得出分治策略解决该问题的运行时间：</p>
</li>
</ol>
<p>$$<br>T(n) =<br>\begin{cases}<br>\Theta(1)&amp;if\ \ n\ =\ 1 \<br>2T(\frac{n}{2}) + \Theta(n)&amp;if\ \ n\  &gt; \ 1<br>\end{cases}<br>$$</p>
<p>用<strong>主方法</strong>解此递归式得时间复杂度为$\Theta(nlog_2n)$。</p>
<h3 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h3><p>这个问题最重要的是理解分治策略，理解了分治策略后我们可以进一步优化时间复杂度。实际上我们可以在一次遍历内找出最大子序列和。</p>
<p>从头开始遍历时，每加入一个元素我们都可以比较加入和不加入两种情况下哪一个和更大，这样就会得到这一步的最大子序列和。然后用一个变量保存全局最大子序列和，就能得到我们想要的值。这其实有点类似动态规划。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="暴力法-1"><a href="#暴力法-1" class="headerlink" title="暴力法"></a>暴力法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_p</span><span class="params">(nums: List[int], s: int, e: int)</span> -&gt; int:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(s,e+<span class="number">1</span>):</span><br><span class="line">       sum += nums[i]</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        max_subarray_sum = float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i,len(nums)):</span><br><span class="line">                <span class="keyword">if</span> sum_p(nums,i,j) &gt; max_subarray_sum:</span><br><span class="line">                    max_subarray_sum = sum_p(nums,i,j)</span><br><span class="line">        <span class="keyword">return</span> max_subarray_sum</span><br></pre></td></tr></table></figure>

<p>leetcode美国版超时。国内版96ms，击败9.45%。</p>
<h3 id="分治法-1"><a href="#分治法-1" class="headerlink" title="分治法"></a>分治法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_cross_subarray</span><span class="params">(nums: List[int],s: int, m: int, e: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># 求解跨越子数组的情况</span></span><br><span class="line">    left_sum = <span class="number">0</span></span><br><span class="line">    left_max_sum = float(<span class="string">'-inf'</span>)</span><br><span class="line">    print(left_max_sum)</span><br><span class="line">    left_i = left_max_i = m</span><br><span class="line">    <span class="keyword">while</span> left_i &gt;= s:</span><br><span class="line">        left_sum += nums[left_i]</span><br><span class="line">        <span class="keyword">if</span> left_sum &gt; left_max_sum:</span><br><span class="line">            left_max_sum = left_sum</span><br><span class="line">            left_max_i = left_i</span><br><span class="line">        left_i -= <span class="number">1</span></span><br><span class="line">    right_sum = <span class="number">0</span></span><br><span class="line">    right_max_sum = float(<span class="string">'-inf'</span>)</span><br><span class="line">    right_i = right_max_i = m + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> right_i &lt;= e:</span><br><span class="line">        right_sum += nums[right_i]</span><br><span class="line">        <span class="keyword">if</span> right_sum &gt; right_max_sum:</span><br><span class="line">            right_max_sum = right_sum</span><br><span class="line">            right_max_i = right_i</span><br><span class="line">        right_i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> left_max_sum + right_max_sum</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray2</span><span class="params">(nums: List[int],s: int, e:int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> s == e:</span><br><span class="line">        <span class="keyword">return</span> nums[s]</span><br><span class="line">    m = (s + e) // <span class="number">2</span></span><br><span class="line">    maxnum1 = maxSubArray2(nums,s,m)</span><br><span class="line">    maxnum2 = maxSubArray2(nums,m+<span class="number">1</span>,e)</span><br><span class="line">    maxnum3 = max_cross_subarray(nums,s,m,e)</span><br><span class="line">    <span class="keyword">return</span> max(maxnum1,maxnum2,maxnum3)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> maxSubArray2(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>leetcode用时：124ms，击败5.41%。</p>
<h3 id="一次遍历-1"><a href="#一次遍历-1" class="headerlink" title="一次遍历"></a>一次遍历</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        local_max = nums[<span class="number">0</span>]</span><br><span class="line">        global_max = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            local_max = max(local_max + nums[i],nums[i])</span><br><span class="line">            <span class="keyword">if</span> local_max &gt; global_max:</span><br><span class="line">                global_max = local_max</span><br><span class="line">        <span class="keyword">return</span> global_max</span><br></pre></td></tr></table></figure>

<p>leetcode用时：48ms，击败66.85%。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Leetcode国际版：<a href="https://leetcode.com/" target="_blank" rel="noopener">https://leetcode.com/</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>领扣</tag>
        <tag>easy</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Hexo和Github Pages实现永不丢失的免费博客</title>
    <url>/chinese/2019/02/22/%E5%88%A9%E7%94%A8Hexo%E5%92%8CGithub-Pages%E5%AE%9E%E7%8E%B0%E6%B0%B8%E4%B8%8D%E4%B8%A2%E5%A4%B1%E7%9A%84%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="利用Hexo-Github-Pages实现永不丢失的免费博客"><a href="#利用Hexo-Github-Pages实现永不丢失的免费博客" class="headerlink" title="利用Hexo + Github Pages实现永不丢失的免费博客"></a>利用Hexo + Github Pages实现永不丢失的免费博客</h1><h2 id="组件安装"><a href="#组件安装" class="headerlink" title="组件安装"></a>组件安装</h2><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo官方网站</a>给出的介绍：</p>
<blockquote>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
</blockquote>
<p>Hexo是基于Node.js的，所以安装并使用Hexo之前，必须先安装<strong>Node.js</strong>。</p>
<p><a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages官方</a>给出的介绍：</p>
<blockquote>
<p>GitHub Pages is a static site hosting service designed to host your personal, organization, or project pages directly from a GitHub repository.</p>
<p>GitHub Pages是一种<strong>静态网站托管服务</strong>，用来托管GitHub仓库中的个人、组织或者项目的网页。</p>
</blockquote>
<p>为了将博客部署/备份到github上，我们不仅需要有github账户，还需要下载<strong>Git</strong>。综上我们需要安装的组件有：</p>
<ol>
<li><strong>Node.js</strong></li>
<li><strong>Git</strong></li>
<li><strong>Hexo</strong></li>
</ol>
<p>安装方法在网上很容易找到，就不再细说了。</p>
<a id="more"></a>

<h2 id="本地搭建Hexo博客"><a href="#本地搭建Hexo博客" class="headerlink" title="本地搭建Hexo博客"></a>本地搭建Hexo博客</h2><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a>中包括几种中主要的命令：</p>
<ol>
<li><code>hexo init [folder]</code><br>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</li>
<li><code>hexo new [layout] &lt;title&gt;</code><br>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <code>_config.yml</code>中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</li>
<li><code>hexo generate</code>或者<code>hexo g</code><br>生成静态文件。</li>
<li><code>hexo server</code>或这<code>hexo s</code><br>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</li>
<li><code>hexo deploy</code>或者<code>hexo d</code><br>根据<code>_config.yml</code>中的<code>deploy</code>设则来部署网站。</li>
<li><code>hexo clean</code><br>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。<br>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</li>
</ol>
<p>那么想要创建一个本地Hexo博客很简单，只需要利用<code>hexo init</code>创建一个网站，然后<code>hexo g</code>命令生成静态文件，最后使用<code>hexo s</code>就可以查看生成的静态网站了。如果想要写新的博客只需使用<code>hexo new &quot;blog title&quot;</code>就可以在<code>/source/_post/</code>文件夹中生成一个<code>blog-title.md</code>文件，编辑这个文件就可以写博客了。博客编辑完成后重新执行<code>hexo g</code>就能生成对应的静态文件了。</p>
<p>Hexo有很多的主题可以选择，很多主题简介漂亮、支持功能扩展、自定义样式等。Hexo的外观设置请见本博客另一片篇博文<a href="https://freshmanhaner.github.io/2019/02/22/NexT主题基础外观设置/" target="_blank" rel="noopener">NexT主题基础外观设置</a>。但是这里我们先不介绍相关内容，只需要注意<strong>某些功能的扩展可能会影响到后面会提到的备份。</strong></p>
<h2 id="将博客部署到Github-Pages"><a href="#将博客部署到Github-Pages" class="headerlink" title="将博客部署到Github Pages"></a>将博客部署到Github Pages</h2><p>本地搭建了博客肯定是不够的，我们还得把博客发布出去，这就用到GitHub Pages了，其实就是将本地博客的静态文件上传到github中一个特殊的仓库的master分支中。</p>
<p>如果<strong>你已经有权限往github中上传内容</strong>（至于怎么连接github，网上也有很多<a href="https://www.cnblogs.com/yunquan/p/4862723.html" target="_blank" rel="noopener">教程</a>），想要部署博客到GitHub Pages只需两步：</p>
<ol>
<li><p>修改<code>_config.yml</code>中的<code>deploy</code>为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:user_name&#x2F;repository_name.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行命令<code>npm install hexo-deployer-git --save</code></p>
</li>
</ol>
<h2 id="备份实现永不丢失"><a href="#备份实现永不丢失" class="headerlink" title="备份实现永不丢失"></a>备份实现永不丢失</h2><p>用心写出的博客，绝不能让它由于某些以外丢失。本地的单一本分是不够可靠的，我们可以将源文件上传到GitHub Pages对应仓库的非master分支中。</p>
<p>如果你已经完成了GitHub Pages的部署，那么下面的内容会非常简单：</p>
<h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>在博客文件夹下执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git checkout -b backup_branch_name</span><br><span class="line">git add *</span><br><span class="line">git commit -am "first backup"</span><br><span class="line">git remote add origin git@github.com:user_name/repository_name.git</span><br><span class="line">git push origin backup_branch_name</span><br></pre></td></tr></table></figure>

<p>这样就大功告成了！</p>
<h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>只要你做了上一步的备份，你就可以在另一台电脑上恢复你的博客，当然这台电脑上要安装上面提到的组件。恢复只需3步：</p>
<ol>
<li>将GitHub Pages对应仓库克隆到本地<br><code>git clone git@github.com:user_name/repository_name.git</code></li>
<li>进入仓库对应目录，切换到备份分支<br><code>git checkout -b backup_branch_name</code></li>
<li>安装本地hexo，既执行命令<br><code>npm install hexo --save</code></li>
</ol>
<p>完成上述3步后，就可以使用hexo的各种命令来写博客、部署博客了。</p>
<p>需要注意的是某些扩展功能会导致恢复过程的出错，比如访问次数的统计功能就会使备份过程出错。后面我会详细说明什么功能对博客的恢复会有影响，又如何解决。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>hexo官网：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></li>
<li>GitHub Pages官网：<a href="https://pages.github.com/" target="_blank" rel="noopener">https://pages.github.com/</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>前端</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT主题基础外观设置</title>
    <url>/chinese/2019/02/22/NexT%E4%B8%BB%E9%A2%98%E5%9F%BA%E7%A1%80%E5%A4%96%E8%A7%82%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="NexT主题基础外观设置"><a href="#NexT主题基础外观设置" class="headerlink" title="NexT主题基础外观设置"></a>NexT主题基础外观设置</h1><h2 id="更换语言"><a href="#更换语言" class="headerlink" title="更换语言"></a>更换语言</h2><p>NexT支持多种语言：</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>代码</th>
<th>设定示例</th>
</tr>
</thead>
<tbody><tr>
<td>English</td>
<td><code>en</code></td>
<td><code>language: en</code></td>
</tr>
<tr>
<td>简体中文</td>
<td><code>zh-Hans</code></td>
<td><code>language: zh-Hans</code></td>
</tr>
<tr>
<td>Français</td>
<td><code>fr-FR</code></td>
<td><code>language: fr-FR</code></td>
</tr>
<tr>
<td>Português</td>
<td><code>pt</code></td>
<td><code>language: pt</code> or <code>language: pt-BR</code></td>
</tr>
<tr>
<td>繁體中文</td>
<td><code>zh-hk</code> 或者 <code>zh-tw</code></td>
<td><code>language: zh-hk</code></td>
</tr>
<tr>
<td>Русский язык</td>
<td><code>ru</code></td>
<td><code>language: ru</code></td>
</tr>
<tr>
<td>Deutsch</td>
<td><code>de</code></td>
<td><code>language: de</code></td>
</tr>
<tr>
<td>日本語</td>
<td><code>ja</code></td>
<td><code>language: ja</code></td>
</tr>
<tr>
<td>Indonesian</td>
<td><code>id</code></td>
<td><code>language: id</code></td>
</tr>
<tr>
<td>Korean</td>
<td><code>ko</code></td>
<td><code>language: ko</code></td>
</tr>
</tbody></table>
<p>想要切换语言只需要编辑<strong>hexo 配置文件</strong><code>_config.yml</code>(注意区分主题配置文件)中的<code>language</code>项。</p>
<a id="more"></a>
<h2 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h2><p>对菜单外观的设置包括三个部分：</p>
<ul>
<li>菜单的连接</li>
<li>菜单的名称</li>
<li>菜单的图标</li>
</ul>
<h3 id="设置菜单连接"><a href="#设置菜单连接" class="headerlink" title="设置菜单连接"></a>设置菜单连接</h3><p>NexT默认的菜单项有6个，初始只有<code>home</code>和<code>archives</code>，剩余菜单项需要在<strong>主题配置文件</strong>中手动开启。</p>
<table>
<thead>
<tr>
<th>键值</th>
<th>设定值</th>
<th>显示文本（简体中文）</th>
</tr>
</thead>
<tbody><tr>
<td>home</td>
<td><code>home: /</code></td>
<td>主页</td>
</tr>
<tr>
<td>archives</td>
<td><code>archives: /archives</code></td>
<td>归档页</td>
</tr>
<tr>
<td>categories</td>
<td><code>categories: /categories</code></td>
<td><del>分类页</del></td>
</tr>
<tr>
<td>tags</td>
<td><code>tags: /tags</code></td>
<td><del>标签页</del></td>
</tr>
<tr>
<td>about</td>
<td><code>about: /about</code></td>
<td><del>关于页面</del></td>
</tr>
<tr>
<td>commonweal</td>
<td><code>commonweal: /404.html</code></td>
<td><del>公益 404</del></td>
</tr>
</tbody></table>
<p>例如我们想增加”标签页“这个菜单，需要以下3步：</p>
<ol>
<li><p>编辑<strong>主题配置文件</strong>中的<code>menu</code>项，该项初始内容如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  #about: &#x2F;about&#x2F; || user</span><br><span class="line">  #tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  #categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat</span><br></pre></td></tr></table></figure>

<p>将<code>tags</code>前的注释去掉。</p>
</li>
<li><p>新建页面<code>tags</code>，既执行下列命令：<br><code>hexo new page &quot;tags&quot;</code></p>
</li>
<li><p>完成2后<code>blog/source/</code>中会出现<code>tags</code>目录，该目录下有<code>index.md</code>文件，文件内容如果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: 2019-02-18 16:40:41</span><br></pre></td></tr></table></figure>

<p>编辑该文件，添加：<code>type: tags</code>。</p>
</li>
</ol>
<p>完成以上3步后，重新生成静态文件，添加tags菜单项完成！</p>
<h3 id="设置菜单名称"><a href="#设置菜单名称" class="headerlink" title="设置菜单名称"></a>设置菜单名称</h3><p>设置完tags后默认的中文名称是”标签“，那么如果想要改变菜单的显示名称怎么办？</p>
<p>Hexo 在生成菜单显示名称的时候是使用键值查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 <code>next/languages/{language}.yml</code>（<code>{language}</code> 为你所使用的语言）。</p>
<p>以简体中文为例，若你需要添加一个菜单项，比如 <code>something</code>。那么就需要修改简体中文对应的翻译文件<code>languages/zh-Hans.yml</code>，在 <code>menu</code> 字段下添加一项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: 首页</span><br><span class="line">  archives: 归档</span><br><span class="line">  categories: 分类</span><br><span class="line">  tags: 标签</span><br><span class="line">  about: 关于</span><br><span class="line">  search: 搜索</span><br><span class="line">  commonweal: 公益404</span><br><span class="line">  something: 有料</span><br></pre></td></tr></table></figure>

<h3 id="设置菜单图标"><a href="#设置菜单图标" class="headerlink" title="设置菜单图标"></a>设置菜单图标</h3><p>NexT本身有默认的菜单图标，通过编辑<strong>主题配置文件</strong>中的<code>menu_icons</code>项来关闭或者开启。菜单图标的改变只能从“<a href="https://fontawesome.com/" target="_blank" rel="noopener">Font Awesome 图标</a>”中选择，如果想要改变默认的对应，只需：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  #Icon Mapping.</span><br><span class="line">  home: home #item name: icon name</span><br><span class="line">  about: user</span><br><span class="line">  categories: th</span><br><span class="line">  tags: tags</span><br><span class="line">  archives: archive</span><br><span class="line">  commonweal: heartbeat</span><br></pre></td></tr></table></figure>



<h2 id="去除底部“由-Hexo-强力驱动-主题-—-NexT-Muse“"><a href="#去除底部“由-Hexo-强力驱动-主题-—-NexT-Muse“" class="headerlink" title="去除底部“由 Hexo 强力驱动 | 主题 — NexT.Muse“"></a>去除底部“<em>由 Hexo 强力驱动 | 主题 — NexT.Muse</em>“</h2><p>博客底部样式在文件<code>next/layout/_partials/footer.swig</code>中定义，想要去除“<em>由 Hexo 强力驱动 | 主题 — NexT.Muse</em>“，只需在文件中删掉（或者注释掉）<code>{ % if theme.footer.powered %}</code>之后的所有内容。</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/Web/blog/NexT_footer.PNG" alt="NexT_footer"></p>
<h2 id="设置背景动画"><a href="#设置背景动画" class="headerlink" title="设置背景动画"></a>设置背景动画</h2><p>NexT自带5种背景动画，只需要在<strong>主题配置文件</strong>的相应位置开启即可。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他的一些外观设置可以参考Hexo配置文件和主题配置文件。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="https://www.jianshu.com/p/9f0e90cc32c2" target="_blank" rel="noopener">Hexo-NexT配置超炫网页效果</a></li>
<li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT文档</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>前端</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 56 Merge Intervals</title>
    <url>/chinese/2019/02/13/leetcode-56-Merge-Intervals/</url>
    <content><![CDATA[<h1 id="leetcode-56-区间合并——Merge-Intervals"><a href="#leetcode-56-区间合并——Merge-Intervals" class="headerlink" title="leetcode 56 区间合并——Merge Intervals"></a>leetcode 56 区间合并——Merge Intervals</h1><p>排序算法有很多应用，区间排序就是一种典型的应用。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一组区间，合并所有重叠的区间。</p>
<p>例子1：</p>
<blockquote>
<p>输入：[[1,3],[2,6],[8,10],[15,18]]</p>
<p>输出：[[1,6],[8,10],[15,18]]</p>
</blockquote>
<p>例子2：</p>
<blockquote>
<p>输入：[[1,4],[4,5]]</p>
<p>输出：[[1,5]]</p>
</blockquote>
<a id="more"></a>

<h2 id="解体思路"><a href="#解体思路" class="headerlink" title="解体思路"></a>解体思路</h2><p>按照区间的起始点对区间进行排序，那么可以合并的区间一定是相邻的。</p>
<p>算法步骤如下：</p>
<ol>
<li>将给定的一组区间<strong>按照起始点进行排序</strong>。</li>
<li>设置<em>new_start</em>和<em>new_end</em>两个变量来存储即将插入结果队列的区间起始点和终点，从左往右开始遍历排好序的区间。</li>
<li>如果当前区间和下一个区间有重叠，更新<em>new_end</em>，<strong>注意新的值一定要大于当前<em>new_end</em></strong>。</li>
<li>如果当前区间和下一个区间没有重叠，将<em>new_start</em>和<em>new_end</em>作为起始点和终点的区间插入结果。</li>
</ol>
<ul>
<li>时间复杂度<br>对序列排序的时间复杂度是$\Theta(n \times log_2{n})$，而对序列遍历的时间复杂度是$\Theta(n)$。所以整个算法的时间复杂度是$\Theta(n \times log_2{n})$。</li>
<li>空间复杂度<br>空间复杂度和排序算法有关。比如<strong>空间复杂度</strong>是$\Theta(1)$，而合并排序的时间复杂度是$\Theta(n)$。</li>
</ul>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>我一开始的实现不够简洁，逻辑虽然简单，但是代码看上去很臃肿。具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="comment"># class Interval:</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: <span class="string">'List[Interval]'</span>)</span> -&gt; 'List[Interval]':</span></span><br><span class="line">        sorted_int = sorted(intervals,key=<span class="keyword">lambda</span> x:x.start) <span class="comment">#sort intervals by start</span></span><br><span class="line">        </span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        length = len(sorted_int)</span><br><span class="line">        <span class="keyword">if</span> length &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        new_start = sorted_int[<span class="number">0</span>].start</span><br><span class="line">        new_end = sorted_int[<span class="number">0</span>].end</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; length):</span><br><span class="line">            <span class="keyword">if</span> new_end &gt;= sorted_int[i].start:</span><br><span class="line">                new_end = max(sorted_int[i].end,new_end)</span><br><span class="line">                i = i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = Interval(new_start,new_end)</span><br><span class="line">                result.append(tmp)</span><br><span class="line">                new_start = sorted_int[i].start</span><br><span class="line">                new_end = sorted_int[i].end</span><br><span class="line">                </span><br><span class="line">        tmp = Interval(new_start,new_end)//处理最后一个区间</span><br><span class="line">        result.append(tmp)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p><strong>leetcode用时：60ms，排名85.63%。</strong></p>
<p>在看过大神的代码后学到了一个<strong>技巧</strong>，就是对<strong>访问列表是对负数的应用</strong>。例如<code>list[-1]</code>表示访问列表的最后一个元素，这个技巧在这个题目中可以使得代码变得简洁。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="comment"># class Interval:</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: <span class="string">'List[Interval]'</span>)</span> -&gt; 'List[Interval]':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        sorted_int = sorted(intervals,key=<span class="keyword">lambda</span> x:x.start) <span class="comment">#sort intervals by start</span></span><br><span class="line">        </span><br><span class="line">        result = [sorted_int[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(sorted_int)):</span><br><span class="line">            <span class="keyword">if</span> result[<span class="number">-1</span>].end &gt;= sorted_int[i].start:</span><br><span class="line">                <span class="keyword">if</span>(result[<span class="number">-1</span>].end &lt; sorted_int[i].end):</span><br><span class="line">                    result[<span class="number">-1</span>].end = sorted_int[i].end</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(sorted_int[i])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p><strong>leetcode用时：56ms，排名99.24%。</strong></p>
<p>这个实现相比于第一个实现不仅变得简洁，而且<strong>省去了新建区间的过程</strong>，直接利用已有区间，这样省下了一定的时间，时间性能排名上升。</p>
<h2 id="超慢实现"><a href="#超慢实现" class="headerlink" title="超慢实现"></a>超慢实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="comment"># class Interval:</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type intervals: List[Interval]</span></span><br><span class="line"><span class="string">        :rtype: List[Interval]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> i: i.start)</span><br><span class="line">        temp = intervals[<span class="number">0</span>]</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(intervals[:]):<span class="comment">#在循环中使用len()函数，非常影响性能</span></span><br><span class="line">            next = intervals[i]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> temp.end &lt; next.start:</span><br><span class="line">                res.append(temp)</span><br><span class="line">                temp = next</span><br><span class="line">            <span class="keyword">elif</span> temp.end &gt;= next.start:</span><br><span class="line">                temp = Interval(temp.start, max(temp.end, next.end))</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        res.append(temp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><strong>leetcode用时：748ms</strong></p>
<p>这个超慢实现还是常见的<strong>低效循环</strong>错误，课件只要避免在<a href="https://freshmanhaner.github.io/2018/10/05/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/#more" target="_blank" rel="noopener">如何优化程序性能</a>提到过的常见错误，可以很大程度上提升程序的时间性能。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Leetcode国际版：<a href="https://leetcode.com/" target="_blank" rel="noopener">https://leetcode.com/</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>领扣</tag>
        <tag>中等</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 2 AddTwoNumbers</title>
    <url>/chinese/2019/02/10/leetcode-2-AddTwoNumbers/</url>
    <content><![CDATA[<h1 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定两个<strong>非空</strong>链表来表示两个非负整数。整数的数位反向存储，每个链表节点存储一个数字。将两个整数相加并以相同的格式返回结果。</p>
<p>例如：</p>
<blockquote>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p>
<p>输出：7 -&gt; 0 -&gt; 8</p>
<p>其实就是 342 + 465 = 807</p>
</blockquote>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个题目本身难度不大，不知道难度为什么是<em>中等</em>。我解题过程中主要的纠结点是对结果链表头部的处理，因为链表头部相对于其他节点比较特殊，需要单独考虑。其他没有发现什么难点，无非是对链表和指针的操作。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>对于链表头节点的问题，我选择创建一个空的头节点，这样可以统一处理头节点和其他节点，在最后返回时跳过空的头节点。</p>
<p>我的第一次实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: <span class="string">'ListNode'</span>, l2: <span class="string">'ListNode'</span>)</span> -&gt; 'ListNode':</span></span><br><span class="line">        carry = <span class="number">0</span> <span class="comment">#进位</span></span><br><span class="line">        </span><br><span class="line">        lp1 = l1</span><br><span class="line">        lp2 = l2</span><br><span class="line">        </span><br><span class="line">        lsum = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        res = ListNode(<span class="number">0</span>)</span><br><span class="line">        lpr = res</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lp1:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lp2:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(lp1 <span class="keyword">and</span> lp2):</span><br><span class="line">            lsum = lp1.val + lp2.val + carry</span><br><span class="line">            <span class="keyword">if</span>(lsum &gt;= <span class="number">10</span>):</span><br><span class="line">                lsum -= <span class="number">10</span></span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            new_digit = ListNode(lsum)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">            lpr = lpr.next</span><br><span class="line">            lp1 = lp1.next</span><br><span class="line">            lp2 = lp2.next</span><br><span class="line">        <span class="keyword">while</span>(lp1):</span><br><span class="line">            lsum = lp1.val + carry</span><br><span class="line">            <span class="keyword">if</span> lsum &gt;= <span class="number">10</span>:</span><br><span class="line">                lsum -= <span class="number">10</span></span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            new_digit = ListNode(lsum)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">            lpr = lpr.next</span><br><span class="line">            lp1 = lp1.next</span><br><span class="line">        <span class="keyword">while</span>(lp2):</span><br><span class="line">            lsum = lp2.val + carry</span><br><span class="line">            <span class="keyword">if</span> lsum &gt;= <span class="number">10</span>:</span><br><span class="line">                lsum -= <span class="number">10</span></span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            new_digit = ListNode(lsum)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">            lpr = lpr.next</span><br><span class="line">            lp2 = lp2.next</span><br><span class="line">        <span class="keyword">if</span> carry != <span class="number">0</span>:</span><br><span class="line">            new_digit = ListNode(carry)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">        res = res.next</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>leetcode运行时间128ms。</p>
<p>第一次的实现表现不佳，用时排名接近50%。主要问题在于每次循环都用if/else判断lsum是否大于等于10，这样其实浪费了不少时间。那么我们能不能无论lsum是否小于10，都统一处理呢？可以！</p>
<p>优化后代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: <span class="string">'ListNode'</span>, l2: <span class="string">'ListNode'</span>)</span> -&gt; 'ListNode':</span></span><br><span class="line">        carry = <span class="number">0</span> <span class="comment">#进位</span></span><br><span class="line">        </span><br><span class="line">        lp1 = l1</span><br><span class="line">        lp2 = l2</span><br><span class="line">        </span><br><span class="line">        lsum = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        res = ListNode(<span class="number">0</span>)</span><br><span class="line">        lpr = res</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(lp1 <span class="keyword">and</span> lp2):</span><br><span class="line">            lsum = lp1.val + lp2.val + carry</span><br><span class="line">            carry = lsum // <span class="number">10</span></span><br><span class="line">            lsum = lsum % <span class="number">10</span></span><br><span class="line">            new_digit = ListNode(lsum)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">            lpr = lpr.next</span><br><span class="line">            lp1 = lp1.next</span><br><span class="line">            lp2 = lp2.next</span><br><span class="line">        <span class="keyword">while</span>(lp1):</span><br><span class="line">            lsum = lp1.val + carry</span><br><span class="line">            carry = lsum // <span class="number">10</span></span><br><span class="line">            lsum = lsum % <span class="number">10</span></span><br><span class="line">            new_digit = ListNode(lsum)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">            lpr = lpr.next</span><br><span class="line">            lp1 = lp1.next</span><br><span class="line">        <span class="keyword">while</span>(lp2):</span><br><span class="line">            lsum = lp2.val + carry</span><br><span class="line">            carry = lsum // <span class="number">10</span></span><br><span class="line">            lsum = lsum % <span class="number">10</span></span><br><span class="line">            new_digit = ListNode(lsum)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">            lpr = lpr.next</span><br><span class="line">            lp2 = lp2.next</span><br><span class="line">        <span class="keyword">if</span> carry != <span class="number">0</span>:</span><br><span class="line">            new_digit = ListNode(carry)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">        <span class="keyword">return</span> res.next</span><br></pre></td></tr></table></figure>

<p>leetcode运行时间96ms。</p>
<p>96ms的表现已经超越99.26%的实现。</p>
<h2 id="超慢实现"><a href="#超慢实现" class="headerlink" title="超慢实现"></a>超慢实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l3val = <span class="number">0</span></span><br><span class="line">            add1 =<span class="number">0</span> </span><br><span class="line">            l3 = ListNode(<span class="number">0</span>)</span><br><span class="line">            l3last = l3</span><br><span class="line">            <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 :</span><br><span class="line">                l3val=<span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> l1 :</span><br><span class="line">                    l3val = l1.val</span><br><span class="line">                    <span class="comment">#print(l1.val)</span></span><br><span class="line">                    l1 = l1.next</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">if</span> l2 :</span><br><span class="line">                    l3val += l2.val</span><br><span class="line">                    <span class="comment">#print(l2.val)</span></span><br><span class="line">                    l2 = l2.next</span><br><span class="line">                l3val += add1</span><br><span class="line">                add1 = l3val//<span class="number">10</span></span><br><span class="line">                l3last.next = ListNode(l3val%<span class="number">10</span>)</span><br><span class="line">                l3last = l3last.next</span><br><span class="line">                print(add1)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> add1==<span class="number">1</span>:</span><br><span class="line">                l3last.next = ListNode(<span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> l3.next</span><br></pre></td></tr></table></figure>

<p>leetcode用时312ms。</p>
<p>这个超慢实现，我不太确定慢的原因。我觉得可能的原因有：</p>
<ol>
<li>循环中的两个分支多数情况下都要经过，这限制了处理器的预执行优化，影响性能。</li>
<li>实现中有<code>print()</code></li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Leetcode国际版：<a href="https://leetcode.com/" target="_blank" rel="noopener">https://leetcode.com/</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>中等</tag>
        <tag>力扣</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 162 Find Peak Element</title>
    <url>/chinese/2019/01/23/leetcode-162-Find-Peak-Element/</url>
    <content><![CDATA[<h1 id="leetcode-162-Find-Peak-Element"><a href="#leetcode-162-Find-Peak-Element" class="headerlink" title="leetcode 162 Find Peak Element"></a>leetcode 162 Find Peak Element</h1><p>这个题目是MIT 6.006算法课中提到的第一个问题，也就是一维数组的Peak Finder问题。如果感兴趣看一看一下我的<a href="https://freshmanhaner.github.io/2019/01/20/MIT-6-006-Lecture-1-b-%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">MIT 6.006 Lecture 1-b 笔记</a>。</p>
<p>在对比不同解题思路的同时，我还对比了不同语言（c、C++、Python）。能够非常明显的看出在<strong>效率方面</strong>：c &gt; C++ &gt; Python；时间复杂度最高的<strong>简单算法用c语言写</strong>的效率也要大于C++写的低时间复杂度的算法，更不用说Python。当然如果看简洁程度，Python还是更优。详细情况请看具体实现。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote>
<p>A peak element is an element that is greater than its neighbors.</p>
<p>峰值元素是指比相邻元素大的元素</p>
<p>Given an input array <code>nums</code>, where nums[i] $\neq$ nums[i+1], find a peak element and return its index.</p>
<p>给定输入数组<code>nums</code>，规定nums[i]$\neq$nums[i+1]。从该数组中找到一个峰值元素并返回它的索引值。</p>
<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>
<p>给定的数组中可能含有多个峰值，只需找到其中任意一个即可。</p>
<p>You may imagine that nums[-1] = nums[n] = $-\infty$.</p>
<p>你可以假设nums[-1] = nums[n] = $-\infty$。</p>
</blockquote>
<a id="more"></a>

<h2 id="解体思路"><a href="#解体思路" class="headerlink" title="解体思路"></a>解体思路</h2><p>题目中很多的假设可以用来提升我们算法的效率，比如nums[i]$\neq$nums[i+1]、nums[-1] = nums[n] = $-\infty$。</p>
<h3 id="线性扫描"><a href="#线性扫描" class="headerlink" title="线性扫描"></a>线性扫描</h3><p>从左往右扫描整个数组，找出第一个出现的峰值元素。第一反应是看每个元素的左右两边来判断是否为峰值，其实只需要可能右边邻居，因为左边已经比较过了，一定是小于该元素的。</p>
<ul>
<li><p>时间复杂度<br>最坏情况下（元素自左向右递增）我们要扫描整个数组。所以时间复杂度为$O(n)$。</p>
</li>
<li><p>空间复杂度</p>
<p>只用到了常数额外空间，所以空间复杂度是$O(1)$。</p>
</li>
</ul>
<h3 id="递归二分搜索"><a href="#递归二分搜索" class="headerlink" title="递归二分搜索"></a>递归二分搜索</h3><p>递归二分搜索算法和下面的迭代二分搜索都属于<strong>分治策略</strong>_devide&amp;conquer_的一种。根据题目我们可以看出，考虑中间元素<code>mid</code>，如果<code>nums[mid] &lt; nums[mid+1]</code>，那么<code>mid</code>元素的右边一定存在峰值元素。因为我们只需找出峰值元素中的任意一个，我们就不再需要考虑<code>mid</code>元素的左边一半了，这样问题的规模也就缩小了一半。</p>
<ul>
<li>时间复杂度<br>$T(n) = T(\frac{n}{2}) + \Theta(1) = T(\frac{n}{4}) + 2\Theta(1) = … = log_2(n) \times \Theta(1)=O(log_2(n))$</li>
<li>空间复杂度<br>递归二分搜索中，每次递归表用都会占用上次一半的额外空间，所以总的额外空间是$log_2(n)$。也就是说空间复杂度也是$O(log_2(n))$。</li>
</ul>
<h3 id="迭代二分搜索"><a href="#迭代二分搜索" class="headerlink" title="迭代二分搜索"></a>迭代二分搜索</h3><p>迭代二分搜索和递归二分搜索整体思路一样，<strong>时间复杂度也是相同的</strong>（迭代在常数项上一般优于递归）。差别在于迭代二分搜索不会占用太多的额外空间，所以空间复杂度是$O(1)$。</p>
<p>所以能用迭代的地方尽量不用递归。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="线性扫描算法——c语言实现"><a href="#线性扫描算法——c语言实现" class="headerlink" title="线性扫描算法——c语言实现"></a>线性扫描算法——c语言实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; nums[i + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然是$\Theta(n)$的时间复杂度，但是用c语言编写的话用时为<strong>0ms</strong>。</p>
<h3 id="递归二分搜索——C-实现"><a href="#递归二分搜索——C-实现" class="headerlink" title="递归二分搜索——C++实现"></a>递归二分搜索——C++实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == e)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> mid = (s + e) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[mid + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> search(nums,mid+<span class="number">1</span>,e);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> search(nums,s,mid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">return</span> search(nums,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>用时<strong>4ms</strong></p>
<h3 id="迭代二分搜索——Python3实现"><a href="#迭代二分搜索——Python3实现" class="headerlink" title="迭代二分搜索——Python3实现"></a>迭代二分搜索——Python3实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start = <span class="number">0</span> </span><br><span class="line">        end = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">            <span class="keyword">if</span> start == end:</span><br><span class="line">                <span class="keyword">return</span> start</span><br><span class="line">            mid = (start + end)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid+ <span class="number">1</span>]):</span><br><span class="line">                start = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br></pre></td></tr></table></figure>

<p>单纯按照时间复杂度来比较，迭代二分搜索应该是最快的，但是用Python实现用时却是同样时间复杂度C++实现的8倍，用时<strong>32ms</strong>。</p>
<h2 id="超慢实现"><a href="#超慢实现" class="headerlink" title="超慢实现"></a>超慢实现</h2><p>通过分析超慢实现，我们可以避免影响算法效率的低级错误。</p>
<h3 id="c语言超慢实现"><a href="#c语言超慢实现" class="headerlink" title="c语言超慢实现"></a>c语言超慢实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = numsSize  <span class="number">-1</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt;  nums[m+<span class="number">1</span>]) &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细看这段代码，其实并没有什么低价错误，只不过是在计算中间值m的时候算式稍微复杂些。和最优实现0ms差别也不大，用时4ms。</p>
<h3 id="C-超慢实现"><a href="#C-超慢实现" class="headerlink" title="C++超慢实现"></a>C++超慢实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">2</span>)            </span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//----------------------------------------------</span></span><br><span class="line">        <span class="keyword">int</span> peak = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;            </span><br><span class="line">            <span class="keyword">if</span> (i<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; i+<span class="number">1</span> &lt; nums.size() )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>] &amp;&amp; nums[i] &gt; nums[i+<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i+<span class="number">1</span> == nums.size() &amp;&amp; nums[i] &gt; nums[i<span class="number">-1</span>])                </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> peak;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>和上段代码不同，这段代码就明显犯了<strong>低级错误：在循环代码中加入了低效率因素。</strong>在<code>for</code>循环语句中使用<code>nums.size()</code>，使得每次循环都会调用<code>size()</code>函数，严重影响算法性能，用时8ms。</p>
<p>至于如何优化算法性能，请见<a href="https://freshmanhaner.github.io/2018/10/05/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/#more" target="_blank" rel="noopener">如何优化程序性能</a></p>
<h3 id="Python3超慢实现"><a href="#Python3超慢实现" class="headerlink" title="Python3超慢实现"></a>Python3超慢实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> nums[<span class="number">0</span>] &gt;= nums[<span class="number">1</span>] <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            </span><br><span class="line">            mid = low + (high - low) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">and</span> nums[<span class="number">0</span>] &gt;= nums[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> mid == len(nums)<span class="number">-1</span> <span class="keyword">and</span> nums[<span class="number">-1</span>] &gt;= nums[<span class="number">-2</span>]:</span><br><span class="line">                <span class="keyword">return</span> len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid<span class="number">-1</span>] &lt;= nums[mid] <span class="keyword">and</span> nums[mid] &gt;= nums[mid+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> nums[mid+<span class="number">1</span>] &gt; nums[mid]:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure>

<p>循环中加入了太多的分支，一定程度上拖慢了程序的性能，用时76ms。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Leetcode国际版：<a href="https://leetcode.com/" target="_blank" rel="noopener">https://leetcode.com/</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>领扣</tag>
        <tag>easy</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>使用virtualenv和virtualenvwrapper建立多个独立python环境</title>
    <url>/chinese/2019/01/22/%E4%BD%BF%E7%94%A8virtualenv%E5%92%8Cvirtualenvwrapper%E5%BB%BA%E7%AB%8B%E5%A4%9A%E4%B8%AA%E7%8B%AC%E7%AB%8Bpython%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>Python丰富的库是它的优势之一，但是对于我这样的强迫症来说却多少有些不太友好。安装的库越来越多，加上各种库之间的依赖关系。即使能够方便地查看，也会觉得混乱。更不要说还有安装失败的时候，强迫症心里表示很不舒服。<br>如果你在使用Python，也像我一样是个强迫症，那么救星来了。</p>
<p><img src="https://www.python.org/static/img/python-logo.png" alt="Python"></p>
<a id="more"></a>  

<h1 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h1><p><a href="https://pypi.org/project/virtualenv/" target="_blank" rel="noopener">virtualenv</a>是建立独立Python环境的工具，独立的Python环境在实际中是非常必要的。比如你的某个软件依赖某个库的版本1，另一个软件依赖这个库的版本2，如果你把这个库装在同一个python环境中，你很可能把某些你不想升级的库升级了，从而导致一些软件的失效。<br>搞清楚了有什么用，下面我们来安装吧，这里以Windows环境为例。有了神器pip的帮助，virtualenv的安装很简单，进入cmd，然后只需<code>pip install virtualenv</code>这条命令就能安装成功。如果遇到问题，详细解决请参见<a href="https://virtualenv.pypa.io/en/latest/" target="_blank" rel="noopener">官方文件</a>。<br>安装简单，使用起来还很简答。进入你需要防止独立Python环境的目录下，执行<code>virtualenv your_env_name</code>Python虚拟环境就能创建成功。如果现在就想使用这个环境，只需要<code>cd your_env_name/Scripts</code>，找到<em>Scripts</em>目录下的<em>avtivate.bat</em>这个脚本文件，执行就能进入虚拟环境。你可以像在真实环境下一样通过<code>pip list</code>查看已经看装的库，或者安装/卸载你需要的库，我就不再多说了。当你想要退出的时候，也只需要运行<em>deactivate.bat</em>文件就可以了。<br>这些虚拟环境可以任意放置，而每次使用都要进入虚拟环境目录下来运行脚本文件。管理起来，使用起来未免还是有些麻烦，对晚期强迫症来说还是不够，如果有工具能够帮助我们管理虚拟环境，在任意位置都能使用就好了。  </p>
<h1 id="virtualenvwrapper"><a href="#virtualenvwrapper" class="headerlink" title="virtualenvwrapper"></a>virtualenvwrapper</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://pypi.org/project/virtualenvwrapper/" target="_blank" rel="noopener">virtualenvwrapper</a>就是你需要的管理软件，看名字就可以看出，它主要是对virtualenv的一些功能做了封装，方便我们使用。官方列出的功能如下：</p>
<blockquote>
<ol>
<li>Organizes all of your virtual environments in one place.</li>
<li>Wrappers for creating, copying and deleting environments, including user-configurable hooks.</li>
<li>Use a single command to switch between environments.</li>
<li>Tab completion for commands that take a virtual environment as argument.</li>
<li>User-configurable hooks for all operations.</li>
<li>Plugin system for more creating sharable extensions.</li>
</ol>
</blockquote>
<p>我就不翻译了，反正你知道它很有用就是了。下面介绍安装和简单的使用，还是以Windows环境为例。安装还是依靠咱们的<em>pip</em>神器，<code>pip install virtualenvwrapper-win</code>（linux下是<code>pip install virtualenvwrapper</code>就可以了）。安装成功后的简单使用如下：</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="新建virtualenv"><a href="#新建virtualenv" class="headerlink" title="新建virtualenv"></a>新建virtualenv</h3><p><code>mkvirtualenv your_env_name</code>，所有的Python环境会被集中放置在同一目录下，命令返回的内容会告诉你在哪里。</p>
<h3 id="删除虚拟环境"><a href="#删除虚拟环境" class="headerlink" title="删除虚拟环境"></a>删除虚拟环境</h3><p><code>rmvirtualenv your_env_name</code>，用于删除某个指定的虚拟环境。</p>
<h3 id="查看所有Python环境"><a href="#查看所有Python环境" class="headerlink" title="查看所有Python环境"></a>查看所有Python环境</h3><p><code>workon</code></p>
<h3 id="进入某个Python环境"><a href="#进入某个Python环境" class="headerlink" title="进入某个Python环境"></a>进入某个Python环境</h3><p><code>workon the_env_you_want_enter</code></p>
<h3 id="退出当前Python环境"><a href="#退出当前Python环境" class="headerlink" title="退出当前Python环境"></a>退出当前Python环境</h3><p><code>deactivate</code><br>virtualenvwrapper的功能当然不知于此，更多功能等你探索。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="https://virtualenv.pypa.io/en/latest/" target="_blank" rel="noopener">https://virtualenv.pypa.io/en/latest/</a></li>
<li><a href="https://virtualenvwrapper.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://virtualenvwrapper.readthedocs.io/en/latest/</a></li>
</ol>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>virtualenv</tag>
        <tag>virtualenvwrapper</tag>
        <tag>虚拟python环境</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 7 ReverseInteger</title>
    <url>/chinese/2018/11/19/leetcode-7-ReverseInteger/</url>
    <content><![CDATA[<h1 id="Reverse-Integer"><a href="#Reverse-Integer" class="headerlink" title="Reverse Integer"></a>Reverse Integer</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Given a 32-bit signed integer, reverse digits of an integer.</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: 123</span><br><span class="line">Output: 321  </span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: -123</span><br><span class="line">Output: -321  </span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong><br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range:$[-2^{31},2^{31}-1]$ . For the purpose of this problem, assume that your function <em>returns 0 when the reversed integer overflows</em>.</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个题目比较简单，也没有太多发挥的空间，主要的性能差异产生于实现的细节上。<br>大部分人的思路思路都是利用求余的方法从右往左取出x中的数字，然后在将他们组成结果。当然要记得处理超出范围的情况。<br>那么同样的思路在实现时可以产生许多的差异。比如：</p>
<ul>
<li>如何处理x的正负情况<ul>
<li><code>if/else</code>分别处理两种情况</li>
<li>利用编程语言的特性同时处理两种情况</li>
</ul>
</li>
<li>如何存储提取出的数字<ul>
<li>存储在<strong>队列</strong>中</li>
<li>边提取边处理，不做存储</li>
</ul>
</li>
<li>如何判断超出范围的情况<ul>
<li>在溢出前做处理</li>
<li>用范围更大的数据类型存储结果，最后再判断是否超出范围</li>
</ul>
</li>
</ul>
<p>这些细节对结果不会产生太大的影响，但是当大家的性能非常接近时，每1ms的提升都可以超越许多人。  </p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>我选择了大多数人能实现的，较快的实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//leetcode表现：用时12ms</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(INT_MAX / <span class="number">10</span> &lt; result || INT_MIN/<span class="number">10</span> &gt; result)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            result = result*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="超慢实现"><a href="#超慢实现" class="headerlink" title="超慢实现"></a>超慢实现</h2><p>虽然这一题大家的实现在效率差不许多，我们还是来试着分析一下最慢的实现是怎么造成的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//leetcode表现：用时32ms</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">            res = res*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( (res&gt;=INT_MIN) &amp;&amp; (res&lt;=INT_MAX)) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个较慢实现看上去和较好的实现差别不大，唯二的差别是：</p>
<ul>
<li>较慢实现采用计算完成后再判断是否溢出</li>
<li>结果的数据类型一个是int一个是long long</li>
</ul>
<p>上述两点差别在这个题目中并不会造成多大影响。如果非要区别的话，第一个区别在溢出的情况下会多花时间；第二个区别则会造成一点空间上的浪费。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Leetcode国际版：<a href="https://leetcode.com/" target="_blank" rel="noopener">https://leetcode.com/</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>领扣</tag>
        <tag>easy</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_1_TwoSum</title>
    <url>/chinese/2018/11/15/leetcode-1-TwoSum/</url>
    <content><![CDATA[<h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.<br>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the same element twice.  </p>
<a id="more"></a>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="Brute-Force——暴力法"><a href="#Brute-Force——暴力法" class="headerlink" title="Brute Force——暴力法"></a>Brute Force——暴力法</h3><p>直接采用两层循环扫描所有元素，找到和为target的两个数，然后返回。<br><strong>时间复杂度：$O(N^2)$，空间复杂度：$O(1)$</strong>  </p>
<h3 id="Two-pass-Hash-Table——两遍哈希表法"><a href="#Two-pass-Hash-Table——两遍哈希表法" class="headerlink" title="Two-pass Hash Table——两遍哈希表法"></a>Two-pass Hash Table——两遍哈希表法</h3><p>算法在很多时候就是在时间复杂度与空间复杂度的权衡（trade-off）。暴力法空间复杂度很小，时间复杂度却比较大，显然不适用于对时间要求较高的应用。两遍哈希表法就是牺牲一点空间来换取一些时间。之所以叫两遍哈希表法（Hash Table），是因为要循环（iteration）两遍。第一遍建立哈希表存储每个元素的值和索引（Index）。第二遍循环利用建好的哈希表快速查找（Look Up）每个元素是否存在互补元素（即与之相加和为target的元素），就能在$O(N)$的时间复杂度下找到答案。<br><strong>时间复杂度：$O(N)$，空间复杂度$O(N)$</strong><br>&emsp;注意：哈希表的查找速度接近$O(1)$的时间复杂度，但具有不确定性。如果哈希表构建的不够好，碰撞（Collision）很多的话，查找速度也可能退化(Degenerate)为$O(N)$，但是一般而言，哈希表的摊分时间复杂度（Amortized Time Complexity）可以达到$O(1)$。  </p>
<h3 id="One-pass-Hash-Table——一遍哈希表法。"><a href="#One-pass-Hash-Table——一遍哈希表法。" class="headerlink" title="One-pass Hash Table——一遍哈希表法。"></a>One-pass Hash Table——一遍哈希表法。</h3><p>其实我们深入研究一下两遍哈希表法会发现，其实可以一次遍历做完<strong>插入</strong>和<strong>查找</strong>两件事。插入之前先看一下现在的哈希表中有没有待插入值的互补值，如果有，后面就不用继续执行了。既减少了遍历的次数，也减少了遍历的长度。当然，这两点只能影响到系数，并不会真正提升时间复杂度。<br><strong>时间复杂度：$O(N)$，空间复杂度：$O(N)$</strong></p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Brute Force</span></span><br><span class="line"><span class="comment">//leetcode表现：用时76ms</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">         <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = i + <span class="number">1</span>;j &lt; length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    result.push_back(i);</span><br><span class="line">                    result.push_back(j);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="两遍哈希表法"><a href="#两遍哈希表法" class="headerlink" title="两遍哈希表法"></a>两遍哈希表法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Two-pass Hash Table</span></span><br><span class="line"><span class="comment">//Leetcode表现：用时4ms</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">         <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash_table;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">            hash_table.insert(&#123;nums[i],i&#125;);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            it = hash_table.find(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it != hash_table.end() &amp;&amp; (*it).second != i)</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(i);</span><br><span class="line">                result.push_back((*it).second);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="一遍哈希表法"><a href="#一遍哈希表法" class="headerlink" title="一遍哈希表法"></a>一遍哈希表法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;One-pass</span><br><span class="line">&#x2F;&#x2F;leetcode表现：用时4ms</span><br><span class="line">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">         vector&lt;int&gt; result;</span><br><span class="line">        unordered_map&lt;int,int&gt; hash_table;</span><br><span class="line">        int len &#x3D; nums.size();</span><br><span class="line">        unordered_map&lt;int,int&gt;::iterator it;</span><br><span class="line">        int i;</span><br><span class="line">        for(i &#x3D; 0;i &lt; len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            it &#x3D; hash_table.find(target - nums[i]);</span><br><span class="line">            if(it !&#x3D; hash_table.end())</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(i);</span><br><span class="line">                result.push_back((*it).second);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                hash_table.insert(&#123;nums[i],i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="超慢实现"><a href="#超慢实现" class="headerlink" title="超慢实现"></a>超慢实现</h2><ol>
<li>其一：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//leetcode表现：用时288ms</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; answer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j &amp;&amp; (nums[i] + nums[j]) == target) &#123;</span><br><span class="line">                    answer.push_back(i);</span><br><span class="line">                    answer.push_back(j);</span><br><span class="line">                    <span class="keyword">return</span> answer;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
同样是暴力法解决问题，却花费了上一种暴力法接近<strong>四倍</strong>的时间。其中原由我在啊<a href="https://freshmanhaner.github.io/2018/10/05/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/#more" target="_blank" rel="noopener">如何优化程序性能</a>一文中已经提过，这里简单说一下原因。主要原因是在<strong>循环中出现了低效代码*</strong>nums.size()*，每次循环（而且还是两层循环）都要调用这个函数，造成了时间上的浪费。这种浪费是非常可怕的，尤其是对于大型程序来说，这样一个简单算法就有数倍的差别，可想而知对于大量数据或者大型程序将有多么大的差别。如果提前把他赋予一个常量，就可以避免这种浪费。<br>你以为这已经差到不能更差了？你错了！</li>
<li>其二：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//leetcode表现：用时292ms</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i!=j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]+nums[j]==target)</span><br><span class="line">                    &#123;</span><br><span class="line">                        d.emplace_back(i);</span><br><span class="line">                        d.emplace_back(j);</span><br><span class="line">                        <span class="keyword">return</span> d;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
你能找出这个解决方案比“最差”更差的原因吗？要知道<em>emplace_back()</em>是比<em>push_back()</em>要高效的。<br>上一种解决方案能别这一种快4ms，在于上一种解决方案少了一些判断。对于<em>if（断言1 &amp;&amp; 断言2）</em>这种形式，如果断言1不满足，后面的断言二就不会被判断了。上一种解决方案的一些情况中断言2不会被判断，一定程度上节省了时间，二这个解决方案无论什么情况下都会完成两个断言的判断。</li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Leetcode国际版：<a href="https://leetcode.com/" target="_blank" rel="noopener">https://leetcode.com/</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>领扣</tag>
        <tag>easy</tag>
        <tag>简单</tag>
      </tags>
  </entry>
</search>
