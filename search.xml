<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MIT 6.006 Lecture 1-a 笔记</title>
    <url>/chinese/2019/01/19/MIT-6-006-Lecture-1-a-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="MIT-6-006-Lecture-1-a-笔记"><a href="#MIT-6-006-Lecture-1-a-笔记" class="headerlink" title="MIT 6.006 Lecture 1-a 笔记"></a>MIT 6.006 Lecture 1-a 笔记</h1><p>这是6.006课程的概述部分，主要是对课程的介绍。第一模块的问题讲解从Lecture 1-b开始。</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/algorithm/MIT-6-006/MIT6_006_1_a.png" alt="MIT 6.006 Lecture 1-a"></p>
<a id="more"></a>

<h2 id="课程概述"><a href="#课程概述" class="headerlink" title="课程概述"></a>课程概述</h2><p>一句话概括这门课程：</p>
<ul>
<li><strong>Efficient procedures for solving problems on large inputs.</strong></li>
</ul>
<blockquote>
<p><em>The world is moving faster, things get bigger, where have the capability of computing on large inputs. But that doesn’t mean that efficiency isn’t of primary concern.</em></p>
<p>(<em>世界迅速发展，计算机处理大型输入的能力也在变强，但是这不意味着“高效”就变得不重要了。</em>)</p>
</blockquote>
<ul>
<li><strong>Scalability</strong></li>
</ul>
<p>世界会继续发展，输入会继续变大，“large”的意义会继续变迁。所以扩展能力很重要，当输入变大，依然可以“高效”的解决。</p>
<blockquote>
<p><em>We want be able to track how our procedure will gonna to do as input get larger and larger.</em><br><em>(当问题输入变得越来越大时，我们希望依然知道程序会如何执行。</em>)</p>
</blockquote>
<ul>
<li><strong>Classic data structure and elementary algorithms</strong></li>
</ul>
<blockquote>
<p><em>Classic data structures were invented many decades ago, but they stood the test of time, and they continue to be useful</em></p>
<p>经典数据结构是那些被发明了许多年，经受住了时间的考验依旧有用的数据结构。</p>
</blockquote>
<ul>
<li><strong>Real implementaions in Python</strong></li>
</ul>
<p>课程中会要求用Python来实现这些经典数据结构。所以需要有一定的Python基础。</p>
<ul>
<li><strong>Fun problem set</strong></li>
</ul>
<p>有趣不是指简单，而是有挑战性而且有价值的问题。这样你解决这些问题后会觉得学到了一些东西，并且会有成就感。</p>
<h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><p>课程分为8个模块，每个模块都跟随一些问题：</p>
<ol>
<li><strong><em>Algorithmic thinking:</em></strong> <em>Peak finding</em></li>
<li><strong><em>Sorting&amp;Trees:</em></strong> <em>Event simulation</em></li>
<li><strong><em>Hashing:</em></strong> <em>Genome comparison</em></li>
<li><strong><em>Numerics:</em></strong> <em>RSA encrythion</em></li>
<li><strong><em>Graphs:</em></strong> <em>Rubik’s cube</em></li>
<li><strong><em>Shortest paths</em></strong> </li>
<li><strong><em>Dynamic programming:</em></strong>  <em>Image compression</em></li>
<li><strong><em>Advanced topics</em></strong></li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
        <category>计算机及软件</category>
        <category>算法</category>
        <category>MIT 6.006</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>MIT</tag>
        <tag>名校课程</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.006 Lecture 1-b 笔记</title>
    <url>/chinese/2019/01/20/MIT-6-006-Lecture-1-b-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Lecture-1-b-笔记——Peak-finder"><a href="#Lecture-1-b-笔记——Peak-finder" class="headerlink" title="Lecture 1-b 笔记——Peak finder"></a>Lecture 1-b 笔记——Peak finder</h1><p>这节主要讲解”<strong>极值点问题</strong>“（Peak finder），通过不同解决思路之间的对比来理解如何设计高效算法。</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/algorithm/MIT-6-006/MIT6_006_1_b.png" alt="MIT 6.006 Lecture 1-b"></p>
<a id="more"></a>

<blockquote>
<p><em>We pick this problem, peak finder, because it’s so easy to understand, and there are fairly straightforward algorithms that are not particularly efficient to solve this problem. And so this is kind of toy problem but like a lot of toy problems, it’s very evocative, and that it points out the issue that involve in designing efficient algorithm.</em></p>
<p>(<em>选择“极值点问题”，是因为它很容易理解，而且有很多虽不高效但简单的方法解决它。它就像一个练习问题，像其他练习问题一样具有启发性，会指出设计高效算法需要注意的点。</em>)</p>
</blockquote>
<h2 id="One-dimensional-version"><a href="#One-dimensional-version" class="headerlink" title="One-dimensional version"></a>One-dimensional version</h2><p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/algorithm/MIT-6-006/MIT_6_006_1_b_2.png" alt="MIT 6.006 Lecture 1-b-2"></p>
<blockquote>
<p>Position 2 is a peak if and only if b $\geq$ a and b $\geq$ c</p>
<p>Position 11 is a peak if k $\geq​$ j</p>
<p>(<em>位置2是极值点当且仅当</em> b $\geq$ a $\bigwedge$ b $\geq​$ c</p>
<p>位置11是极值点，只需k $\geq​$ j)</p>
</blockquote>
<p><strong>Problem:</strong> Find <strong>a</strong> peak if it exists.（极值点是否存在（值得思考的问题）？如果存在，找到其中一个。）</p>
<h3 id="Straightforward-Algorithm"><a href="#Straightforward-Algorithm" class="headerlink" title="Straightforward Algorithm:"></a>Straightforward Algorithm:</h3><p>从左向右遍历</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/algorithm/MIT-6-006/MIT_6_006_1_b_3.png" alt="MIT 6.006 Lecture 1-b-3"></p>
<ol>
<li>如果位置$\frac{n}{2}​$左边的数从左向右增大，而右边从左向右减小，那位置$\frac{n}{2}​$就是一个极值点。</li>
<li>如果整个数组从左向右一直增大，那位置$n$就是极值点。</li>
</ol>
<p>&emsp;上述第1中情况，我们遍历$\frac{n}{2}$个元素找到极值点。而第2中情况我们要遍历全部$n​$个元素才能找到极值点。</p>
<p>所以<strong>最坏情况</strong>下的时间复杂度是$\Theta(n)​$。</p>
<p><font color=red>注意符号$O(n)$、符号$\Theta(n)$和$\Omega(n)$在算法时间复杂度上的意义。</font></p>
<h3 id="Divide-amp-Conquer-algorithm"><a href="#Divide-amp-Conquer-algorithm" class="headerlink" title="Divide&amp;Conquer algorithm:"></a>Divide&amp;Conquer algorithm:</h3><p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/algorithm/MIT-6-006/MIT_6_006_1_b_4.png" alt=""></p>
<p>这次我们从$\frac{n}{2}$位置开始分别和左右两个位置比较。</p>
<blockquote>
<p>If $a[\frac{n}{2}] &lt; a[\frac{n}{2}-1]​$ then only look at left half 1 … $\frac{n}{2}-1​$ to look for <strong>a</strong> peak.</p>
<p>Else if $a[\frac{n}{2}] &lt; a[\frac{n}{2}+1]$ then only look at right half $\frac{n}{2}+1$ … $n$ to look for <strong>a</strong> peak.</p>
<p>Otherwise $\frac{n}{2}$ position is a peak.</p>
<p>(<em>如果</em>$a[\frac{n}{2}] &lt; a[\frac{n}{2}-1]$，左半边数组中一定存在极值点。</p>
<p><em>如果</em>$a[\frac{n}{2}] &lt; a[\frac{n}{2}+1]$，右半边数组中一定存在极值点。</p>
<p>如果上述两种情况都不成立，$\frac{n}{2}$就是极值点。)</p>
</blockquote>
<p>下面分析这个算法的时间复杂度：</p>
<p>$T(n) = T(\frac{n}{2}) + \Theta(1)$</p>
<p>从上面的时间复杂度分析可以得到</p>
<p>$T(n) = T(\frac{n}{2}) + \Theta(1) $</p>
<p>&emsp;&emsp;$= T(\frac{n}{4}) + \Theta(1) + \Theta(1)$</p>
<p>&emsp;&emsp;$ = \log_{2}n\times \Theta(1)$</p>
<p>&emsp;&emsp;$=\Theta(\log_{2}n)$</p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>在Python环境下分别编写上面两个算法解决极值点问题，当$n = 10,000,000$时，线性时间复杂度算法用时约13秒，而对数时间复杂度算法用时仅0.001秒。当输入足够大时，两种时间复杂度的差别还是很大的。</p>
<p>对于一维Peak Finder问题的具体解决，将看<a href="https://freshmanhaner.github.io/2019/01/23/leetcode-162-Find-Peak-Element/#more" target="_blank" rel="noopener">传送门</a>。</p>
<p>这种差别在二维的情况下更为明显：</p>
<h2 id="Two-dimensional-version"><a href="#Two-dimensional-version" class="headerlink" title="Two-dimensional version"></a>Two-dimensional version</h2><p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/algorithm/MIT-6-006/MIT_6_006_1_b_5.png" alt="MIT 6.006 Lecture 1-b-5"></p>
<blockquote>
<p>a is a 2-dimensional peak if and only if $a \geq b,a \geq c,a \geq d,a \geq e​$.</p>
<p><em>二维极值点的定义：当且仅当$a \geq b,a \geq c,a \geq d,a \geq e$时 $a$是一个二维极值点。</em></p>
</blockquote>
<p><strong>Problem:</strong> Find <strong>a</strong> peak if it exists.（极值点是否存在（值得思考的问题）？如果存在，找到其中一个。）</p>
<h3 id="Greedy-Ascent-alorithm"><a href="#Greedy-Ascent-alorithm" class="headerlink" title="Greedy Ascent alorithm:"></a>Greedy Ascent alorithm:</h3><p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/algorithm/MIT-6-006/MIT_6_006_1_b_6.png" alt="MIT 6.006 Lecture 1-b-6"></p>
<p>需要选择一个开始点，我们假设从二维数组的中间开始向右，当然你也可以选择其他的出发点。</p>
<p>我们从12开始向右，发现右边比12大，所以移动到13，然后是14，到边界转而向下……</p>
<p>（其间如果遇到比当前位置小的，就转向其他方向）</p>
<p>如图，我们一直到20的位置，发现20是一个极值点。不难发现<strong>最坏情况</strong>下的时间复杂度是$\Theta(m\times{n})$。</p>
<h3 id="Extent-1-D-devide-amp-conquer-to-2-D-Attempt-No-1"><a href="#Extent-1-D-devide-amp-conquer-to-2-D-Attempt-No-1" class="headerlink" title="Extent 1-D devide&amp;conquer to 2-D(Attempt No.1)"></a>Extent 1-D devide&amp;conquer to 2-D(Attempt No.1)</h3><blockquote>
<p>Pick middle column $j = \frac{m}{2}$</p>
<p>Find a 1-D peak at $(i,j)$</p>
<p>Use $(i,j)$ as a start point on row $i$ to find 1-D peak on row $i$</p>
<p>（挑选中间列$j$</p>
<p>从$j$列中找出一维极值点$(i,j)$</p>
<p>再在$(i,j)$所在的$i$行找出一维极值，这个就是我们要找的二维极值。）</p>
</blockquote>
<p>如果这个算法是正确的，那么它的时间复杂度是$\Theta(\log_{2}n + \log_{2}m)$。这个算法是高效的，可惜并不正确，因为在第$i$行可能并不存在一个二维极值点。</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/algorithm/MIT-6-006/MIT_6_006_1_b_7.PNG" alt="MIT 6.006 Lecture 1-b-7"></p>
<p>如上图，假设从第3列开始，算法会结束在14这个位置，因为12是第3列的一维极值点，但是第2行中却不存在一个二维极值点。</p>
<center><font color=red>Attempt Failed</font></center>

<h3 id="Extent-1-D-devide-amp-conquer-to-2-D-Attempt-No-2"><a href="#Extent-1-D-devide-amp-conquer-to-2-D-Attempt-No-2" class="headerlink" title="Extent 1-D devide&amp;conquer to 2-D(Attempt No.2)"></a>Extent 1-D devide&amp;conquer to 2-D(Attempt No.2)</h3><blockquote>
<p>Pick middle column $j = \frac{m}{2}$</p>
<p>Find global maximum on column $j$ at $(i,j)$</p>
<p>Compare $(i,j-1),(i,j),(i,j+1)​$</p>
<p>Pick left columns if $(i,j-1) &gt; (i,j)​$</p>
<p>Else if$(i,j+1) &gt; (i,j)​$  pick right columns</p>
<p>Otherwise $(i,j)$ is a 2-D peak</p>
<p>If you pick left/right columns, you will solve the new problem with half the number of columns</p>
<p>（挑选中间列$j$，找到$j$列中的全局最大值$(i,j)$。</p>
<p>比较$(i,j-1),(i,j),(i,j+1)$，如果$(i,j-1) &gt; (i,j)$则去左边列中找二维极值点，</p>
<p>如果$(i,j+1) &gt; (i,j)$则去右边列中找二维极值点，如果上述两种情况都不成立，$(i,j)$就是一个二维极值点。</p>
<p>如果是去左（或者右）列中找二维极值点，其实就是把问题的列数缩小到了一般。）</p>
</blockquote>
<p>&emsp;在上述的算法中，如果只有1列，我们只需找到这一列中的最大值，这就是二维极值了。</p>
<p>&emsp;下面我们来分析这个算法的时间复杂度：</p>
<p>$T(n,m) = T(n,\frac{m}{2}) + \Theta(n)​$</p>
<p>&emsp;&emsp;$ = \Theta(n) \times \log_{2}m​$</p>
<p>&emsp;&emsp;$ = \Theta(n\log_{2}m)$</p>
<center><font color=red>Attempt Succeed</font></center>

<p><strong>作业：</strong></p>
<p>&emsp;分析上述算法，至少证明其中一个算法的正确性，或者找出例子证明不正确性。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>计算机及软件</category>
        <category>算法</category>
        <category>MIT 6.006</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>MIT</tag>
        <tag>名校课程</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.006 Lecture3 插入排序和归并排序</title>
    <url>/chinese/2019/02/22/MIT-6-006-Lecture3-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="MIT-6-006-Lecture3-插入排序和归并排序"><a href="#MIT-6-006-Lecture3-插入排序和归并排序" class="headerlink" title="MIT 6.006 Lecture3 插入排序和归并排序"></a>MIT 6.006 Lecture3 插入排序和归并排序</h1><p>这是排序部分的第一讲，我们会<strong>先</strong>介绍一下排序问题及其应用，<strong>然后</strong>介绍<strong>插入排序</strong>和<strong>归并排序</strong>两种算法，并对比。<strong>最后</strong>用Python实现这两种算法。</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/algorithm/MIT-6-006/MIT_6_006_lecture3_1.png" alt="MIT 6.006 Lecture3"></p>
<a id="more"></a>

<h2 id="排序问题及其应用"><a href="#排序问题及其应用" class="headerlink" title="排序问题及其应用"></a>排序问题及其应用</h2><h3 id="什么是排序问题"><a href="#什么是排序问题" class="headerlink" title="什么是排序问题"></a>什么是排序问题</h3><blockquote>
<p><strong>Input:</strong><br>   array A[1…n] of numbers.<br><strong>Output:</strong><br>   permutation B[1…n] of A such that B[1] ≤ B[2] ≤ … ≤ B[n] .<br><strong>e.g.</strong><br>   A = [7, 2, 5, 5, 9.6] → B = [2, 5, 5, 7, 9.6] </p>
</blockquote>
<p>排序问题给定一个输入数组A，算法处理后输入一个有序数组B。</p>
<h3 id="排序算法的应用"><a href="#排序算法的应用" class="headerlink" title="排序算法的应用"></a>排序算法的应用</h3><p>排序算法在很多方面都有应用，比如：</p>
<ul>
<li>组织一些数据库，比如歌曲库、书单库、电话簿</li>
<li>让某些问题变得简单<br>比如找数组中值、二叉查找、找统计离群点等</li>
<li>一些不太明显的应用，比如数据压缩、电脑绘图等。</li>
</ul>
<p>可以说排序算法是计算机科学一个很重要的基础，所以掌握好排序算法是很重要也很必要的。</p>
<h2 id="两种排序算法"><a href="#两种排序算法" class="headerlink" title="两种排序算法"></a>两种排序算法</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序可以说是最简单的一种排序算法，只需要四五行的Python代码就能实现。当然简单在很多时候意味着低效。</p>
<p>伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Insertion-Sort(A[],n)</span><br><span class="line">2. 	for j &lt;-- 2 to n</span><br><span class="line">3. 		将A[j]插入到已经排好序的子数组A[1..j-1]中</span><br><span class="line">4. 		通过调换位置讲A[j]放在正确的位置</span><br></pre></td></tr></table></figure>

<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/algorithm/MIT-6-006/insertion_sort.PNG" alt="插入排序图解"></p>
<p>上述伪代码中第3行，将A[j]插入到已经排好序的子数组，这个过程中<strong>有一定的优化空间</strong>。因为子数组已经是排好序的，所以我们可以选择二分法插入。这样时间复杂度就变成了$\Theta(n)$变为$\Theta(log_2n)$。</p>
<p>即便是用二分查找法找到合适的位置，但是第4行伪代码中将A[j]插入到合适的位置依然要花费$\Theta(n)$。因为插入的过程是通过交换位置实现的。</p>
<p>所以不难看出插入排序要遍历2..n-1元素，将每个元素插入到合适位置的时间复杂度是$\Theta(n)$。所以插入排序的<strong>整体时间复杂度是$\Theta(n^2)​$。</strong></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序算法是<strong>分治策略</strong>一种典型的应用。《算法导论》中给出了分治策略的三个步骤：</p>
<ol>
<li>分解（Divide）：<br>将原问题划分为一些子问题，这些子问题和原问题一样，只不过规模更下。</li>
<li>解决（Conquer）：<br>递归地解决这些子问题，如果子问题的规模足够小，就停止递归，直接求解。</li>
<li>合并（Combine）：<br>将子问题的解合并为原问题的解。</li>
</ol>
<p>对应到归并排序算法</p>
<ol>
<li>分解：<br>将针对整个数组的排序分为对左右两个子数组的排序。</li>
<li>解决<br>递归地解决这些子问题，当子问题的规模只剩一个元素是，不用排序就是有序的了。</li>
<li>合并：<br>归并排序算法的关键和难点也是在合并这一过程。合并做到将两个有序的数组原地合并为一个有序的数组。</li>
</ol>
<p>归并排序算法伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Merge-Sort A[1..n]</span><br><span class="line">	if n &#x3D; 1</span><br><span class="line">		done</span><br><span class="line">	else</span><br><span class="line">		Merge-Sort A[1..n&#x2F;2]</span><br><span class="line">		Merge-Sort A[n&#x2F;2 + 1 .. n]</span><br><span class="line">		Merge the two sorted sub-arrays</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<p>可以列出归并排序的递归式：<br>$$<br>T(n) =<br>\begin{cases}<br>\Theta(1)\ \ 若\ n \le c\<br>2T(\frac{n}{2}) + \Theta(n)<br>\end{cases}<br>$$<br>利用<strong>master theory</strong>容易得出归并排序算法的时间复杂度是$\Theta(nlog_2n)​$</p>
<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><p>python本身已经内置了排序算法，而且时间复杂度不错。我们自己实现一遍主要是为了理解算法。</p>
<h3 id="插入排序-1"><a href="#插入排序-1" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">InsertionSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">		j = i - <span class="number">1</span></span><br><span class="line">		tmp = nums[i]</span><br><span class="line">		<span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">if</span> nums[j] &gt; tmp:</span><br><span class="line">				nums[j+<span class="number">1</span>] = nums[j]</span><br><span class="line">				j -= <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">		nums[j + <span class="number">1</span>] = tmp</span><br></pre></td></tr></table></figure>



<h3 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(nums,s,m,e)</span>:</span></span><br><span class="line">	left = nums[s:m+<span class="number">1</span>]</span><br><span class="line">	right = nums[m+<span class="number">1</span>:e+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">	i = j = <span class="number">0</span></span><br><span class="line">	k = s</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">		<span class="keyword">if</span> left[i] &lt; right[j]:</span><br><span class="line">			nums[k] = left [i]</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			nums[k] = right[j]</span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">		k += <span class="number">1</span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">while</span> i &lt; len(left):</span><br><span class="line">		nums[k] = left[i]</span><br><span class="line">		k += <span class="number">1</span></span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">while</span> j &lt; len(right):</span><br><span class="line">		nums[k] = right[j]</span><br><span class="line">		k += <span class="number">1</span></span><br><span class="line">		j += <span class="number">1</span>	</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MergeSort2</span><span class="params">(nums,s,e)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> s != e:</span><br><span class="line">		m = (s + e) // <span class="number">2</span></span><br><span class="line">		MergeSort2(nums,s,m)</span><br><span class="line">		MergeSort2(nums,m+<span class="number">1</span>,e)</span><br><span class="line">		Merge(nums,s,m,e)</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MergeSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">	MergeSort2(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
        <category>计算机及软件</category>
        <category>算法</category>
        <category>MIT 6.006</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>MIT</tag>
        <tag>名校课程</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.006 Lecture 4 堆和堆排序</title>
    <url>/chinese/2019/02/27/MIT-6-006-Lecture-4-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="MIT-6-006-Lecture4-堆和堆排序"><a href="#MIT-6-006-Lecture4-堆和堆排序" class="headerlink" title="MIT 6.006 Lecture4 堆和堆排序"></a>MIT 6.006 Lecture4 堆和堆排序</h1><p>由优先级队列来引出堆，然后用堆来实现堆排序。</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/algorithm/MIT-6-006/MIT_6_006_lecture_4_a.png" alt="MIT 6.006 Lecture4"></p>
<a id="more"></a>

<h2 id="优先级队列-Priority-Queue"><a href="#优先级队列-Priority-Queue" class="headerlink" title="优先级队列 Priority Queue"></a>优先级队列 Priority Queue</h2><p>优先级队列的维基定义：</p>
<blockquote>
<p>In computer science, a priority queue is an abstract data type which is like a regular queue or stack data structure, but where additionally each element has a “priority” associated with it. In a priority queue, an element with high priority is served before an element with low priority. </p>
<p>在计算机科学中，优先级队列是一种类似于普通队列或普通栈的抽象数据结构，但是每个元素都会有一个对应的“优先级”。在优先级队列中，优先级高的元素会被优先服务。</p>
</blockquote>
<p>MIT 6.006课程给出的定义：</p>
<blockquote>
<p>A data structure implementing a set S of elements, each associated with a key, supporting the following operations:</p>
<ul>
<li>insert(S,x): insert element x into set S</li>
<li>max(S): return element of S with largest key</li>
<li>extract_max(S): return element of S with largest key and remove it from S</li>
<li>increase_key(S,x,k): increase the value of element x’s key to new value k.(assumed to be as large as current value)</li>
</ul>
<p>优先级队列是一个数据结构，这个数据结构实现一个集合S，集合中的每个元素都对应一个关键词，而且这个数据结构支持下列操作：</p>
<ul>
<li>insert(S,x): 把元素x插入到集合S中</li>
<li>max(S): 返回集合S中有最大关键字的元素</li>
<li>extract_max(S): 返回集合S中有最大关键字的元素，并将其从集合中删除。</li>
<li>increase_key(S,x,k): 将x元素的关键词的值提升到k。</li>
</ul>
</blockquote>
<p><strong>优先级队列经常用堆来实现</strong>。</p>
<h2 id="堆-Heaps"><a href="#堆-Heaps" class="headerlink" title="堆 Heaps"></a>堆 Heaps</h2><h2 id="堆排序-Heapsort"><a href="#堆排序-Heapsort" class="headerlink" title="堆排序 Heapsort"></a>堆排序 Heapsort</h2>]]></content>
      <categories>
        <category>学习</category>
        <category>计算机及软件</category>
        <category>算法</category>
        <category>MIT 6.006</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>MIT</tag>
        <tag>名校课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福大学IOS7开发课程5</title>
    <url>/chinese/2021/04/25/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B5/</url>
    <content><![CDATA[<p>这节课主要讲解：</p>
<ol>
<li>View Controller的<strong>生命周期</strong></li>
<li><strong>NotificationCenter</strong>的相关知识</li>
<li>组件UITextView的简单使用</li>
</ol>
<p>并通过Demo展示</p>
<a id="more"></a>

<h2 id="ViewController的声明周期"><a href="#ViewController的声明周期" class="headerlink" title="ViewController的声明周期"></a>ViewController的声明周期</h2><p>ViewController 的生命周期可以看作一系列函数，ViewController是UIViewController的子类。</p>
<p>生命周期的开始是创建，创建后会涉及到：</p>
<ol>
<li>viewDidLoad()</li>
<li>viewWillLayoutSubviews()</li>
<li>viewDidLayoutSubviews()</li>
<li>viewWillAppear()</li>
<li>viewDidAppear()</li>
<li>viewWillDisappear()</li>
<li>viewDidDisappear()</li>
<li>didReceiveMemoryWaring()</li>
</ol>
<p>接下来<strong>详细介绍</strong>这几个生命周期：</p>
<h2 id="viewDidLoad"><a href="#viewDidLoad" class="headerlink" title="viewDidLoad()"></a>viewDidLoad()</h2><p>在viewDidLoad()之前会执行创建的动作，但是我们一般不会在创建中执行操作。</p>
<p>创建完成之后，outlets被设置好。</p>
<p>viewDidLoad()只会被<strong>调用一次</strong>，<strong>是用来初始化controller非常好的位置</strong>。</p>
<p>需要注意的是此时view的几何结构（geometry）还没完成，<strong>还无法确定App是运行在6寸的iPhone上还是10寸的iPad上</strong>。所以不要在viewDidLoad()中初始化和尺寸、几何结构相关的操作。</p>
<h2 id="viewWillLayoutSubviews"><a href="#viewWillLayoutSubviews" class="headerlink" title="viewWillLayoutSubviews()"></a>viewWillLayoutSubviews()</h2><p>当view的几何结构发生改变时（比如屏幕从竖着变成横着），（ios7及以上）在展示之前会调用viewWillLayoutSubviews()</p>
<h2 id="viewDidLayoutSubviews"><a href="#viewDidLayoutSubviews" class="headerlink" title="viewDidLayoutSubviews()"></a>viewDidLayoutSubviews()</h2><h2 id="viewWillAppear"><a href="#viewWillAppear" class="headerlink" title="viewWillAppear()"></a>viewWillAppear()</h2><p>view展现在屏幕之前，会调用viewWillAppear()函数。</p>
<p>当使用多MVC模型时，会有多个view，此时某个view的viewWillAppear()可能会被调用多次，所以只执行一次的初始化代码不要放在这里，而应该放在viewDidLoad()。</p>
<p>基于这个理解，有些操作需要放入viewWillAppear()执行，比如Model中的数据在view不可见时被更改了，当view再次展现的时候，需要同步Model和UI。</p>
<p>另外，和viewDidLoad()相对的，这里已经完成了view几何结构的初始化，因此可以执行和几何结构相关的一些操作了。</p>
<p>在生命周期<code>viewWillAppear</code>中，必须调用<code>[super viewWillAppear:animated]</code>，调用位置无关紧要，你可以在开始调用也可以在结束时调用。</p>
<p><code>viewWillDisappear</code>也是一样。</p>
<h2 id="viewDidAppear"><a href="#viewDidAppear" class="headerlink" title="viewDidAppear()"></a>viewDidAppear()</h2><p>view展现在屏幕上之后，调用viewDidAppear()</p>
<h2 id="viewWillDisappear"><a href="#viewWillDisappear" class="headerlink" title="viewWillDisappear()"></a>viewWillDisappear()</h2><p>view即将消失时调用viewWillDisappear()，此时最好停止使用非必要的资源，比如动画等等。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">  [<span class="keyword">super</span> viewWillDisappear:animated]; <span class="comment">// 在所有viewWill/Did中都要调用super函数</span></span><br><span class="line">  <span class="comment">// 记住滑动的位置</span></span><br><span class="line">  [<span class="keyword">self</span> rememberScrollPosition];</span><br><span class="line">  <span class="comment">// 做一些清理工作</span></span><br><span class="line">  [<span class="keyword">self</span> saveDataToPermanentStore];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="viewDidDisappear"><a href="#viewDidDisappear" class="headerlink" title="viewDidDisappear()"></a>viewDidDisappear()</h2><p>view消失以后，调用viewDidDisappear()</p>
<h2 id="didReceiveMemoryWaring"><a href="#didReceiveMemoryWaring" class="headerlink" title="didReceiveMemoryWaring()"></a>didReceiveMemoryWaring()</h2><p>内存不够了，可能是因为你的App，<strong>也可能是手机上的其他App造成的</strong>。</p>
<p>这是你应该试图清理内存。</p>
<p>为什么是我要清理内存？因为操作系统有权限kill应用，如果内存不够了，而你的App又占用了很多内存，很有可能被iOS杀死。 </p>
<h2 id="awakeFromNib"><a href="#awakeFromNib" class="headerlink" title="awakeFromNib()"></a>awakeFromNib()</h2><p>（说实话，没完全听懂，先记下来，以后用到再详细研究一下吧。）</p>
<p>这个方法会发送给storyboard中绘制出来的所有对象，包括controller</p>
<p>如果进入到Controller的init方法，就一定也会进入到<code>awakeFromNib</code>。</p>
<p>尽可能不要将代码放在<code>awakeFromNib</code>中。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setup &#123;...&#125;;  <span class="comment">// do something which can't wait until viewDidLoad</span></span><br><span class="line">- (<span class="keyword">void</span>)awakeFromNib &#123; [<span class="keyword">self</span> setup]; &#125;</span><br><span class="line"><span class="comment">// uIViewController's designated initializer is initWithNibName:bundle:(ugh!)</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithNibName:(<span class="built_in">NSString</span> *)name bundle:(<span class="built_in">NSBundle</span> *)bundle</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 如果使用awakeFromNib，为了保证正确性，也要加上这三行代码</span></span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> initWithNibName:name bundle:bundle];</span><br><span class="line">  [<span class="keyword">self</span> setup];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<div id="flowchart-0" class="flow-chart"></div>

<img src="https://developer.apple.com/library/archive/referencelibrary/GettingStarted/DevelopiOSAppsSwift/Art/WWVC_vclife_2x.png" style="zoom:30%;" />






<h2 id="组件UITextView简介"><a href="#组件UITextView简介" class="headerlink" title="组件UITextView简介"></a>组件UITextView简介</h2><p>组件<a href="https://developer.apple.com/documentation/uikit/uitextview" target="_blank" rel="noopener">UITextView</a>类似于UILable，但是可以展示多行，具有可选可编辑可滚动等特点。</p>
<h2 id="NotificationCenter相关知识"><a href="#NotificationCenter相关知识" class="headerlink" title="NotificationCenter相关知识"></a>NotificationCenter相关知识</h2><p>接下来讲一讲NSNotification</p>
<ul>
<li><p>Notifications也就是之前在MVC中称为radio station的概念。</p>
</li>
<li><p>NSNotificationcenter</p>
<p>通过<code>[NSNotificationCenter defaultCenter]</code>获取默认Notification Center。</p>
<p>如果想监听这个radio station，那么发送如下消息：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="keyword">id</span>)observer  <span class="comment">// 需要接收通知的对象</span></span><br><span class="line">           selector:(SEL)methodToInvokeIfSomethingHappens</span><br><span class="line">               name:(<span class="built_in">NSString</span> *)name  <span class="comment">// station的名称</span></span><br><span class="line">             object:(<span class="keyword">id</span>)sender;  <span class="comment">// 你感兴趣的变更，如果填写nil，标识任何人发生变更，都会通知你。指定某个sender，可以只接收指定对象发来的通知。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当有广播的时候，observer会被通知：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)methodToInvokeIfSomethingHappens:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">  notification.name;  <span class="comment">// 传递的station的名称</span></span><br><span class="line">  notification.object;  <span class="comment">// 给你发送通知的对象</span></span><br><span class="line">  notification.userInfo;  <span class="comment">// 有关发生了什么的特定信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结束后记得关闭radio station</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[center removeObserver:<span class="keyword">self</span>]; <span class="comment">//关闭所有radio station</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">[center removeObserver:<span class="keyword">self</span> name:<span class="built_in">UIContentSizeCategoryDidChangeNotification</span> object:<span class="literal">nil</span>];  <span class="comment">//关闭指定radio station</span></span><br></pre></td></tr></table></figure>

<p>如果离开堆栈时，没有关闭radio station，notification center可能会继续发送notification，并<strong>导致App崩溃</strong>！</p>
<p>因为NSNotificationCenter有一个指向你的unsafe retained指针。</p>
<p>关闭radio station最好的位置是在MVC离开屏幕的时候，实在不行，可以在dealloc中关闭，dealloc会在离开堆栈之前调用：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">  <span class="comment">// be careful in this method! can't access properties! you are almost gone from heap!</span></span><br><span class="line">  [[<span class="built_in">NSNotificationCenter</span> defaultcenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>关于NotificationCenter，一个常用的例子是字体的变化。当用户在系统设置中改变字体大小时，可以利用NotificationCenter使App中的字体也跟着变化。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSNotificationCenter</span> *center = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</span><br><span class="line">[center addObserver:<span class="keyword">self</span></span><br><span class="line">           selector:<span class="keyword">@selector</span>(preferredFontsSizeChanged:)</span><br><span class="line">               name:<span class="built_in">UIContentsizeCategoryDidChangeNotification</span></span><br><span class="line">             object:<span class="literal">nil</span>]; <span class="comment">// this station's broadcasts aren't object-specific</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)preferredFontsSizeChanged:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">  <span class="comment">// reset fonts of objects using preferred fonts</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>目的：了解attributed text（富文本）、生命周期以及Notification。</p>
<ol>
<li><p>新建App，在storageBoard中加入：</p>
<ul>
<li>TextView</li>
<li>label</li>
<li>6 buttons</li>
</ul>
<p>如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gptqmdv9uwj30i40zs41r.jpg" alt="image-20210423160322521"></p>
</li>
<li><p>为TextView和Label添加property:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextView</span> *body;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UILabel</span> *headline;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为buttons添加三个函数</p>
<ul>
<li><p>四个色块的button共用一个函数，函数的作用是：在textView中选中一些文字，点击色块button后，选中的文字变成色块对应的颜色</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)changeBodySelectionColorToMatchBackgroundOfButton:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span>.body.textStorage addAttribute:<span class="built_in">NSForegroundColorAttributeName</span> value:sender.backgroundColor range:<span class="keyword">self</span>.body.selectedRange];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>outline按钮对应的函数，作用是给选中文字添加红色描边。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)outlineBodySelection:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span>.body.textStorage addAttributes:@&#123; <span class="built_in">NSStrokeWidthAttributeName</span> : @<span class="number">-3</span>, <span class="built_in">NSStrokeColorAttributeName</span>: [<span class="built_in">UIColor</span> redColor] &#125; range:<span class="keyword">self</span>.body.selectedRange];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加描边需要添加两个属性，一个用来设置描边的宽度，一个用来设置描边的颜色。</p>
<p><code>NSStrokeWidthAttributeName</code>用来设置描边的宽度，设置为整数会让字体变成中空，设置为负数会保持字体填充。</p>
<p><code>NSStrokeColorAttributeName</code>用来设置描边的颜色。</p>
</li>
<li><p>unOutline按钮对应的按钮，作用是删除字体的描边。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)unOutlineBodySelection:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span>.body.textStorage removeAttribute:<span class="built_in">NSStrokeWidthAttributeName</span> range:<span class="keyword">self</span>.body.selectedRange];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接利用<code>removeAttribute</code>删除<code>NSStrokeWidthAttributeName</code>属性，颜色就不用管了，没有宽度颜色也就无法显示了。</p>
</li>
</ul>
</li>
<li><p>设置outline按钮的字体描边</p>
<p>这样产不多就是这节课要介绍的关于富文本的知识点了。接下来加入一些生命周期的元素。</p>
<p>现在想要让outline按钮的文字变成描边的，我们可不想在设置一个按钮来让outline按钮outline，而是想一开始它就是描边的。</p>
<p>这个时候就用到生命周期了，可以在<code>viewDidLoad()</code>函数中实现：</p>
<p>先为button添加outlet，<code>@property (weak, nonatomic) IBOutlet UIButton *outline;</code>，然后在<code>viewDidLoad()</code>函数中编写代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    <span class="built_in">NSMutableAttributedString</span> *title = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:<span class="keyword">self</span>.outline.currentTitle];</span><br><span class="line">    [title setAttributes:@ &#123;</span><br><span class="line">        <span class="built_in">NSStrokeWidthAttributeName</span> : @<span class="number">3</span>,</span><br><span class="line">        <span class="built_in">NSStrokeColorAttributeName</span> : <span class="keyword">self</span>.outline.tintColor&#125;</span><br><span class="line">                   range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, [title length])];</span><br><span class="line">    [<span class="keyword">self</span>.outline setAttributedTitle:title forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用NSNotificationCenter让App中字体跟随系统字体，用户改变系统字体时，App中字体也随之变动。</p>
<ol>
<li><p>首先实现一个将字体设置为系统对应字体的方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)usePreferredFonts &#123;</span><br><span class="line">    <span class="keyword">self</span>.body.font = [<span class="built_in">UIFont</span> preferredFontForTextStyle:<span class="built_in">UIFontTextStyleBody</span>];</span><br><span class="line">    <span class="keyword">self</span>.headline.font = [<span class="built_in">UIFont</span> preferredFontForTextStyle:<span class="built_in">UIFontTextStyleHeadline</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并将其包装一层：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)preferredFontsChanged:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    [<span class="keyword">self</span> usePreferredFonts];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在生命周期<code>viewWillAppear()</code>中添加NotificationCenter</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">               selector:<span class="keyword">@selector</span>(preferredFontsChanged:)</span><br><span class="line">                   name:<span class="built_in">UIContentSizeCategoryDidChangeNotification</span></span><br><span class="line">                 object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后记得关闭radio station</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillDisappear:animated];</span><br><span class="line">    <span class="comment">// [[NSNotificationCenter defaultCenter] removeObserver:self]; // 这种方法也可以，删除所有的notification，但不够优雅，尽量使用下面的方法，指定具体的notificationCenter</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span></span><br><span class="line">                                                    name:<span class="built_in">UIContentSizeCategoryDidChangeNotification</span></span><br><span class="line">                                                  object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后要考虑一种情况，NotificationCenter在view消失时被关闭，如果在这之后用户修改了系统的字体，那么view再次appear时，App字体会和系统不一致。因此，需要在<code>viewWillAppear</code>中，调用<code>[self usePreferredFonts]</code>来同步外部世界的字体。</p>
</li>
</ol>
</li>
</ol>
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: instantiated(实例化)
op=>operation: 调用awakeFromNib()
op2=>operation: outlets设置完成
op3=>operation: 调用viewDidLoad()
op4=>operation: 几何结构确定下来以后,\
调用viewWillLayoutSubviews()和viewDidLayoutSubviews()
op5=>operation: (对着MVC再屏幕中出现和消失，下面几个生命周期可能会被多次调用)
op6=>operation: 调用viewWillAppear()和viewDidAppear()
op7=>operation: 每当几何结构改变（比如屏幕旋转）都会调用\
viewWillLayoutSubviews()和viewDidLayoutSubviews()
op8=>operation: 如果设置了屏幕自动旋转，还会调用will/didRotatedTo/From
op9=>operation: 调用viewWillDisappear()和viewDidDisappear()
op10=>operation: 如果手机内存吃紧，调用didReceiveMemoryWarning()
e=>end
st->op->op2->op3->op4->op5->op6->op7->op8->op9->op10->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发入门</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福大学IOS7开发课程4</title>
    <url>/chinese/2021/03/29/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B4/</url>
    <content><![CDATA[<p>这节课主要讲了<strong>Objecitive-C的几个细节</strong>和<strong>Foundation</strong>库中的一些类</p>
<p>本节课主要介绍iOS开发</p>
<ul>
<li>NSObject</li>
<li>NSArray</li>
<li>NSMutableArray</li>
<li>NSNumber</li>
<li>NSValue</li>
<li>NSData</li>
<li>NSDate</li>
<li>NSSet</li>
<li>NSMutableSet</li>
<li>NSOrderedSet</li>
<li>NSMutableOrderedSet</li>
<li>NSDictionary</li>
<li>NSMutableDictionary</li>
<li>NSUserDefaults</li>
<li>NSRange</li>
<li>UIColor</li>
<li>UIFont</li>
<li>UIFontDescriptor</li>
<li>NSAttributedString</li>
<li>NSMutableAttributedString</li>
</ul>
<a id="more"></a>

<h1 id="Objecitive-C的几个细节"><a href="#Objecitive-C的几个细节" class="headerlink" title="Objecitive-C的几个细节"></a>Objecitive-C的几个细节</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><ol>
<li>利用Alloc &amp; init创建对象</li>
<li>利用类的方法创建对象</li>
<li>或者上述两者同时使用</li>
<li>让其他对象帮忙创建类的对象<figure class="highlight"><table><tr><td class="code"><pre><span class="line">- NSString's -- (NSString *)stringByAppendingString:(NSString *)otherString</span><br><span class="line">- NSArray's -- (NSString *)componentsJoinedByString:(NSString *)separator;</span><br><span class="line">- NSString's &amp; NSArray's -- (id)mutableCopy</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h2><p>向nil发送消息是可以的，但是不会执行任何代码</p>
<h2 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h2><p>Objective-C有个<strong>非常重要</strong>的类型——<strong>id</strong>，id是一种类型，意味“指向未知类型对象的<strong>指针</strong>”。</p>
<p><strong>在运行过程中，所有对象的指针都是id类型的。</strong></p>
<p>用id来指定变量类型，<strong>就是动态绑定</strong>。</p>
<p>但是在编译过程中，如果你指定对象的类型，编译器可以帮助发现bug。</p>
<p><strong>那么动态绑定安全么？</strong></p>
<p>动态绑定导致可以向对象发送未定义的信息，比如该对象类型为定义的方法，当然这会导致程序崩溃。</p>
<p>如果在代码中指定对象的类型，这种错误就可以在编译过程中被发现，防止程序在执行过程中崩溃，比如，<code>NSString *s  = @&#39;x&#39;</code>，这种情况下，如果给s发送非NSString的方法，编译器可以发现错误。</p>
<p>当然也可以使用：<code>id obj = s</code>、<code>NSArray *a = obj</code>，但是这样<strong>编译器没办法帮忙检查错误</strong>，所以存在一定危险。</p>
<p>另外，永远不要使用<code>id *</code>，因为<strong>id本身就是个指针</strong>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Vehicle</span></span></span><br><span class="line">- (<span class="keyword">void</span>)move;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Ship</span> : <span class="title">Vehicle</span></span></span><br><span class="line">- (<span class="keyword">void</span>)shoot;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Ship *s = [[Ship alloc] init];</span><br><span class="line">[s shoot];</span><br><span class="line">[s move];</span><br><span class="line"></span><br><span class="line">Vehicle *v = s; <span class="comment">// 合法</span></span><br><span class="line">[v shoot]; <span class="comment">// 编译器会给出警告，因为它以为v是Vehicle</span></span><br><span class="line">          <span class="comment">//但是运行时不会崩溃，因为v实际上是一个Ship</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> obj = ...; <span class="comment">// 任意定义obj，比如NSString；</span></span><br><span class="line">[obj shoot;] <span class="comment">// 编译器不会给出警告，因为它知道shoot函数确实存在，同时它又不知道obj的类型，因此编译器无法给出警告。</span></span><br><span class="line"><span class="comment">// 但是，实际运行中，程序会崩溃。</span></span><br><span class="line">[obj someMethodNameThatNoObjectAnywhereRespondsTo];</span><br><span class="line"><span class="comment">// 这个时候编译器会给出警告，因为它知道没有任何函数叫someMethodNameThatNoObjectAnywhereRespondsTo</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *hello = <span class="string">@"hello"</span>;</span><br><span class="line">[hello shoot]; <span class="comment">// 编译器会给出警告，因为NSString没有shoot函数</span></span><br><span class="line">Ship *helloShip = (Ship *)hello; <span class="comment">// 编译器不会给出警告 </span></span><br><span class="line">[helloShip shoot];<span class="comment">// 导致运行时崩溃</span></span><br><span class="line">[(<span class="keyword">id</span>)hello shoot]; <span class="comment">//编译器不会给出警告，但是运行时会崩溃</span></span><br></pre></td></tr></table></figure>

<p><strong>什么时候会用到危险的动态绑定（id）</strong></p>
<ol>
<li>Objective-C允许在同一个collection（比如NSArray）中有不同类型的类，想这么做时，需要用到动态绑定。 </li>
<li>当希望使用MVC中的blind/structured通信（比如delegation）时。</li>
</ol>
<p><strong>为了把动态绑定变得安全</strong>，需要使用Introspection和Protocols</p>
<ul>
<li><p>Introspection</p>
<p>在运行时询问id是什么类型或询问可以向其发送的信息。</p>
<p>继承自NSObject的所有对象都有下面三个函数：</p>
<ol>
<li><p><code>isKindOfClass:</code></p>
<p>判断对象是不是某种类，包含继承的情况</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>([obj isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *s = [(<span class="built_in">NSString</span>*)obj stringByAppendingString:<span class="string">@"xyzzy"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如在纸牌匹配游戏中<code>PlayingCard.m</code>的<code>match</code>函数的源代码为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">int</span>)match:(<span class="built_in">NSArray</span> *)otherCards</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>([otherCards count] == <span class="number">1</span>) &#123;</span><br><span class="line">        PlayingCard *otherCard = [otherCards firstObject];</span><br><span class="line">      <span class="keyword">if</span>([<span class="keyword">self</span>.suit isEqualToString:otherCard.suit]) &#123;</span><br><span class="line">            score = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.rank == otherCard.rank) &#123;</span><br><span class="line">            score = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以改为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">int</span>)match:(<span class="built_in">NSArray</span> *)otherCards</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>([otherCards count] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">id</span> card = [otherCards firstObject];</span><br><span class="line">        <span class="keyword">if</span>([card isKindOfClass:[PlayingCard <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            PlayingCard *otherCard = (PlayingCard *)card;</span><br><span class="line">            <span class="keyword">if</span>([<span class="keyword">self</span>.suit isEqualToString:otherCard.suit]) &#123;</span><br><span class="line">                score = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.rank == otherCard.rank) &#123;</span><br><span class="line">                score = <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>isMemberOfClass:</code></p>
<p>判断对象是不是某种类，不包括继承的情况</p>
</li>
<li><p><code>respondsToSelector:</code></p>
<p>判断对象能否相应某个函数</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>([obj respondsToSelector:<span class="keyword">@selector</span>(shoot)]) &#123;</span><br><span class="line">    [obj shoot];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([obj respondsToSelector:<span class="keyword">@selector</span>(shootAt:)]) &#123;</span><br><span class="line">    [obj shootAt:target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>在objective-C中，SEL是selector的一种类型</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">SEL shootSelector = <span class="keyword">@selector</span>(shoot);</span><br><span class="line">SEL shootAtSelector = <span class="keyword">@selector</span>(shootAt:);</span><br><span class="line">SEL moveToSelelctor = <span class="keyword">@selector</span>(moveTo:withPenColor);</span><br></pre></td></tr></table></figure>
</li>
<li><p>给定SEL，可以要求对象执行selector</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[obj performSelector:shootSelector];</span><br><span class="line">[obj performSelector:shootAtSelector withObject:coordinate];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[array makeObjectsPerformSelector:shootSelector];</span><br><span class="line"><span class="comment">// cool, huh?</span></span><br><span class="line">[array makeObjectsPerformSelector:shootAtSelector withObject:target];</span><br><span class="line"><span class="comment">// target is an id</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Protocols</p>
<p>不指定指针指向的对象类型，但是指定其实现的函数。</p>
</li>
</ul>
<h1 id="Foundation库"><a href="#Foundation库" class="headerlink" title="Foundation库"></a>Foundation库</h1><h2 id="NSObject"><a href="#NSObject" class="headerlink" title="NSObject"></a>NSObject</h2><p>在iOS SDK中 ，NSObject几乎是所有类的基类。</p>
<p>NSObject包含一个非常有用的函数<code>- (NSString *)description</code>，会返回对类的描述，所以最好在自己实现的类中对其重写。该函数一般用在两个地方：</p>
<ul>
<li><p>用NSLog打印出来，<code>NSLog(@&quot;array contents are  %@&quot;, myArray);</code>，用于debug</p>
</li>
<li><p>并不是所有的对象都实现了<code>- (id)copy</code>和<code>- (id)mutableCopy</code>，在未实现它们的对象中调用，会抛出异常</p>
</li>
<li><p>你向可修改对象（比如MutableArray）发送copy，返回值并不是可修改对象，而是获得一个不可修改的对象。</p>
</li>
</ul>
<h2 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h2><p>NSArray是对象的有序集合，不可修改（immutable），一旦创建，不能添加或删除对象。</p>
<p>只要NSArray本身在内存的堆中，其中所有的对象都有strong指针指向它们。</p>
<p>一般通过<code>@[]</code>手动创建NSArray，NSArray中包括以下一些关键函数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)count;</span><br><span class="line">- (<span class="keyword">id</span>)objectAtIndex:(<span class="built_in">NSUInteger</span>)index; <span class="comment">//如果index超出边界，程序崩溃</span></span><br><span class="line">- (<span class="keyword">id</span>)lastObject; <span class="comment">//如果数组为空，返回nil，不会导致程序崩溃</span></span><br><span class="line">- (<span class="keyword">id</span>)firstObject; <span class="comment">//如果数组为空，返回nil，不会导致程序崩溃</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)sortedArrayUsingSelector:(SEL)aSelector;</span><br><span class="line">- (<span class="keyword">void</span>)makeObjectsPerformsSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)selectorArgument;</span><br><span class="line">- (<span class="built_in">NSString</span> *)componentsJoinedByString:(<span class="built_in">NSString</span> *)separator;</span><br></pre></td></tr></table></figure>

<h2 id="NSMutableArray"><a href="#NSMutableArray" class="headerlink" title="NSMutableArray"></a>NSMutableArray</h2><p>是NSArray的可变版本（mutable），继承了NSArray的所有函数</p>
<p>一般通过<code>alloc/init</code>创建，或者通过以下函数创建</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)arrayWithCapacity:(<span class="built_in">NSUInteger</span>)numItems;</span><br><span class="line">+ (<span class="keyword">id</span>)array;<span class="comment">//[NSMutableArray array] 等价于 [[NSMutableArray alloc] init]</span></span><br></pre></td></tr></table></figure>

<p>对于NSArray和NSMutableArray两种数组，可以用for-in的方式遍历：</p>
<p>Objective-C支持for-in形式的数组遍历。需要注意的是，for-in形式的数组遍历默认会进行强制类型转换，比如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *myArray = ...;<span class="comment">// 任意类型数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *string <span class="keyword">in</span> myArray) &#123; <span class="comment">//编译器不知道数组中的数据类型</span></span><br><span class="line">  <span class="keyword">double</span> = value = [string doubleValue];<span class="comment">// 如果string的类型并不是NSString，会导致程序崩溃</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么如果数组中的数据类型不同，如何进行遍历呢？可以使用id</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *myArray = ...;<span class="comment">// 同样，任意类型的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">  <span class="comment">// 通过某些方法确认obj是你想要的类型，防止程序崩溃</span></span><br><span class="line">  <span class="keyword">if</span>([obj isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">    <span class="comment">// 这是确认了obj的类型是NSString</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NSNumber"><a href="#NSNumber" class="headerlink" title="NSNumber"></a>NSNumber</h2><p>NSNumber是对元类型int、float、double、BOOL、enum等的封装。<strong>当你想把这些元类型的数据放入同一个数组时很有用。</strong></p>
<h2 id="NSValue"><a href="#NSValue" class="headerlink" title="NSValue"></a>NSValue</h2><p>类似于NSNumber，但是用来封装一些非对象、非元类型的数据，例如c structs。</p>
<h2 id="NSData"><a href="#NSData" class="headerlink" title="NSData"></a>NSData</h2><p>用于存储bits</p>
<h2 id="NSDate"><a href="#NSDate" class="headerlink" title="NSDate"></a>NSDate</h2><p>用于存储日期，相关的类型还有NSCalendar，NSDateFormatter，NSDateComponents。</p>
<h2 id="NSSet-NSMutableSet"><a href="#NSSet-NSMutableSet" class="headerlink" title="NSSet/NSMutableSet"></a>NSSet/NSMutableSet</h2><h2 id="NSOrderedSet-NSMutableOrderedSet"><a href="#NSOrderedSet-NSMutableOrderedSet" class="headerlink" title="NSOrderedSet/NSMutableOrderedSet"></a>NSOrderedSet/NSMutableOrderedSet</h2><h2 id="NSDictionary"><a href="#NSDictionary" class="headerlink" title="NSDictionary"></a>NSDictionary</h2><p>存储键值对，不可修改。</p>
<p>NSDictionary可以用<code>@{key1:value1, key2:value2}</code>创建，比如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *colors = @&#123; <span class="string">@"green"</span> : [<span class="built_in">UIColor</span> greenColor],</span><br><span class="line">                        <span class="string">@"blue"</span> : [<span class="built_in">UIColor</span> blueColor],</span><br><span class="line">                        <span class="string">@"red"</span> : [<span class="built_in">UIColor</span> redColor]&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *colorString = <span class="string">@"red"</span>;</span><br><span class="line"><span class="built_in">UIColor</span> *colorObject = colors[colorString];</span><br></pre></td></tr></table></figure>

<h2 id="NSMutableDictionary"><a href="#NSMutableDictionary" class="headerlink" title="NSMutableDictionary"></a>NSMutableDictionary</h2><p>NSDictionary的可修改版本，出了继承了NSDictionary所有的函数，还有下面几个重要函数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)anObject forKey:(<span class="keyword">id</span>)key;</span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key;</span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects;</span><br><span class="line">- (<span class="keyword">void</span>)addEntriesFromDictionary:(<span class="built_in">NSDictionary</span> *)otherDictionary;</span><br></pre></td></tr></table></figure>

<p>Dictionary和NSMutableDictionary可用如下方法遍历：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *myDictionary = ...;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span> key <span class="keyword">in</span> myDictionary) &#123;</span><br><span class="line">  <span class="comment">// do something with key here</span></span><br><span class="line">  <span class="keyword">id</span> value = [myDictionary objectForKey:key];</span><br><span class="line">  <span class="comment">// do something with value here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NSUserDefaults"><a href="#NSUserDefaults" class="headerlink" title="NSUserDefaults"></a>NSUserDefaults</h2><p>介绍NSUserDefaults之前，需要先介绍一个术语：<strong><em>Property List</em></strong></p>
<p>Property List是一个iOS开发中常用术语，在一些API中会用到，比如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)writeToFile:(<span class="built_in">NSString</span> *)path atomically:(<span class="built_in">BOOL</span>)atom;</span><br></pre></td></tr></table></figure>

<p>这个函数只能发送给NSArray或NSDictionary，并且其中只能包含Property List对象。</p>
<ul>
<li><p><strong>概念：</strong></p>
<p>Property List可以理解为只包含NSArray、NSDictionary、NSNumber、NSString、NSDate、NSDate的一个集合，并且Property List是一个递归的概念。</p>
<p>比如一个由NSString组成的NSArray，就是一个Property List</p>
<p>一个由NSArray组成的NSArray是不是一个Property List要看子NSArray是不是Property List，如果是，那组成的NSArray就是一个Property List，否则不是。</p>
<p>对于NSDictionary，只有当其所有key和value都是Property List的时候才是Property List</p>
<p>那么，假设有一个NSArray，其中包含了多个NSDictionary，这些NSDictionary的key都是NSString，value都是NSNumber，那么这个NSArray也是个Property List</p>
</li>
</ul>
<p>NSUserDefaults就是Property List的轻量级存储，可以看成一个持久存储的NSDictionary。算不上一个数据库，通常只用来存储小数据，比如用户设置。</p>
<p>利用standardUserDefaults读写：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setArray:rvArray forKey:<span class="string">@"RecentlyViewed"</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setDouble:(<span class="keyword">double</span>)aDouble forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="built_in">NSInteger</span>)integerForKey;(<span class="built_in">NSString</span> *)key; <span class="comment">// NSInteger is a typedef to 32 or 64 bit int</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)obj forKey:(<span class="built_in">NSString</span> *)key; <span class="comment">//obj must be a Property List</span></span><br><span class="line">-(<span class="built_in">NSArray</span> *)arrayForKey:(<span class="built_in">NSString</span> *)key; <span class="comment">// will return nil if value for key is not NSArray</span></span><br></pre></td></tr></table></figure>

<p>更改后一定要使用synchronize进行同步，才能写入永久内存。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSUser</span> Defaults standardUserDefaults] synchronize];</span><br></pre></td></tr></table></figure>

<h2 id="NSRange"><a href="#NSRange" class="headerlink" title="NSRange"></a>NSRange</h2><p>是一个类似C语言中struct的结构，用于指定string和数组的界限，其结构如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="built_in">NSUInteger</span> location;</span><br><span class="line">  <span class="built_in">NSUInteger</span> length;</span><br><span class="line">&#125; <span class="built_in">NSRange</span>;</span><br></pre></td></tr></table></figure>

<p>使用方法如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *greeting = <span class="string">@"hello world"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *hi = <span class="string">@"hi"</span>;</span><br><span class="line"><span class="built_in">NSRange</span> r = [greeting rangeOfString:hi];</span><br><span class="line"><span class="keyword">if</span>(r.location == <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">  <span class="comment">//没能在greeting中找到hi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UIColor"><a href="#UIColor" class="headerlink" title="UIColor"></a>UIColor</h2><p>一个非常简单的类，用于表示颜色。可以用RGB或者HSB等方法初始化。</p>
<h2 id="UIFont"><a href="#UIFont" class="headerlink" title="UIFont"></a>UIFont</h2><p>字体在UI设计中非常重要，iOS在不同截面显示的字体变化很大，所以要重视UIFont这个类。</p>
<p>对于展示内容而言，使用Font<strong>最好的方法</strong>是调用<code>preferredFontForTextStyle</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> preferredFontForTextStyle:<span class="built_in">UIFontTextStyleBody</span>];</span><br></pre></td></tr></table></figure>

<p>除了<code>UIFontTextStyleBody</code>，还有<code>UIFontTextStyleHeadline</code>、<code>UIFontTextStyleCaption1</code>、<code>UIFontTextStyleFootnote</code>等等。</p>
<p>对于按键内容等，可以使用系统字体：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">UIFont</span> *)systemFontOfSize:(<span class="built_in">CGFloat</span>)pointSize;</span><br><span class="line">+ (<span class="built_in">UIFont</span> *)boldSystemFontOfSize:(<span class="built_in">CGFloat</span>)pointSize;</span><br></pre></td></tr></table></figure>

<p><strong>不要将系统字体用于内容。</strong></p>
<h2 id="UIFontDescriptor"><a href="#UIFontDescriptor" class="headerlink" title="UIFontDescriptor"></a>UIFontDescriptor</h2><p>字体是由艺术家设计的，并没有特定的准则，有些字体甚至没有加黑。尽管如此，UIFontDescriptor尝试对所有字体进行分类。</p>
<h2 id="NSAttributedString"><a href="#NSAttributedString" class="headerlink" title="NSAttributedString"></a>NSAttributedString</h2><p>iOS开发中经常需要显示一些带有特殊样式的文本，比如说带有下划线、删除线、斜体、空心字体、背景色、阴影以及图文混排（一种文字中夹杂图片的显示效果）。</p>
<p>通常想要实现这些效果要使用到iOS的Foundation框架提供的NSAttributedString类，NSAttributedString类中有许多属性，不同属性对应不同的文本样式。本文主要对这些属性做一个解释说明，并会结合实际代码来应用它们。</p>
<p>可以将NSAttributedString想象成NSString，其每个字母有个叫做attributes的NSDictionary。 </p>
<p>NSAttributedString<strong>不是</strong>NSString的继承，所以不能使用NSString的函数。</p>
<h2 id="NSMutableAttributedString"><a href="#NSMutableAttributedString" class="headerlink" title="NSMutableAttributedString"></a>NSMutableAttributedString</h2><p>相对于NSAttributedString，NSMutableAttributedString更加常用。</p>
<p>添加或者设置字母对应attributes的方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addAttributes:(<span class="built_in">NSDictionary</span> *)attributes range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line">- (<span class="keyword">void</span>)setAttributeds:(<span class="built_in">NSDictionary</span> *)attributes range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line">-(<span class="keyword">void</span>)removeAttribute:(<span class="built_in">NSString</span> *)attributeName range:(<span class="built_in">NSRange</span>)range;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *yellow = [<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line"><span class="built_in">UIColor</span> *transparentYellow = [yellow colorWithAlphaComponent:<span class="number">0.3</span>];</span><br><span class="line">@&#123; <span class="built_in">NSFontAttributeName</span>:</span><br><span class="line">     [<span class="built_in">UIFont</span> preferredFontWithTextStyle:<span class="built_in">UIFontTextStyleHeadline</span>],</span><br><span class="line">   <span class="built_in">NSForegroundColorAttributeName</span> : [<span class="built_in">UIColor</span> greenColor], <span class="comment">// 字体颜色</span></span><br><span class="line">   <span class="built_in">NSStrokeWidthAttributeName</span> : @<span class="number">-5</span>,</span><br><span class="line">   <span class="built_in">NSStrokeColorAttributeName</span> : [<span class="built_in">UIColor</span> redColor],</span><br><span class="line">   <span class="built_in">NSUnderlineStyleAttributeName</span> : @(<span class="built_in">NSUnderlineStyleNone</span>), <span class="comment">// 设置字体描边</span></span><br><span class="line">   <span class="built_in">NSBackgroundColorAttributeName</span> : transparentYellow <span class="comment">// 设置字体背景颜色</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp14yomq5ij30ds0oggrt.jpg" alt="image-20210329221812138"></p>
<p>attributed strings用在哪里？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UIButton</span></span><br><span class="line">- (<span class="keyword">void</span>)setAttributedTitle:(<span class="built_in">NSAttributedString</span> *)title forState:...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UILable</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSAttributedString</span> *attributedText;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UITextView</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSTextStorage</span> *textStorage;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发入门</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福大学IOS7开发课程3</title>
    <url>/chinese/2021/03/22/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B3/</url>
    <content><![CDATA[<h1 id="斯坦福大学IOS7开发课程3"><a href="#斯坦福大学IOS7开发课程3" class="headerlink" title="斯坦福大学IOS7开发课程3"></a>斯坦福大学IOS7开发课程3</h1><p>课程3主要内容是继续之前的纸牌游戏。上节课实现的纸牌游戏App只是实现了简单的纸牌翻转，这节课使其变得真正可玩。</p>
<p>主要分为三个部分：</p>
<ol>
<li>先回顾上节课编写的App</li>
<li>对上节课的App改进</li>
<li>使游戏变得可玩</li>
</ol>
<a id="more"></a>

<h2 id="上节课实现的纸牌翻转App"><a href="#上节课实现的纸牌翻转App" class="headerlink" title="上节课实现的纸牌翻转App"></a>上节课实现的纸牌翻转App</h2><ol>
<li><p><strong>将背景颜色设置为绿色</strong></p>
<p>打开<code>Main.storyboard</code>，选中View后，在属性栏里将<code>Background</code>的颜色设置为绿色。</p>
</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo58d9362j30ee0oe773.jpg" class="setBackgroundColor" width="300" height="700" title="设置Background颜色" alt="加载失败">

<ol start="2">
<li><p><strong>添加纸牌正反面的图片</strong></p>
<p>在网上获取纸牌正反面图片，比如：</p>
</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo59iuj4rj30dw0jgqdw.jpg" class="CardBack" width="100" height="250" title="纸牌背面" alt="加载失败">

<img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo59sknnzj30dw0jg74b.jpg" class="CardFront" width="100" height="250" title="纸牌正面" alt="加载失败">


<p>   选中<code>Assets.xcassets</code>，将两张图片拖至其中。</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo5bh0htpj31e00d4adb.jpg" class="addImage" width="600" height="200" title="添加图片到Assets.xcassets" alt="加载失败">

<ol start="3">
<li><strong>添加按钮，并将按钮的背景图片改为纸牌正面图片（CardFront）， 文字改为“♠️A”</strong></li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo5fk47bsj31sg0r4wpk.jpg" class="setButtonBackground" width="600" height="300" title="设置按钮背景图片" alt="加载失败">

<ol start="4">
<li><p><strong>添加一个<code>Label</code>，显示纸牌翻转的次数</strong></p>
</li>
<li><p><strong>为按钮添加“Touch Up Inside”事件，命名为<code>touchCardButton</code></strong></p>
</li>
<li><p><strong>为<code>Label</code>在<code>ViewController.m</code>的<code>@interface ViewController() @end</code>之间添加“Referencing Outlets“，命名为<code>flipsLabel</code>。</strong></p>
</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gooawynczug30v00ienpd.gif" class="addOutlets" width="600" height="300" title="为Label添加Outlet" alt="加载失败">

<ol start="7">
<li><p><strong>另外，在<code>ViewController.m</code>的<code>@interface ViewController() @end</code>之间添加int属性<code>flipCount</code></strong></p>
</li>
<li><p><strong>在<code>ViewController.m</code>中实现touchCardButton事件函数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (IBAction)touchCardButton:(UIButton *)sender &#123;</span><br><span class="line">    if ([sender.currentTitle length]) &#123;</span><br><span class="line">        [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardBack&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [sender setTitle:@&quot;&quot; forState:UIControlStateNormal];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Card *card &#x3D; [self.deck drawRandomCard];</span><br><span class="line">        if(card) &#123;</span><br><span class="line">        [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardFront&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [sender setTitle:@&quot;A♣️&quot; forState:UIControlStateNormal];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    self.flipCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重构属性<code>flipCount</code>的<code>setter</code>函数。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setFlipCount:(int)flipCount</span><br><span class="line">&#123;</span><br><span class="line">    _flipCount &#x3D; flipCount;</span><br><span class="line">    self.flipsLabel.text &#x3D; [NSString stringWithFormat:@&quot;Flips: %d&quot;,self.flipCount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>此时App完成，代码如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ViewController.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController : UIViewController</span><br><span class="line">- (IBAction)touchCardButton:(UIButton *)sender;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ViewController.m</span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (weak, nonatomic) IBOutlet UILabel *flipsLabel;</span><br><span class="line">@property (nonatomic) int flipCount;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)touchCardButton:(UIButton *)sender &#123;</span><br><span class="line">    if ([sender.currentTitle length]) &#123;</span><br><span class="line">        [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardBack&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [sender setTitle:@&quot;&quot; forState:UIControlStateNormal];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardFront&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [sender setTitle:@&quot;A♣️&quot; forState:UIControlStateNormal];</span><br><span class="line">    &#125;</span><br><span class="line">    self.flipCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFlipCount:(int)flipCount</span><br><span class="line">&#123;</span><br><span class="line">    _flipCount &#x3D; flipCount;</span><br><span class="line">    self.flipsLabel.text &#x3D; [NSString stringWithFormat:@&quot;Flips: %d&quot;,self.flipCount];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>最终效果如下：</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1goob73x6nkg30j816ykjm.gif" class="result1" width="300" height="700" title="最终效果1" alt="加载失败">



<h2 id="对该App改进"><a href="#对该App改进" class="headerlink" title="对该App改进"></a>对该App改进</h2><p>上节课完成的App只能实现纸牌的翻转，每次翻转显示的纸牌都是同一张。那么如何让每次翻转，随机显示牌堆中的一张纸牌呢？其实也很简单，方法如下：</p>
<ol>
<li><p><strong>在<code>ViewController.m</code>中引入<code>Deck.h</code></strong></p>
</li>
<li><p><strong>在<code>ViewController.m</code>的<code>@interface ViewController() @end</code>之间添加<code>Deck*</code>属性<code>deck</code></strong></p>
</li>
<li><p><strong>在<code>ViewController.m</code>中引入<code>PlayingCardDeck.h</code></strong></p>
</li>
<li><p><strong>修改属性<code>deck</code>的<code>getter</code>，当<code>_deck</code>为空时，通过<code>[[PlayingCardDeck alloc]init]</code>创建牌堆，然后再返回Deck。</strong></p>
<p>此时<code>ViewController.m</code>的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  ViewController.m</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">#import &quot;PlayingCardDeck.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (weak, nonatomic) IBOutlet UILabel *flipsLabel;</span><br><span class="line">@property (nonatomic) int flipCount;</span><br><span class="line">@property (strong, nonatomic) Deck *deck;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Deck *)deck</span><br><span class="line">&#123;</span><br><span class="line">    if(!_deck)</span><br><span class="line">        _deck &#x3D; [self createDeck];</span><br><span class="line">    return _deck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Deck *)createDeck</span><br><span class="line">&#123;</span><br><span class="line">    return [[PlayingCardDeck alloc]init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (IBAction)touchCardButton:(UIButton *)sender &#123;</span><br><span class="line">    if ([sender.currentTitle length]) &#123;</span><br><span class="line">        [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardBack&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [sender setTitle:@&quot;&quot; forState:UIControlStateNormal];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardFront&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [sender setTitle:@&quot;A♣️&quot; forState:UIControlStateNormal];</span><br><span class="line">    &#125;</span><br><span class="line">    self.flipCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFlipCount:(int)flipCount</span><br><span class="line">&#123;</span><br><span class="line">    _flipCount &#x3D; flipCount;</span><br><span class="line">    self.flipsLabel.text &#x3D; [NSString stringWithFormat:@&quot;Flips: %d&quot;,self.flipCount];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在<code>touchCardButton</code>函数中，利用<code>deck</code>的<code>drawRandomCard</code>函数随机抽取一张纸牌。</strong></p>
</li>
<li><p><strong>将随机抽取出的Card的内容显示出来。需要注意的是，牌堆里的牌抽完以后要停止抽牌。</strong></p>
</li>
</ol>
<p>完成后<code>ViewController.m</code>的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ViewController.m</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">#import &quot;PlayingCardDeck.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (weak, nonatomic) IBOutlet UILabel *flipsLabel;</span><br><span class="line">@property (nonatomic) int flipCount;</span><br><span class="line">@property (strong, nonatomic) Deck *deck;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Deck *)deck</span><br><span class="line">&#123;</span><br><span class="line">    if(!_deck)</span><br><span class="line">        _deck &#x3D; [self createDeck];</span><br><span class="line">    return _deck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Deck *)createDeck</span><br><span class="line">&#123;</span><br><span class="line">    return [[PlayingCardDeck alloc]init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)touchCardButton:(UIButton *)sender &#123;</span><br><span class="line">    if ([sender.currentTitle length]) &#123;</span><br><span class="line">        [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardBack&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [sender setTitle:@&quot;&quot; forState:UIControlStateNormal];</span><br><span class="line">        self.flipCount++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Card *card &#x3D; [self.deck drawRandomCard]; &#x2F;&#x2F; 从牌堆抽随机取一张Card</span><br><span class="line">        if(card) &#123; &#x2F;&#x2F; 牌堆里的牌抽完以后停止抽牌</span><br><span class="line">            [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardFront&quot;] forState:UIControlStateNormal];</span><br><span class="line">            [sender setTitle:card.contents forState:UIControlStateNormal]; &#x2F;&#x2F; 将Card的内容展示出来</span><br><span class="line">            self.flipCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFlipCount:(int)flipCount</span><br><span class="line">&#123;</span><br><span class="line">    _flipCount &#x3D; flipCount;</span><br><span class="line">    self.flipsLabel.text &#x3D; [NSString stringWithFormat:@&quot;Flips: %d&quot;,self.flipCount];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1goobso7hl7g30j816yx6r.gif" class="result2" width="300" height="700" title="最终效果2" alt="加载失败">



<h2 id="使该游戏变得真正可玩"><a href="#使该游戏变得真正可玩" class="headerlink" title="使该游戏变得真正可玩"></a>使该游戏变得真正可玩</h2><p>接下来我们让游戏变得真正可玩儿。在MVC开发模型中，游戏的逻辑属于Model，Model和UI是完全独立的，所以在编写过程中不需要考虑UI。</p>
<h3 id="Model开发"><a href="#Model开发" class="headerlink" title="Model开发"></a>Model开发</h3><p>首先添加一个新的类<code>CardMatchingGame</code>，这个类就是MVC模型中的Model，在编码<code>CardMathingGame</code>的过程中，需要思考需要哪些公开的API。</p>
<ol>
<li>首先是构造函数，因为需要传进一些参数，比如牌的张数，所以新建构造函数<code>initWithCardCount</code>，指定构造函数（designated initializer）</li>
<li>公开的属性 score，但同时我们不希望别人能够随意修改socre属性，因此需要在公开API中将其设置为readonly，同时在.m文件中的私密API中声明为readwrite。其实readwrite用的不多，因为默认情况下就是readwrite，只有在公开API只读的时候才会用到。</li>
<li>允许用户通过index选中纸牌<code>chooseCardAtIndex</code></li>
<li>通过index从牌堆中获取Card，<code>CardAtIndex</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; CardMatchingGame.h</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface CardMatchingGame : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; designated initializer</span><br><span class="line">- (instancetype)initWithCardCount:(NSUInteger)count usingDeck:(Deck *)deck;</span><br><span class="line">- (void)chooseCardAtIndex:(NSUInteger)index;</span><br><span class="line">- (Card *)cardAtIndex:(NSUInteger)index;</span><br><span class="line">@property (nonatomic, readonly) NSInteger score;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure>

<p>接下来开始在<code>CardMatchingGame.m</code>中开始实现:</p>
<ol>
<li><p>利用关键字<code>readwrite</code>使得属性score在<code>CardMatchingGame.m</code>中可写。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CardMatchingGame</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSInteger</span> score;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>新建属<code>cards</code>，用于存储游戏中的纸牌。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CardMatchingGame</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSInteger</span> score;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *cards; <span class="comment">// of Card</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改属性<code>cards</code>的<code>getter</code>函数</p>
<p>属性的默认初始值为nil，当属性<code>cards</code>的指针为nil时，创建一个<code>NSMutableArray</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-(NSMutableArray *)cards</span><br><span class="line">&#123;</span><br><span class="line">    if(!_cards) &#123;</span><br><span class="line">        _cards &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    return _cards;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现构造函数<code>initWithCardCount</code></p>
<p>这个构造函数是designated initializer，也就是说使用这个类的用户必须调用这个构造函数，否则类无法被正确的初始化。使用构造函数init会返回nil。这个信息要传递给用户，所以以注释的形式写在公开API中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-(instancetype) initWithCardCount:(NSUInteger)count usingDeck:(Deck *)deck</span><br><span class="line">&#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if(self) &#123;</span><br><span class="line">        for(int i &#x3D; 0;i &lt; count;i++) &#123;</span><br><span class="line">            Card *card &#x3D; [deck drawRandomCard];</span><br><span class="line">            if(card) &#123;</span><br><span class="line">                [self.cards addObject:card];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                self &#x3D; nil;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现函数<code>cardAtIndex</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (Card *)cardAtIndex:(NSUInteger)index</span><br><span class="line">&#123;</span><br><span class="line">    return index &lt; [self.cards count] ? self.cards[index] : nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现函数<code>chooseCardAtIndex</code></p>
<p>这个函数是游戏的关键。表示某个card被选中后的处理方式，包括匹配过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static const int PENALTY_SCORE &#x3D; 1;</span><br><span class="line">static const int COST_OF_CHOOSE &#x3D; 1;</span><br><span class="line"></span><br><span class="line">-(void)chooseCardAtIndex:(NSUInteger)index</span><br><span class="line">&#123;</span><br><span class="line">    Card *card &#x3D; [self cardAtIndex:index];</span><br><span class="line">    if(!card.isMatched) &#123;</span><br><span class="line">        &#x2F;&#x2F; if choosen card is not matched</span><br><span class="line">        if(card.isChosen) &#123; &#x2F;&#x2F; if the card is already chosen</span><br><span class="line">            card.chosen &#x3D; NO; &#x2F;&#x2F; filp the card back</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; match it against another card</span><br><span class="line">            &#x2F;&#x2F; here, only match two cards, but may make it match multiple cards in later</span><br><span class="line">            for(Card *otherCard in self.cards) &#123;</span><br><span class="line">                if(otherCard.isChosen &amp;&amp; !otherCard.isMatched) &#123; &#x2F;&#x2F; Bingo, find the card we want to match</span><br><span class="line">                    int matchScore &#x3D; [card match:@[otherCard]]; &#x2F;&#x2F; try to match it</span><br><span class="line">                    if(matchScore &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; not match</span><br><span class="line">                        self.score -&#x3D; PENALTY_SCORE; &#x2F;&#x2F; penalty of un match</span><br><span class="line">                        otherCard.chosen &#x3D; NO; &#x2F;&#x2F; flip the other card back</span><br><span class="line">                    &#125; else &#123; &#x2F;&#x2F; match</span><br><span class="line">                        self.score +&#x3D; matchScore;</span><br><span class="line">                        card.matched &#x3D; YES;</span><br><span class="line">                        otherCard.matched &#x3D; YES;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            card.chosen &#x3D; YES;</span><br><span class="line">            self.score -&#x3D; COST_OF_CHOOSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; if choosen card is already matched</span><br><span class="line">        &#x2F;&#x2F; do nothing</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="UI开发"><a href="#UI开发" class="headerlink" title="UI开发"></a>UI开发</h3><p>到目前，完成了App中Model的实现，接下来是实现App的UI。</p>
<ol>
<li><p>在UI中创建多张纸牌，可以通过复制粘贴的方式完成</p>
</li>
<li><p>创建OutletCollections，添加所有纸牌。</p>
<p>创建方法，右键点击某个button，按住“New Referencing Outlet Collections“，拖到<code>ViewController.m</code>中。</p>
<p>添加其他button的方法，按住Ctrl键，点击button并拖到<code>ViewController.m</code>中</p>
</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gopcewkpqrg30n80v41l3.gif" class="addOutletCollections" width="300" height="700" title="添加OutletCollections" alt="加载失败">

<ol start="3">
<li><p>在<code>ViewController.m</code>中引入<code>CardMatchingGame.h</code></p>
</li>
<li><p>新增<code>CardMatchingGame</code>的属性<code>game</code></p>
<p><code>@property (strong, nonatomic) CardMatchingGame *game;</code></p>
</li>
<li><p>重写属性<code>game</code>的<code>getter</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (CardMatchingGame *)game&#123;</span><br><span class="line">    <span class="keyword">if</span>(!_game) &#123;</span><br><span class="line">        _game = [[CardMatchingGame alloc] initWithCardCount:[<span class="keyword">self</span>.cardButtons count] usingDeck:[<span class="keyword">self</span> createDeck]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _game;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>ViewController.m</code>中创建函数<code>titleForCard</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSString *)titleForCard:(Card *)card</span><br><span class="line">&#123;</span><br><span class="line">    return card.isChosen ? card.contents : @&quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>ViewController.m</code>中创建函数<code>backgroundImageForCard</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)backgroundImageForCard:(Card *)card</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageNamed:card.isChosen ? <span class="string">@"CardFront"</span> : <span class="string">@"CardBack"</span>]; <span class="comment">// CardFront &amp; CardBack are name of card image</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>ViewController.m</code>中创建函数<code>updateUI</code>用于同步Model和UI。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateUI</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIButton</span> *cardButton <span class="keyword">in</span> <span class="keyword">self</span>.cardButtons) &#123;</span><br><span class="line">        <span class="keyword">int</span> cardIndex = [<span class="keyword">self</span>.cardButtons indexOfObject:cardButton];</span><br><span class="line">        Card *card = [<span class="keyword">self</span>.game cardAtIndex:cardIndex];</span><br><span class="line">        [cardButton setTitle:[<span class="keyword">self</span> titleForCard:card] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        [cardButton setBackgroundImage:[<span class="keyword">self</span> backgroundImageForCard:card] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        cardButton.enabled = !card.isMatched;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Touch Up Inside事件，命名为touchCardButton，并将所有button加入其中，方法类似于步骤2.</p>
</li>
<li><p><code>.m</code>文件中实现<code>touchCardButton</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)touchCardButton:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">    <span class="keyword">int</span> cardIndex = [<span class="keyword">self</span>.cardButtons indexOfObject:sender];</span><br><span class="line">    [<span class="keyword">self</span>.game chooseCardAtIndex:cardIndex];</span><br><span class="line">    [<span class="keyword">self</span> updateUI];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>到这个时候App已经可以运行了，运行效果如下：</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosmu8s2gmg30j01261kx.gif" class="result3" width="300" height="700" title="最终效果3" alt="加载失败">

<p>可以正常运行，但是两张黑桃却没有正常匹配，问题出在哪里？</p>
<p>问题在我们在<a href="https://zhang-tianxu.github.io/chinese/2021/03/15/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B2/">课程2</a>中实现的<code>Card</code>类中的匹配函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Card.m</span><br><span class="line">- (int)match:(NSArray *)otherCards</span><br><span class="line">&#123;</span><br><span class="line">  int score &#x3D; 0;</span><br><span class="line">  for(Card *card in otherCards) &#123;</span><br><span class="line">    if([card.contents isEqualToString:self.contents])</span><br><span class="line">      score &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">    return score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这显然不是一个完整的匹配逻辑。</p>
<p>所以需要在<code>PlayingCard</code>类的<code>.m</code>文件中重构<code>match</code>函数。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">int</span>)match:(<span class="built_in">NSArray</span> *)otherCards</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>([otherCards count] == <span class="number">1</span>) &#123;</span><br><span class="line">        PlayingCard *otherCard = [otherCards firstObject];</span><br><span class="line">        <span class="keyword">if</span>([<span class="keyword">self</span>.suit isEqualToString:otherCard.suit]) &#123; <span class="comment">// 如果花色匹配</span></span><br><span class="line">            score = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span>.rank == otherCard.rank]) &#123; <span class="comment">// 如果数字匹配</span></span><br><span class="line">            score = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在完成了匹配规则，最后一个任务是添加一个<code>Label</code>用于展示分数。</p>
<ol>
<li><p>在UI中增加一个Label</p>
</li>
<li><p>为Label增加一个Outlet</p>
</li>
<li><p>在<code>updateUI</code>中更新score Label。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)updateUI</span><br><span class="line">&#123;</span><br><span class="line">    for (UIButton *cardButton in self.cardButtons) &#123;</span><br><span class="line">        int cardIndex &#x3D; [self.cardButtons indexOfObject:cardButton];</span><br><span class="line">        Card *card &#x3D; [self.game cardAtIndex:cardIndex];</span><br><span class="line">        [cardButton setTitle:[self titleForCard:card] forState:UIControlStateNormal];</span><br><span class="line">        [cardButton setBackgroundImage:[self backgroundImageForCard:card] forState:UIControlStateNormal];</span><br><span class="line">        cardButton.enabled &#x3D; !card.isMatched;</span><br><span class="line">    &#125;</span><br><span class="line">    self.scoreLabel.text &#x3D; [NSString stringWithFormat:@&quot;Score: %d&quot;, self.game.score];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosov9rkvfg30j0126kjl.gif" class="result4" width="300" height="700" title="最终效果4" alt="加载失败">

<p>至此，一个可玩的纸牌匹配游戏App已经完成，大家可以试着让App可以同时匹配三张及以上的纸牌。</p>
]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发入门</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福大学IOS7开发课程2</title>
    <url>/chinese/2021/03/15/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B2/</url>
    <content><![CDATA[<h1 id="斯坦福大学IOS7开发课程2"><a href="#斯坦福大学IOS7开发课程2" class="headerlink" title="斯坦福大学IOS7开发课程2"></a>斯坦福大学IOS7开发课程2</h1><p>这节课就着手开始实现”Card Matching Game”，纸牌匹配游戏。</p>
<p>具体来说就是实现涉及的各种类，以及XCode的简单使用。</p>
<a id="more"></a>

<h2 id="Card类"><a href="#Card类" class="headerlink" title="Card类"></a>Card类</h2><p>下面代码是<a href="https://zhang-tianxu.github.io/chinese/2021/03/15/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B1/">课程1</a>结束时的Card类，包括<code>Card.h</code>和<code>Card.m</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Card.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation&gt;</span><br><span class="line">@interface Card : NSObject</span><br><span class="line">@property (strong nonatomic) NSString *contents;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, getter&#x3D;isChosen) BOOL chosen;</span><br><span class="line">@property (nonatomic, getter&#x3D;isMatched) BOOL matched;</span><br><span class="line">- (int)match:(NSArray *)otherCards;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Card.m</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line">@interface Card()</span><br><span class="line">@end</span><br><span class="line">@implementation Card</span><br><span class="line"></span><br><span class="line">- (int)match:(NSArray *)otherCards</span><br><span class="line">&#123;</span><br><span class="line">  int score &#x3D; 0;</span><br><span class="line">  for(Card *card in otherCards) &#123;</span><br><span class="line">    if([card.contents isEqualToString:self.contents])</span><br><span class="line">      score &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="Deck类"><a href="#Deck类" class="headerlink" title="Deck类"></a>Deck类</h2><p>这节课首先添加另外一个类：整幅牌Deck，下面是上节课学的类的基本结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Deck : NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.m</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">@interface Deck()</span><br><span class="line">@end</span><br><span class="line">@implementation Deck</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>接下来为Deck类添加两个基础的方法:</p>
<ul>
<li>向Deck中添加牌的<code>addCard</code>，其中atTop表示是否将新的牌放在牌堆的顶部。</li>
<li>另一个是从Deck中随机抽取牌的<code>drawRandomCard</code>：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line"></span><br><span class="line">@interface Deck : NSObject</span><br><span class="line">- (void)addCard:(Card *)card atTop:(BOOL)atTop;</span><br><span class="line"></span><br><span class="line">- (Card *)drawRandomCard;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>如果希望<code>addCard</code>的参数<code>atTop</code>是<strong>可选参数</strong>，在Objective-C中唯一的方法就是声明一个新的函数，这个函数也叫<code>addCard</code>，但是没有参数<code>atTop</code>。这两个<code>addCard</code>是两个不同的函数，相互之间并没有关联。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line"></span><br><span class="line">@interface Deck : NSObject</span><br><span class="line">- (void)addCard:(Card *)card atTop:(BOOL)atTop;</span><br><span class="line">- (void)addCard:(Card *)card;</span><br><span class="line"></span><br><span class="line">- (Card *)drawRandomCard;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>为了存储牌堆中的牌，需要在私密API中添加一个属性，类型是可变数组<code>NSMutableArray</code>。mutable意味着可以向数组中添加或删除数据，而普通的<code>NSArray</code>是不能修改的，一旦被建立，不能添加数据也不能删除。</p>
<p><strong>在Objective-C中声明数组没办法指定数据类型。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.m</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">@interface Deck()</span><br><span class="line">@property (strong, nonatomic) NSMutableArray *cards; &#x2F;&#x2F; of Card</span><br><span class="line">@end</span><br><span class="line">@implementation Deck</span><br><span class="line">  </span><br><span class="line">- (void)addCard:(Card *)card atTop:(BOOL)atTop</span><br><span class="line">&#123;</span><br><span class="line">  if (atTop) &#123;</span><br><span class="line">    [self.cards insertObject:card atIndex:0];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    [self.cards addObject:card];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addCard:(Card *)card</span><br><span class="line">&#123;</span><br><span class="line">  [self addCard:card atTop:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Card *)drawRandomCard</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>根据上节课说到构建属性时自动生成的getter和setter，新建一个Deck类后，其所有的变量和属性都<strong><em>会被自动初始化为0/nil</em></strong>，属性<code>cards</code>是一个空指针，因此调用<code>addCard</code>时虽然不会导致程序的崩溃，但是也不能正常工作。</p>
<p>那么怎么解决这个问题呢？方法是重写属性的getter函数，在getter中添加一个判断结构，属性cards自动生成的getter是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSMutableArray *)cards</span><br><span class="line">&#123;</span><br><span class="line">  return _cards;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了在其中添加一个判断逻辑，需要手动重写这个getter：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.m</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">@interface Deck()</span><br><span class="line">@property (strong, nonatomic) NSMutableArray *cards; &#x2F;&#x2F; of Card</span><br><span class="line">@end</span><br><span class="line">@implementation Deck</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 为了处理cards为空指针的情况，手动重写getter</span><br><span class="line">- (NSMutableArray *)cards</span><br><span class="line">&#123;</span><br><span class="line">  if(!_cards) _cards &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">  return _cards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addCard:(Card *)card atTop:(BOOL)atTop</span><br><span class="line">&#123;</span><br><span class="line">  if (atTop) &#123;</span><br><span class="line">    [self.cards insertObject:card atIndex:0];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    [self.cards addObject:card];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addCard:(Card *)card</span><br><span class="line">&#123;</span><br><span class="line">  [self addCard:card atTop:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Card *)drawRandomCard</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>接下来实现<code>drawRandomCard</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.m</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">@interface Deck()</span><br><span class="line">@property (strong, nonatomic) NSMutableArray *cards; &#x2F;&#x2F; of Card</span><br><span class="line">@end</span><br><span class="line">@implementation Deck</span><br><span class="line"></span><br><span class="line">- (  NSMutableArray *)cards</span><br><span class="line">&#123;</span><br><span class="line">  if(!_cards) _cards &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">  return _cards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addCard:(Card *)card atTop:(BOOL)atTop</span><br><span class="line">&#123;</span><br><span class="line">  if (atTop) &#123;</span><br><span class="line">    [self.cards insertObject:card atIndex:0];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    [self.cards addObject:card];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addCard:(Card *)card</span><br><span class="line">&#123;</span><br><span class="line">  [self addCard:card atTop:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Card *)drawRandomCard</span><br><span class="line">&#123;</span><br><span class="line">  Card *randomCard &#x3D; nil;</span><br><span class="line">  </span><br><span class="line">  if([self.cards count]) &#123;</span><br><span class="line">    unsigned index &#x3D; arc4random() % [self.cards count];</span><br><span class="line">    randomCard &#x3D; self.cards[index];</span><br><span class="line">    [self.cards removeObjectAtIndex:index];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return randomCard;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>至此，Deck类已经完成。</p>
<h2 id="PlayingCard类"><a href="#PlayingCard类" class="headerlink" title="PlayingCard类"></a>PlayingCard类</h2><p>接下来再添加一个类：<code>PlayingCard</code>，同样的，基本结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.h</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line">@interface PlayingCard : Card &#x2F;&#x2F; 终于有个类的父类不是NSObject了</span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>给类添加两个属性<code>suit</code>和<code>rank</code>，前者表示牌的花色“桃（hearts）”、“（方片）diamons”、“（梅花）clubs”，后者表示1到13。另外在<code>.m</code>文件中，重写父类属性content的getter。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.h</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line">@interface PlayingCard : Card</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) NSString *suit;</span><br><span class="line">@property (nonatomic) NSUInteger rank;</span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  return [NSString stringWithFormat:@&quot;%d%@&quot;,self.rank, self.suit];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>注意到，字符串前面有个<code>@</code>，这<strong><em>表示把字符串变成一个字符串类</em></strong>。其中<code>%@</code>表示一个对象，当然可以是字符串。</p>
<p>重写父类属性contents的getter之后，获取contents内容会返回“数字 + 花色”，比如“3红桃”、“1梅花”、“13方片”等。但是在纸牌中，我们一般会把1说成A，11说成J等……，为了符合这个习惯，上面的contents重写可以改成下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  NSArray *rankStrings &#x3D; @[@&quot;?&quot;,@&quot;A&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;10&quot;,@&quot;J&quot;,@&quot;Q&quot;,@&quot;K&quot;];</span><br><span class="line">  &#x2F;&#x2F; 将0-13表示为?,1,2,...,J,Q,K</span><br><span class="line">  return [rankStrings[self.rank] stringByAppendingString:self.suit];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>将rank的0设置为”？“是因为objective-C默认将rank初始化为0，”？“表示这是未知的，没有经过设置的。那如果花色没经过设置也会显示”？“就更好了，解决方法也是重写suit属性的getter函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  NSArray *rankStrings &#x3D; @[@&quot;?&quot;,@&quot;A&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;10&quot;,@&quot;J&quot;,@&quot;Q&quot;,@&quot;K&quot;];</span><br><span class="line">  &#x2F;&#x2F; 将0-13表示为?,1,2,...,J,Q,K</span><br><span class="line">  return [rankStrings[self.rank] stringByAppendingString:self.suit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  return _suit?_suit:@&quot;?&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>suit的选择应该只有四种，为了防止suit被设置为其他值，还要重写suit属性的setter：<code>setSuit</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  NSArray *rankStrings &#x3D; @[@&quot;?&quot;,@&quot;A&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;10&quot;,@&quot;J&quot;,@&quot;Q&quot;,@&quot;K&quot;];</span><br><span class="line">  &#x2F;&#x2F; 将0-13表示为?,1,2,...,J,Q,K</span><br><span class="line">  return [rankStrings[self.rank] stringByAppendingString:self.suit];</span><br><span class="line">&#125;</span><br><span class="line">@synthesize suit &#x3D; _suit;</span><br><span class="line">&#x2F;&#x2F; 因为重构了suit的getter和setter，所以要手写@synthesize</span><br><span class="line">- (void)setSuit:(NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  if([@[@&quot;♥️&quot;,@&quot;♦️&quot;,@&quot;♠️&quot;,@&quot;♣️&quot;] containsObject:suit]) &#123;</span><br><span class="line">    _suit &#x3D; suit;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  return _suit?_suit:@&quot;?&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>值得注意的是，<code>setSuit</code>中的第一个<code>@</code>表示创建新的数组，在这里，每次判断都会新建这个数组。为了性能和代码简介，可以新建函数来判断setter收到的suit是否有效。实际上，这种改变对性能的提升是极其有限的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  NSArray *rankStrings &#x3D; @[@&quot;?&quot;,@&quot;A&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;10&quot;,@&quot;J&quot;,@&quot;Q&quot;,@&quot;K&quot;];</span><br><span class="line">  &#x2F;&#x2F; 将0-13表示为?,1,2,...,J,Q,K</span><br><span class="line">  return [rankStrings[self.rank] stringByAppendingString:self.suit];</span><br><span class="line">&#125;</span><br><span class="line">@synthesize suit &#x3D; _suit;</span><br><span class="line">&#x2F;&#x2F; 因为重构了suit的getter和setter，所以要手写@synthesize</span><br><span class="line"></span><br><span class="line">+ (NSArray *)validSuits</span><br><span class="line">&#123;</span><br><span class="line">  return @[@&quot;♥️&quot;,@&quot;♦️&quot;,@&quot;♠️&quot;,@&quot;♣️&quot;];</span><br><span class="line">&#125;</span><br><span class="line">- (void)setSuit:(NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  if([[PlayingCard validSuits] containsObject:suit]) &#123;</span><br><span class="line">    &#x2F;&#x2F; 类的函数的调用方法。</span><br><span class="line">    _suit &#x3D; suit;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  return _suit?_suit:@&quot;?&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>这里在函数实现前面第一次出现了<code>+</code>符号，这个符号表示这个函数是<strong>类的函数</strong>（而不是对象的函数）。</p>
<p><strong><em>一般只在两种情况下使用类的函数：</em></strong></p>
<ol>
<li><p>工具函数（utility method），比如这里的<code>validSuits</code>。</p>
</li>
<li><p>创建类的函数，比如<code>stringWithFormat</code>。</p>
<p>对rank属性做同样的检查和优化，并添加一个公开API<code>maxRank</code>返回rank的最大值，比如现在是13。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.h</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line">@interface PlayingCard : Card</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) NSString *suit;</span><br><span class="line">@property (nonatomic) NSUInteger rank;</span><br><span class="line"></span><br><span class="line">+ (NSArray *)validSuits;</span><br><span class="line">+ (NSUInteger)maxRank;</span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  NSArray *rankStrings &#x3D; [PlayingCard rankStrings];</span><br><span class="line">  &#x2F;&#x2F; 将0-13表示为?,1,2,...,J,Q,K</span><br><span class="line">  return [rankStrings[self.rank] stringByAppendingString:self.suit];</span><br><span class="line">&#125;</span><br><span class="line">@synthesize suit &#x3D; _suit;</span><br><span class="line">&#x2F;&#x2F; 因为重构了suit的getter和setter，所以要手写@synthesize</span><br><span class="line"></span><br><span class="line">+ (NSArray *)validSuits</span><br><span class="line">&#123;</span><br><span class="line">  return @[@&quot;♥️&quot;,@&quot;♦️&quot;,@&quot;♠️&quot;,@&quot;♣️&quot;];</span><br><span class="line">&#125;</span><br><span class="line">- (void)setSuit:(NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  if([[PlayingCard validSuits] containsObject:suit]) &#123;</span><br><span class="line">    &#x2F;&#x2F; 类的函数的调用方法。</span><br><span class="line">    _suit &#x3D; suit;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  return _suit?_suit:@&quot;?&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSArray *)rankStrings</span><br><span class="line">&#123;</span><br><span class="line">  return @[@&quot;?&quot;,@&quot;A&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;10&quot;,@&quot;J&quot;,@&quot;Q&quot;,@&quot;K&quot;];</span><br><span class="line">&#125;</span><br><span class="line">+ (NSUInteger)maxRank</span><br><span class="line">&#123;</span><br><span class="line">  return [[self rankStrings] count]-1;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setRank:(NSUInteger)rank</span><br><span class="line">&#123;</span><br><span class="line">  if(rank &lt;&#x3D; [PlayingCard maxRank]) &#123;</span><br><span class="line">    _rank &#x3D; rank;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="PlayingCardDeck类"><a href="#PlayingCardDeck类" class="headerlink" title="PlayingCardDeck类"></a>PlayingCardDeck类</h2><p>接下来可以开始玩牌了，创建一个新的类<code>PlayingCardDeck</code>，继承自<code>Deck</code>类，但是需要<strong>重写构造函数</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCardDeck.h</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line"></span><br><span class="line">@interface PlayingCardDeck : Deck</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCardDeck.m</span><br><span class="line">#import &quot;PlayingCardDeck.h&quot;</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation PlayingCardDeck</span><br><span class="line">- (instancetype)init &#x2F;&#x2F; instancetype类只在init中使用</span><br><span class="line">&#123;</span><br><span class="line">  self &#x3D; [super init];</span><br><span class="line">  &#x2F;&#x2F; 调用父类的构造函数</span><br><span class="line">  if(self) &#123; </span><br><span class="line">    &#x2F;&#x2F; 父类正常完成构造，继续子类的构造函数</span><br><span class="line">    &#x2F;&#x2F; 如果父类无法完成构造，将不执行子类的构造代码</span><br><span class="line">    for (NSString *suit in [PlayingCard validSuits]) &#123;</span><br><span class="line">      for (NSUInteger rank &#x3D; 1; rank &lt;&#x3D; [PlayingCard maxRank]; rank++) &#123;</span><br><span class="line">        PlayingCard *card &#x3D; [[PlayingCard allo] init];</span><br><span class="line">        card.rank &#x3D; rank;</span><br><span class="line">        card.suit &#x3D; suit;</span><br><span class="line">        [self addCard:card];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="XCode的简单使用"><a href="#XCode的简单使用" class="headerlink" title="XCode的简单使用"></a>XCode的简单使用</h2><p>课程剩余的部分就是以纸牌游戏为例，简单介绍XCode的使用，开发一个简单的App，App内容是显示纸牌，点击纸牌将其翻转。</p>
<p>由于课程介绍的是XCode 5，笔者记笔记的时候已经是XCode 12.4了，有了不小的变化，参考笔者另一篇笔记（<a href="https://zhang-tianxu.github.io/chinese/2021/03/09/Objective-C-IOS%E5%BC%80%E5%8F%91%E4%B9%8BHelloWorld/">Objective-C IOS开发之HelloWorld</a>），应该也不难完成，就不再具体介绍实现了。</p>
<p>相较于HelloWorld这个App，课程中实现的App另外涉及了以下知识点：</p>
<ul>
<li><p>图像添加</p>
<p>直接将图片拖到<code>Assets.xcassets</code>文件夹中</p>
</li>
<li><p>button背景图片的设置</p>
<p>点击button，在属性中点击<code>Background</code>下拉菜单，就会显示上一步添加的图片选项，以及一些原始icon。</p>
</li>
<li><p>Action中的sender其实就是触发事件的View对象</p>
</li>
<li><p>类的添加</p>
<p>添加类的方法，XCode 12中其实就是新建<code>Cocoa Touch Class</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发入门</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福大学IOS7开发课程1</title>
    <url>/chinese/2021/03/15/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B1/</url>
    <content><![CDATA[<h1 id="斯坦福大学IOS7开发课程1"><a href="#斯坦福大学IOS7开发课程1" class="headerlink" title="斯坦福大学IOS7开发课程1"></a>斯坦福大学IOS7开发课程1</h1><p>IOS7开发课程讲了如何利用Objective-C语言开发IOS App，而且涉及到很多必须的基础知识，非常值得学习。</p>
<p>课程1讲了一些关于课程安排和作业的事情，自学就不需要了，只选取下面三个<strong>知识点：</strong></p>
<ul>
<li>IOS里有什么</li>
<li>MVC开发模型</li>
<li>Objective-C</li>
</ul>
<a id="more"></a>

<h2 id="IOS里有什么"><a href="#IOS里有什么" class="headerlink" title="IOS里有什么"></a>IOS里有什么</h2><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gok87jp5hnj20lq15ctky.jpg" class="inIOS" width="300" height="700" title="IOS里有什么" alt="加载失败">

<p>总的来说，可以将IOS涉及的组件分为4组或者说4层：</p>
<ul>
<li><p>Core OS</p>
<p>最接近硬件的一层，其实就是Unix操作系统，Unix内核中有的功能，Core OS都有，比如：</p>
<ul>
<li>OSX Kernel</li>
<li>Power Management</li>
<li>Sockets</li>
<li>File System</li>
</ul>
<p>等等……</p>
</li>
<li><p>Core Services</p>
<p>基于Core OS的面向对象层。</p>
<p>Core OS层的API几乎都是用C写的，为了以<em>面向对象</em>的方式编程，加入了Core Services层。这一层包括：</p>
<ul>
<li>Collections</li>
<li>File Access</li>
<li>Networking</li>
<li>Threading</li>
<li>SQLite</li>
<li>Core Location</li>
</ul>
<p>等等</p>
</li>
<li><p>Media</p>
<p>用于展现多媒体，包括视频、图片、声音、文件等等，是非常重要的一层。</p>
</li>
<li><p>Cocoa Touch</p>
<p>Cocoa的API起源于Mac OS X，已经有三十年左右的历史了，是UI层。对IOS开发者来说是需要花比较多时间来学习的一层。这一层可以用来构建按键、滑块、开关、文字输入、动画等等。包括：</p>
<ul>
<li>Multi-Touch</li>
<li>Alerts</li>
<li>Web View</li>
<li>Camera</li>
<li>Controls</li>
</ul>
<p>等等。</p>
</li>
</ul>
<h2 id="MVC开发模型"><a href="#MVC开发模型" class="headerlink" title="MVC开发模型"></a>MVC开发模型</h2><p>Model View Controller是一种用于组织应用程序中所有类的策略，将每个类分成Model 阵营、Controller 阵营或者View 阵营中的额一个。</p>
<p>Model用来描述你的程序是什么，以纸牌游戏为例，纸牌、牌桌甚至玩牌的规则都是独立于UI的，应该放在Model阵营中。至于纸牌是如何展示在屏幕上的，是由Controller负责的，Controller负责如何展现Model，以及展现Model的动画等。View是Controller的下属，是Controller用于构建UI的组件。</p>
<p>View是通用的，比如按键、开关等，是所有程序通用的，而Contrller是针对程序设计的，Model则是完全独立于UI的。</p>
<h3 id="MVC模型中三个阵营之间的通信"><a href="#MVC模型中三个阵营之间的通信" class="headerlink" title="MVC模型中三个阵营之间的通信"></a>MVC模型中三个阵营之间的通信</h3><h4 id="Controller-gt-Model"><a href="#Controller-gt-Model" class="headerlink" title="Controller -&gt; Model"></a>Controller -&gt; Model</h4><p>  Controller了解Model的一切，并且可以任意给Model发消息。</p>
<h4 id="Controller-gt-View"><a href="#Controller-gt-View" class="headerlink" title="Controller -&gt; View"></a>Controller -&gt; View</h4><p>  Controller也可以任意给View发送消息，如果Controller有个property指向View，把这个property成为<strong><em>outlet</em></strong>。</p>
<h4 id="Model-lt-gt-View"><a href="#Model-lt-gt-View" class="headerlink" title="Model &lt;-&gt; View"></a>Model &lt;-&gt; View</h4><p>  永远<strong>不要</strong>让Model和View之间直接通信。因为Model应该是完全独立于UI的，所以不应该给View发消息，而View是通用的，所以也不应该发消息给Model。</p>
<h4 id="View-gt-Controller"><a href="#View-gt-Controller" class="headerlink" title="View -&gt; Controller"></a>View -&gt; Controller</h4><p>View能向Controller发消息么？可以是可以，但是因为View是通用的，它对Controller并不了解，所以他们只能通过约定好的形式向Controller发送消息，有两种方式：</p>
<ul>
<li><p>target action</p>
<p>Controller在内部建立一个target，并给View一个action。当View执行一些操作，比如按键被按下的时候，view会向Controller内的target发射action，这种方式下，View可以不了解Controller，只需要知道某些操作被执行时向Controller发送action。</p>
</li>
<li><p>delegate</p>
<p>target action方式没办法处理非常复杂的通信。比如在一个滚动框中，用户按下手指准备滚动，需要让Controller知道用户要滚动了。因为是否允许用户的滚动请求，View是不知道的，所以需要让Controller代理其执行。有一种特殊的delegate，称为data source。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gok7sf8e9mj20xm0jadhu.jpg" alt="image-20210314123540992"></p>
</li>
</ul>
<p>View并不拥有它们展示的数据</p>
<h4 id="Model-gt-Controller"><a href="#Model-gt-Controller" class="headerlink" title="Model -&gt; Controller"></a>Model -&gt; Controller</h4><p>那么model能向Controller发送消息么？</p>
<p>model应该是完全独立于UI的，所以不能直接向Controller发送消息。但有的时候确实有这样的需求，比如Model中数据变化了，需要告诉Controller，这时可以通过广播的方式，向所有感兴趣的人发送消息，其中当然可以包括Controller</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gok7tedpf9j20wc0jstw6.jpg" alt="image-20210314123951433"></p>
<h3 id="MVCs模型"><a href="#MVCs模型" class="headerlink" title="MVCs模型"></a>MVCs模型</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gok7tphhwkj211q0mg4qp.jpg" alt="image-20210314124445333"></p>
<h2 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C"></a>Objective-C</h2><p>Objective-C的一些基础语法可以到<a href="https://www.yiibai.com/objective_c/" target="_blank" rel="noopener">易百Objective-C教程</a>学习，本课程中只是讲了一些和C/C++等语言不通的地方。和常见的编程语言C++或java相比，Objective-C有个重要的概念“Properties”，在Objective-C中一般不直接读写实例的变量，properties是Objective-C中读写实例的变量的方法，一般由getter函数和setter函数组成。</p>
<p>在Objective-C中，每个类由一个<code>.h</code>头文件的头文件和一个<code>.m</code>的实现文件。其中，<code>.h</code>中是公开的API，<code>.m</code>中是私密API和具体的实现。</p>
<p>在<code>.h</code>中声明类时，必须给定类的父类，其中<code>NSObject</code>是几乎所有类的父类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.h</span><br><span class="line">@interface Test: NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>由于使用了<code>NSObject</code>作为父类，所以需要引入这个类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.h</span><br><span class="line">#import &lt;Foundation&#x2F;NSObject.h&gt;</span><br><span class="line">@interface Test: NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在IOS中一般不会只引进这个类，而是将整个<code>Foundation</code>框架引进来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">@interface Test: NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在<code>.m</code>实现文件中当然要引入头文件，<code>@implementation</code>表示类的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.m</span><br><span class="line">#import &quot;Test.h&quot;</span><br><span class="line">@implementation Test</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>同时<code>.m</code>中可以添加一些私密API</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.m</span><br><span class="line">#import &quot;Test.h&quot;</span><br><span class="line">@interface Test()&#x2F;&#x2F;添加私密API</span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">@implementation Test</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>下面介绍Objective-C的Properties概念，通过<code>@property</code>在<code>.h</code>中添加一个属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">@interface Test: NSObject</span><br><span class="line">  @property (strong nonatomic) NSString *name;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>下面详细说一下<code>property</code>这行代码的构成：</p>
<p><strong>首先</strong>是关键字<code>(strong)</code>。在Objective-C中，所有的对象都被放在堆中，通过指针使用它们。通过这种方式，Objective-C不需要编程人员手动分配和释放内存地址，那么Objective-C如何知道何时释放内存呢？这就是属性声明中<code>(stong)</code>的作用，相应的还有<code>(weak)</code>。在内存管理时，只要有任意一个<code>strong</code>指针指向内存，内存就会被保留，最有一个<code>strong</code>指针被删除时，该地址会<strong>立即</strong>被回收，此时如果还有<code>weak</code>指针指向改地址，<code>weak</code>指针会被置为空。</p>
<p>对于元类型（int、bool等）的属性，不需要声明<code>strong</code>或<code>weak</code>，因为这种类型的属性并不存储在堆中，不需要内存管理。</p>
<p>与其他语言不通，在Objective-C中，引用空指针并不会导致程序崩溃，在Objective-C中你甚至可以给空指针发送数据，也不会导致程序崩溃，当然你给空指针发数据，虽然不会导致程序崩溃，也不会执行任何代码，如果发送的消息需要返回，返回值会被设为0。</p>
<p><strong>然后</strong>是关键字<code>nonatomic</code>，非原子操作。这个关键字的意思是属性的getter和setter<strong>不是线程安全的</strong>，在IOS中一般并不需要属性是线程安全的。在声明属性的同时，Objective-C会自动创建getter和setter方法。如果添加了<code>nonatomic</code>关键字，自动生成的代码是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@synthesize name &#x3D; _name;</span><br><span class="line">- (NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">  return _name;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">  _name &#x3D; name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>@synthesize</code>表示<code>_name</code>是<code>name</code>的别名。这些代码并不会显示出来，但可以直接使用。使用setter和getter的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myTest.name &#x3D; @&quot;Hello World&quot;;</span><br><span class="line">NSLog(@&quot;%@&quot;,myTest.name);</span><br></pre></td></tr></table></figure>

<p>当然也可以用中括号的方式调用，但建议使用上面的方式调用setter和getter。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[myTest setName:@&quot;Hello World&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[myTest name]);</span><br></pre></td></tr></table></figure>

<p>如果不添加<code>nonatomic</code>关键字，自动生成的代码会复杂很多，因为需要添加锁。为了简单，一般都会加上<code>nonatomic</code>关键字。</p>
<p><strong>另外</strong>，如果想要重命名属性的getter和setter，可以通过一下方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, getter &#x3D; getName, setter &#x3D; setName) NSString name;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发入门</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C IOS开发之SQLite数据库</title>
    <url>/chinese/2021/03/10/Objective-C-IOS%E5%BC%80%E5%8F%91%E4%B9%8BSQLite%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>IDE: XCode Version 12.4 (12D4e)</p>
<p>参考<a href="https://www.tutorialspoint.com/ios/ios_sqlite_database.htm" target="_blank" rel="noopener">IOS开发教程</a></p>
<h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><a id="more"></a>

<ol>
<li><p>Xcode创建一个APP</p>
</li>
<li><p>选中项目文件，选中TARGETS，然后在框架（frameworks, Libraries, and Embedded Content）中添加<strong>libsqlite3.tbd</strong>（libsqlite3.0.tbd也一样）</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof54maa10j314p0u0af4.jpg" class="addSQLiteLibImg" width="500" height="600" title="添加SQLite库" alt="加载失败">
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof54tkttyj30ng0qon0f.jpg" class="addSQLiteLibImg2" width="500" height="300" title="添加SQLite库2" alt="加载失败">
</li>
<li><p>新建Objective-C类（File-&gt;New-&gt;File）选择Cocoa Touch Class，点击Next，Subclass of选择NSObject，language选Objective-C。</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof56z2pxuj30u00xm4ee.jpg" class="addObjcClassImg" width="800" height="300" title="添加Objective-C类" alt="加载失败">
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof57eshyqj315i0te0y6.jpg" class="addObjcClassImg2" width="400" height="300" title="添加Objective-C类2" alt="加载失败">
</li>
<li><p>将类的名字命名为DBManager，点击Next创建</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof57v7yg2j31600u0gpo.jpg" class="addDBManager" width="400" height="300" title="创建DBManager" alt="加载失败">
</li>
<li><p>项目中会增加<code>DBManager.h</code>和<code>DBManager.m</code>两个文件，其代码是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;DBManager.h</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#import &lt;sqlite3.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface DBManager : NSObject &#123;</span><br><span class="line">    NSString *databasePath;</span><br><span class="line">&#125;</span><br><span class="line">+(DBManager*)getSharedInstance;</span><br><span class="line">-(BOOL)createDB;</span><br><span class="line">-(BOOL) saveData:(NSString*)registerNumber name:(NSString*)name department:(NSString*)department year:(NSString*)year;</span><br><span class="line">-(NSArray*) findByRegisterNumber:(NSString*)registerNumber;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;DBManager.m</span><br><span class="line"></span><br><span class="line">#import &quot;DBManager.h&quot;</span><br><span class="line"></span><br><span class="line">static DBManager *sharedInstance &#x3D; nil;</span><br><span class="line">static sqlite3 *database &#x3D; nil;</span><br><span class="line">static sqlite3_stmt *statement&#x3D; nil;</span><br><span class="line"></span><br><span class="line">@implementation DBManager</span><br><span class="line"></span><br><span class="line">+(DBManager*)getSharedInstance&#123;</span><br><span class="line">    if(!sharedInstance) &#123;</span><br><span class="line">        sharedInstance &#x3D; [[super allocWithZone:NULL]init];</span><br><span class="line">        [sharedInstance createDB];</span><br><span class="line">    &#125;</span><br><span class="line">    return sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(BOOL)createDB &#123;</span><br><span class="line">    NSString *docsDir;</span><br><span class="line">    NSArray *dirPaths;</span><br><span class="line">    &#x2F;&#x2F; get the documents directory</span><br><span class="line">    dirPaths &#x3D; NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">    docsDir &#x3D; dirPaths[0];</span><br><span class="line">    &#x2F;&#x2F; build the path to the database file</span><br><span class="line">    databasePath &#x3D; [[NSString alloc] initWithString:[docsDir stringByAppendingPathComponent:@&quot;student.db&quot;]];</span><br><span class="line">    BOOL isSuccess &#x3D; YES;</span><br><span class="line">    NSFileManager* filemgr &#x3D; [NSFileManager defaultManager];</span><br><span class="line">    </span><br><span class="line">    if([filemgr fileExistsAtPath:databasePath] !&#x3D; NO) &#123;</span><br><span class="line">        const char *dbpath &#x3D; [databasePath UTF8String];</span><br><span class="line">        if(sqlite3_open(dbpath, &amp;database) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">            char *errMsg;</span><br><span class="line">            const char *sql_stmt &#x3D;</span><br><span class="line">            &quot;create table if not exists studentsDetail (regno integer primary key, name text, department text, year text)&quot;;</span><br><span class="line">            if(sqlite3_exec(database, sql_stmt, NULL, NULL, &amp;errMsg) !&#x3D; SQLITE_OK) &#123;</span><br><span class="line">                isSuccess &#x3D; NO;</span><br><span class="line">                NSLog(@&quot;Fail to create table&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sqlite3_close(database);</span><br><span class="line">            return isSuccess;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            isSuccess &#x3D; NO;</span><br><span class="line">            NSLog(@&quot;Fail to open&#x2F;create database&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return isSuccess;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(BOOL)saveData:(NSString *)registerNumber name:(NSString *)name department:(NSString *)department year:(NSString *)year; &#123;</span><br><span class="line">    const char *dbpath &#x3D; [databasePath UTF8String];</span><br><span class="line">    </span><br><span class="line">    if(sqlite3_open(dbpath, &amp;database) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">        NSString *insertSQL &#x3D; [NSString stringWithFormat:@&quot;insert into studentsDetail (regno, name, department, year) values (\&quot;%ld\&quot;,\&quot;%@\&quot;,\&quot;%@\&quot;,\&quot;%@\&quot;)&quot;,(long)[registerNumber integerValue], name, department, year];</span><br><span class="line">        const char *insert_stmt &#x3D; [insertSQL UTF8String];</span><br><span class="line">        if(sqlite3_prepare_v2(database, insert_stmt, -1, &amp;statement, NULL) !&#x3D; SQLITE_OK) &#123;</span><br><span class="line">            NSLog(@&quot;Prepare failure:%s&quot;,sqlite3_errmsg(database));</span><br><span class="line">        &#125;</span><br><span class="line">        if(sqlite3_step(statement) &#x3D;&#x3D; SQLITE_DONE) &#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    sqlite3_reset(statement);</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSArray*)findByRegisterNumber:(NSString *)registerNumber&#123;</span><br><span class="line">    const char *dbpath &#x3D; [databasePath UTF8String];</span><br><span class="line">    if(sqlite3_open(dbpath, &amp;database) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">        NSString *querySQL &#x3D; [NSString stringWithFormat:@&quot;select name, department, year from studentsDetail where regno &#x3D; \&quot;%@\&quot;&quot;,registerNumber];</span><br><span class="line">        const char *query_stmt &#x3D; [querySQL UTF8String];</span><br><span class="line">        NSMutableArray *resultArray &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">        if(sqlite3_prepare_v2(database, query_stmt, -1, &amp;statement, NULL) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">            if(sqlite3_step(statement) &#x3D;&#x3D; SQLITE_ROW) &#123;</span><br><span class="line">                NSString *name &#x3D; [[NSString alloc] initWithUTF8String:(const char *)sqlite3_column_text(statement, 0)];</span><br><span class="line">                [resultArray addObject:name];</span><br><span class="line">                </span><br><span class="line">                NSString *department &#x3D; [[NSString alloc] initWithUTF8String:(const char*)sqlite3_column_text(statement, 1)];</span><br><span class="line">                [resultArray addObject:department];</span><br><span class="line">                </span><br><span class="line">                NSString *year &#x3D; [[NSString alloc] initWithUTF8String:(const char*)sqlite3_column_text(statement, 2)];</span><br><span class="line">                [resultArray addObject:year];</span><br><span class="line">                return resultArray;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                NSLog(@&quot;Not found&quot;);</span><br><span class="line">                return nil;</span><br><span class="line">            &#125;</span><br><span class="line">            sqlite3_reset(statement);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>Main.storyboard</code>中添加如下组件：</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof3hvfqacj30ga0gsgma.jpg" class="result" width="800" height="300" title="效果" alt="加载失败">
</li>
<li><p>为所有的输入框新建<code>Referencing Outlet</code></p>
</li>
<li><p>为两个button创建<code>Touch Up Inside</code>事件</p>
</li>
<li><p>创建完之后，<code>ViewController.h</code>自动被填写为:</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line">#import &quot;DBManager.h&quot;&#x2F;&#x2F;这个是手动添加的</span><br><span class="line"></span><br><span class="line">@interface ViewController : UIViewController</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *findByRegisterNumberTextField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *regNoTextField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *nameTextField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *departmentTextField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *yearTextField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UIScrollView *myScrollView;</span><br><span class="line"></span><br><span class="line">- (IBAction)findData:(id)sender;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UIButton *saveData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>ViewController.m</code>中实现<code>findData</code>和<code>saveData</code></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  ViewController.m</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)saveData:(id)sender &#123;</span><br><span class="line">    BOOL success &#x3D; NO;</span><br><span class="line">    NSString *alertString &#x3D; @&quot;Data Insertion failed&quot;;</span><br><span class="line">    if(_regNoTextField.text.length &gt; 0 &amp;&amp; _nameTextField.text.length &gt; 0 &amp;&amp; _departmentTextField.text.length &gt; 0 &amp;&amp; _yearTextField.text.length &gt; 0) &#123;</span><br><span class="line">        success &#x3D; [[DBManager getSharedInstance] saveData:_regNoTextField.text name:_nameTextField.text department:_departmentTextField.text year:_yearTextField.text];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        alertString &#x3D; @&quot;Enter all fields&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if(success &#x3D;&#x3D; NO) &#123;</span><br><span class="line">        UIAlertController *alert &#x3D; [UIAlertController alertControllerWithTitle:alertString message:nil preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">        UIAlertAction *okAction &#x3D; [UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">            NSLog(@&quot;点击了OK&quot;);</span><br><span class="line">        &#125;];</span><br><span class="line">        [alert addAction:okAction];</span><br><span class="line">        [self presentViewController:alert animated:YES completion:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)findData:(id)sender &#123;</span><br><span class="line">    NSArray *data &#x3D; [[DBManager getSharedInstance] findByRegisterNumber:_findByRegisterNumberTextField.text];</span><br><span class="line">    if(data &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        UIAlertController *alert &#x3D; [UIAlertController alertControllerWithTitle:@&quot;Data not found&quot; message:nil preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">        UIAlertAction *okAction &#x3D; [UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        &#125;];</span><br><span class="line">        [alert addAction:okAction];</span><br><span class="line">        [self presentViewController:alert animated:YES completion:nil];</span><br><span class="line">        _regNoTextField.text &#x3D; @&quot;&quot;;</span><br><span class="line">        _nameTextField.text &#x3D;@&quot;&quot;;</span><br><span class="line">        _departmentTextField.text &#x3D; @&quot;&quot;;</span><br><span class="line">        _yearTextField.text &#x3D;@&quot;&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        _regNoTextField.text &#x3D; _findByRegisterNumberTextField.text;</span><br><span class="line">        _nameTextField.text &#x3D;[data objectAtIndex:0];</span><br><span class="line">        _departmentTextField.text &#x3D;[data objectAtIndex:1];;</span><br><span class="line">        _yearTextField.text &#x3D;[data objectAtIndex:2];;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mart - Text field delegate</span><br><span class="line">-(void)textFieldDidBeginEditing:(UITextField *)textField &#123;</span><br><span class="line">    [_myScrollView setFrame:CGRectMake(10,50,300,200)];</span><br><span class="line">    [_myScrollView setContentSize:CGSizeMake(300, 350)];</span><br><span class="line">&#125;</span><br><span class="line">-(void)textFieldDidEndEditing:(UITextField *)textField &#123;</span><br><span class="line">    [_myScrollView setFrame:CGRectMake(10, 50, 300, 350)];</span><br><span class="line">&#125;</span><br><span class="line">-(BOOL) textFieldShouldReturn:(UITextField *)textField &#123;</span><br><span class="line">    [textField resignFirstResponder];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>至此，可以通过save按钮保存数据，find按钮可以查找数据，并显示在各自输入框中</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li><p><code>libsqlite3.dylib</code>vs<code>libsqlite3.tbd</code>vs<code>libsqlite3.0.tbd</code></p>
<p><code>.tbd</code> 在Xcode7后替代了<code>.dylib</code> 。而<code>libsqlite3.tbd</code>只是<code>libsqlite3.0.tbd</code>的链接，也就是两者是一摸一样的，引入任意一个的效果都是一样的。</p>
</li>
<li><p>sqlite3的使用</p>
<ol>
<li><p>创建数据库</p>
<p>SQLite的数据库就是一个文件，创建数据库也就是创建一个文件。</p>
</li>
<li><p>打开数据库</p>
<p>打开数据库其实就是用<code>sqlite3_open</code>函数打开一个文件。</p>
</li>
<li><p>执行SQL命令</p>
<p>SQLite中执行SQL命令有两种方式：</p>
<ul>
<li><code>sqlite3_exec()</code></li>
<li><code>sqlite3_prepare_v2()</code>+<code>sqlite3_step()</code></li>
</ul>
<p>两者的区别可以看<a href="https://stackoverflow.com/questions/27383724/sqlite3-prepare-v2-sqlite3-exec" target="_blank" rel="noopener">stackoverflow</a>。</p>
</li>
</ol>
</li>
<li><p>弹出框的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIAlertController *alert &#x3D; [UIAlertController alertControllerWithTitle:@&quot;警告的Title&quot; message:@&quot;警告的消息&quot;</span><br><span class="line">                           preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line"></span><br><span class="line">UIAlertAction *okAction &#x3D; [UIAlertAction actionWithTitle:@&quot;OK&quot;</span><br><span class="line">                           style:UIAlertActionStyleDefault</span><br><span class="line">                           handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">                             NSLog(@&quot;点击了OK&quot;);</span><br><span class="line">                           &#125;];</span><br><span class="line">UIAlertAction *cancelAction &#x3D; [UIAlertAction actionWithTitle:@&quot;Cancel&quot;</span><br><span class="line">                               style:UIAlertActionStyleCancel</span><br><span class="line">                               handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">                                 NSLog(@&quot;点击了Cancel&quot;);</span><br><span class="line">                               &#125;];</span><br><span class="line">[alert addAction:okAction];</span><br><span class="line">[alertController addAction:cancelAction];</span><br><span class="line"></span><br><span class="line">[self presentViewController:alert animated:YES completion:nil];</span><br></pre></td></tr></table></figure>


</li>
</ol>
]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发入门</tag>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C IOS开发之HelloWorld</title>
    <url>/chinese/2021/03/09/Objective-C-IOS%E5%BC%80%E5%8F%91%E4%B9%8BHelloWorld/</url>
    <content><![CDATA[<p>IDE: XCode Version 12.4 (12D4e)</p>
<a id="more"></a>
<ol>
<li>新建App</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofu3u9dcoj314y0ten0w.jpg" alt="image-20210311120542111"></p>
<ol start="2">
<li>给项目命名为<code>HelloWorld</code>，Interface选择<code>Storyboard</code>，Language选择<code>Objective-C</code>。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofu4wmsj2j314u0t6424.jpg" alt="image-20210311120644241"></p>
<ol start="3">
<li>打开文件<code>Main.storyboard</code>，添加一个<code>Label</code>和<code>Button</code>组件。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofubs0rgnj31iw0u0e02.jpg" alt=""></li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofudvnpftj312u0u0tcs.jpg" alt="image-20210311121521358"></p>
<ol start="4">
<li>打开两个面板，一个显示<code>Main.storyboard</code>，另一个显示<code>ViewController.h</code><br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofugj8ui9j31iq0fsdk5.jpg" alt=""></li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofuiw4hgvj31hx0u07i1.jpg" alt=""></p>
<ol start="5">
<li><p>为Label新建<code>New Referencing Outlet</code>（右键点击Label，点击<code>New Referencing Outlet</code>后的点不松开，拖到<code>ViewController.h</code>中。将新的<code>Referencing Outlet</code>命名为<code>helloLabel</code>。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofukdlay3j31gt0u0h9a.jpg" alt=""></p>
</li>
<li><p>为Button添加<code>Touch Up Inside</code>事件，将事件命名为<code>showHelloWorld</code>。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gog2epczyxj30wg0u0h1n.jpg" alt=""><br>这时，<code>ViewController.h</code>的代码变为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  ViewController.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController : UIViewController</span><br><span class="line"></span><br><span class="line">@property (weak, nonatomic) IBOutlet UILabel *helloLabel;</span><br><span class="line">- (IBAction)showHelloWorld:(id)sender;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>同时，<code>ViewController.m</code>中也自动添加了<code>- (IBAction)showHelloWorld(id)sender {}</code>函数，在其中添加<code>_helloLabel.text = @&quot;Hello World&quot;;</code></p>
</li>
</ol>
<p>至此，最简单的IOS App开发完成。</p>
]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发入门</tag>
      </tags>
  </entry>
  <entry>
    <title>github pages + hexo + next + Travis CI实现免费个人博客</title>
    <url>/chinese/2021/03/08/github-pages-hexo-next-Travis-CI%E5%AE%9E%E7%8E%B0%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>是GitHub提供的静态网页托管工具，可以用来建立个人网页，也可以建立网页介绍某个项目。</p>
<p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>是一个博客框架，而<a href="https://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT</a>是Hexo的一个主题。</p>
<p>最后Travis CI是针对GitHub的一款持续集成工具，这里用来完成网站的自动化部署。</p>
<a id="more"></a>
<h1 id="GitHub-Pages设置"><a href="#GitHub-Pages设置" class="headerlink" title="GitHub Pages设置"></a>GitHub Pages设置</h1><p>GitHub Pages主页中有建站的简单教程，为了支持MarkDown撰写博客，选择使用博客框架Hexo，并选择一个比较流行的框架NexT。</p>
<p>在此基础上可以添加许多功能：</p>
<ol>
<li><p>置顶</p>
<ol>
<li>移除默认安装的插件<code>npm uninstall hexo-generator-index --save</code></li>
<li>安装新插件<code>npm install hexo-generator-index-pin-top --save</code></li>
<li>在需要置顶的文章头部<code>top: true</code>或<code>top:整数</code>，其中整数越大的文章越靠前</li>
<li>为置顶的文章添加置顶标签,在<code>/themes/next/layout/_macro/post.swig</code>文件的<code>&lt;div class=&quot;post-meta&quot;&gt;</code>下方，插入如下代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">&lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">&lt;font color&#x3D;7D26CD&gt;置顶&lt;&#x2F;font&gt;</span><br><span class="line">&lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>数学公式</p>
<ol>
<li>编辑<code>theme/next/_config.yml</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">enable:  true</span><br><span class="line">per_page: false</span><br><span class="line">cdn: &#x2F;&#x2F;cdn.bootcss.com&#x2F;mathjax&#x2F;2.7.1&#x2F;latest.js?config&#x3D;TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure></li>
<li>为了更好的性能，不选择在所有页面下支持数学公式。在需要支持matchjax的文章头部，添加<code>mathjax: true</code></li>
</ol>
</li>
<li><p>评论功能</p>
<ol>
<li>评论功能和阅读统计都可以使用LeanCloud</li>
<li>编辑<code>theme/next/_config.yml</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">    enable: true</span><br><span class="line">    appid:  xxxxxxxx</span><br><span class="line">    appkey:  yyyyyyyyyyy</span><br><span class="line">    notify: false # mail notifier , https:&#x2F;&#x2F;github.com&#x2F;xCss&#x2F;Valine&#x2F;wiki</span><br><span class="line">    verify: false # Verification code</span><br><span class="line">    placeholder: 评论 # comment box placeholder</span><br><span class="line">    avatar: mm # gravatar style</span><br><span class="line">    guest_info: nick,mail,link # custom comment header</span><br><span class="line">    pageSize: 10 # pagination size</span><br></pre></td></tr></table></figure>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocmlo8c9sj317k0o8myh.jpg" class="commentsImg" width="400" height="600" title="评论功能" alt="加载失败"></li>
</ol>
</li>
<li><p>阅读统计<br> <a href="https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">为NexT主题添加文章阅读量统计功能</a></p>
</li>
<li><p>字数统计</p>
<ol>
<li>编辑<code>theme/next/_config.yml</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_wordcount:</span><br><span class="line">item_text: true</span><br><span class="line">wordcount: true</span><br><span class="line">min2read: true</span><br><span class="line">totalcount: true</span><br><span class="line">separated_meta: true</span><br></pre></td></tr></table></figure></li>
<li>执行<code>npm install hexo-wordcount@2 --save</code>，安装需要的库<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocmhvhwsnj30cw01iwei.jpg" class="wordCountImg" width="200" height="30" title="字数统计" alt="加载失败"></li>
</ol>
</li>
<li><p>添加网易云播放器</p>
<ol>
<li>去网易云音乐找一首喜欢的歌。</li>
<li>点击“生成外链播放器”，复制HTML代码。</li>
<li>将HTML代码添加到<code>/themes/hexo-theme-next/layout/_macro/sidebar.swig</code>中<code>&lt;aside id=&quot;sidebar&quot; class=&quot;sidebar”&gt;</code>后面，并用<code>&lt;div&gt;</code>包裹。<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocm3k2n6uj30ia0lujua.jpg" class="musicImg" width="400" height="200" title="网易云音乐" alt="加载失败"></li>
</ol>
</li>
<li><p>将标签云改为彩色</p>
<ol>
<li>在<code>themes/next/layout/</code>中新建<code>tag-color.swig</code>文件，代码为： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">     var alltags &#x3D; document.getElementsByClassName(&#39;tag-cloud-tags&#39;);</span><br><span class="line">     var tags &#x3D; alltags[0].getElementsByTagName(&#39;a&#39;);</span><br><span class="line">     for (var i &#x3D; tags.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">       var r&#x3D;Math.floor(Math.random()*75+130);</span><br><span class="line">       var g&#x3D;Math.floor(Math.random()*75+100);</span><br><span class="line">       var b&#x3D;Math.floor(Math.random()*75+80);</span><br><span class="line">       tags[i].style.background &#x3D; &quot;rgb(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .tag-cloud-tags&#123;</span><br><span class="line">    &#x2F;*font-family: Helvetica, Tahoma, Arial;*&#x2F;</span><br><span class="line">    &#x2F;*font-weight: 100;*&#x2F;</span><br><span class="line">    text-align: center;</span><br><span class="line">    counter-reset: tags;</span><br><span class="line">  &#125;</span><br><span class="line">  .tag-cloud-tags a&#123;</span><br><span class="line">    border-radius: 6px;</span><br><span class="line">    padding-right: 5px;</span><br><span class="line">    padding-left: 5px;</span><br><span class="line">    margin: 8px 5px 0px 0px;</span><br><span class="line">  &#125;</span><br><span class="line">  .tag-cloud-tags a:before&#123;</span><br><span class="line">    content: &quot;?&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .tag-cloud-tags a:hover&#123;</span><br><span class="line">     box-shadow: 0px 5px 15px 0px rgba(0,0,0,.4);</span><br><span class="line">     transform: scale(1.1);</span><br><span class="line">     &#x2F;*box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);*&#x2F;</span><br><span class="line">     transition-duration: 0.15s;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></li>
<li>在<code>/themes/next/layout/page.swig</code>中引入<code>tag-color.swig</code>，即在<code>&lt;div class=&quot;tag-cloud&quot;&gt;</code>代码段下方添加<code>{ % include &#39;tag-color.swig&#39; % }</code></li>
<li>也可以将标签云直接加入主页，在<code>/themes/next/layout/index.swig</code>中的block content代码块中加入以下代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;tag-cloud&quot;&gt;</span><br><span class="line">	  &lt;div class&#x3D;&quot;tag-cloud-tags&quot; id&#x3D;&quot;tags&quot;&gt;</span><br><span class="line">		&#123;&#123; tagcloud(&#123;min_font: 16, max_font: 16, amount: 300, color: true, start_color: &#39;#fff&#39;, end_color: &#39;#fff&#39;&#125;) &#125;&#125;</span><br><span class="line">	  &lt;&#x2F;div&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;br&gt;</span><br><span class="line">	</span><br><span class="line">	&#123;% include &#39;tag-color.swig&#39; %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>展示近期文章</p>
<ol>
<li><p>修改<code>themes/next/layout/_macro/sidebar.swig</code> 。找到<code>theme.social</code>，在该板块后隔一行添加如下代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;# recent posts #&#125;</span><br><span class="line">&#123;% if theme.recent_posts %&#125;</span><br><span class="line">&lt;div class&#x3D;&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme.recent_posts_layout  &#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;links-of-blogroll-title&quot;&gt;</span><br><span class="line">        &lt;!-- modify icon to fire by szw --&gt;</span><br><span class="line">        &lt;i class&#x3D;&quot;fa fa-history fa-&#123;&#123; theme.recent_posts_icon | lower &#125;&#125;&quot; aria-hidden&#x3D;&quot;true&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">        &#123;&#123; theme.recent_posts_title &#125;&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;ul class&#x3D;&quot;links-of-blogroll-list&quot;&gt;</span><br><span class="line">        &#123;% set posts &#x3D; site.posts.sort(&#39;-date&#39;) %&#125;</span><br><span class="line">        &#123;% for post in posts.slice(&#39;0&#39;, &#39;5&#39;) %&#125;</span><br><span class="line">        &lt;li class&#x3D;&quot;recent_posts_li&quot;&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title&#x3D;&quot;&#123;&#123; post.title &#125;&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">         &lt;&#x2F;li&gt;</span><br><span class="line">         &#123;% endfor %&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编辑<code>themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">li.recent_posts_li &#123;</span><br><span class="line">    text-align: cengter;</span><br><span class="line">    display: block;</span><br><span class="line">    word-break: keep-all;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>themes/next/_config.yml</code>中添加下方代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 近期文章设置</span><br><span class="line">recent_posts_title: 近期文章</span><br><span class="line">recent_posts_layout: block</span><br><span class="line">recent_posts: true</span><br></pre></td></tr></table></figure>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocmksvxlvj30da0460su.jpg" class="rencentPostImg" width="200" height="100" title="近期文章" alt="加载失败">

</li>
</ol>
</li>
</ol>
<h1 id="Travis-CI自动部署GitHub-Pages"><a href="#Travis-CI自动部署GitHub-Pages" class="headerlink" title="Travis CI自动部署GitHub Pages"></a>Travis CI自动部署GitHub Pages</h1><p><a href="https://docs.travis-ci.com/user/deployment/pages/" target="_blank" rel="noopener">Travis官方教程</a><br>有了Travis CI，更换电脑时，不需要在本地配置完整的环境，可以直接修改md文件，push到github后，Travis CI会自动生成和部署，非常的方便。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo: false</span><br><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - 10 # use nodejs v10 LTS</span><br><span class="line">before_script: # 配置环境</span><br><span class="line">    - npm install hexo-generator-searchdb --save # 用于支持本地搜索功能</span><br><span class="line">    - npm uninstall hexo-generator-index --save </span><br><span class="line">    - npm install hexo-generator-index-pin-top --save # 这两行用于支持置顶功能</span><br><span class="line">    - npm install --save hexo-filter-flowchart # 用于支持markdown中的流程图功能</span><br><span class="line">    - npm install hexo-wordcount@2 --save #用于支持字数统计功能</span><br><span class="line">cache: npm</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - master # build master branch only</span><br><span class="line">script:</span><br><span class="line">  - hexo generate # generate static files</span><br><span class="line">deploy:</span><br><span class="line">  provider: pages</span><br><span class="line">  skip-cleanup: true</span><br><span class="line">  github-token: $GH_TOKEN</span><br><span class="line">  keep-history: true</span><br><span class="line">  on:</span><br><span class="line">    branch: master</span><br><span class="line">  local-dir: public</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">notifications:</span><br><span class="line">   email:</span><br><span class="line">     recipients:</span><br><span class="line">       - xxx@xxx.com</span><br><span class="line">         #-</span><br><span class="line">     on_success: never # default: change</span><br><span class="line">     #on_success: change # default: change</span><br><span class="line">     on_failure: always # default: always</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>自媒体</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>GitHub Pages</tag>
        <tag>Travis</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币和区块链的运行原理</title>
    <url>/chinese/2019/11/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%92%8C%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>比特币和区块链技术出现很久了，大家或多或少都有耳闻。不管是对比特币暴涨的羡慕，还是对背后技术的科普。笔者也是一样多少看过一些相关资料，但最近读区块链支付领域的顶会<sup><a href="#foot_note_1">[1]</a></sup>论文<sup><a href="#foot_note_2">[2]</a></sup>时还是发现自己对技术细节了解太少，甚至存在一些误解。</p>
<p>本文会介绍一些比特区块链的技术细节，同时尽力使其容易理解。</p>
<a id="more"></a>

<h2 id="比特币-bitcoin"><a href="#比特币-bitcoin" class="headerlink" title="比特币 bitcoin"></a>比特币 bitcoin</h2><p>所谓的比特币其实是<strong>交易</strong>组成的链。每个<strong>交易</strong>中包含大概信息就是<strong><em>谁把这个比特币转账给了谁，并且由转出比特币的人签字画押（数字签名<sup><a href="#foot_note_3">[3]</a></sup>）</em></strong>，具体来说如<a href="#pic_1">图1</a>，每个交易中包含</p>
<ul>
<li>收到比特币的人的公钥</li>
<li>由<strong>上一个交易</strong>和<strong>收到比特币的人的公钥</strong>组成的数据的哈希</li>
<li><strong>转出比特币的人的数字签名</strong>。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g91yo948kjj30lw0crab5.jpg" alt=""></p>
<center><span id="pic_1"><sub>图1： 交易链</sub></span></center>

<p>这样做的话，应该收到比特币的人就可以验证转出比特币的人是不是真的拥有这个比特币。方法就是用<strong>上一个</strong>交易中所有者的公钥去验证<strong>这次</strong>交易中的数字签名，这样就能知道这个比特币上一次被转账给了这次的转出者。</p>
<p>这里有个问题是转出比特币的人可能将同一个比特币转账给多个人，这样上面的交易链就会分叉。然而其实只有最早的那次转账是有效的，后面的转账都是非法的。为了验证交易是不是最早的一次转账，就需要一个<strong>公认的顺序</strong>。传统的方法是由中心节点指定一个顺序，大家被动接受。而比特币是通过多数人同意来认定一个顺序是不是<strong>公认</strong>的，这似乎也更符合<strong>公认</strong>这个词的含义。想要让（比特币系统所有参与者中的）多数人<strong>公认</strong>一个顺序，需要：</p>
<ul>
<li>向所有参与者广播所有的交易</li>
<li>多数参与者同意一个顺序</li>
</ul>
<p>在每次交易时，交易的接收者需要证明多数节点同意这次交易是最先收到的交易，这样接收者就能安心的完成交易了。</p>
<p><strong><em>区块链的主要任务就是达成这样的一个公认的顺序</em></strong>。</p>
<h2 id="区块链-blockchain"><a href="#区块链-blockchain" class="headerlink" title="区块链 blockchain"></a>区块链 blockchain</h2><p>区块链的基础是<strong>时间戳服务器</strong>，如<a href="#pic_2">图2</a>。</p>
<h3 id="时间戳服务器"><a href="#时间戳服务器" class="headerlink" title="时间戳服务器"></a>时间戳服务器</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g926rnfzp5j30om07gq38.jpg" alt=""></p>
<center><span id="pic_2"><sub>图2： 时间戳服务器</sub></span></center>

<blockquote>
<p>时间戳服务器计算包含多个需要被打时间戳的数据项的区块的哈希值并广泛地发布这个哈希值。时间戳能证明要得到这个哈希值，显然这些数据当时一定是存在的。每个时间戳的哈希值都纳入了上一个时间戳，形成一条链，后面的时间戳进一步增强前一个时间戳。</p>
<p><em>Bitcoin: A Peer-to-Peer Electronic Cash System<sup><a href="#foot_note_4">[4]</a></sup></em></p>
</blockquote>
<p>系统参与者通过在某个时间戳之后计算哈希来表示对某个顺序的认同，这样最长的链就是最多人认同的链，也就是我们想要的公认的顺序。</p>
<p>如果某个恶意参与者想要修改链中某个区块的内容，那必须把这个区块之后的哈希全部重算一遍，并且快速计算使自己这条链成为最长的，在所有人之前将最新哈希广播出去。这看上去是个比较难的任务，但并非不可完成，只要有足够快的计算机就可能做到。<strong>解决方法就是为计算哈希增加难度</strong>。</p>
<h3 id="工作量证明-Proof-of-Work"><a href="#工作量证明-Proof-of-Work" class="headerlink" title="工作量证明 Proof-of-Work"></a>工作量证明 Proof-of-Work</h3><p><a href="#pic_3">图3</a>是区块链中区块的内容：</p>
<ul>
<li>上一个区块的哈希</li>
<li>上面提到的比特币交易</li>
<li>一个随机数（这个随机数是用来调整计算哈希的难度的，也是工作量证明的关键）</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9281qoyhej30ow06smxl.jpg" alt=""></p>
<center><span id="pic_3"><sub>图3： 区块链</sub></span></center>

<blockquote>
<p>工作量证明采取搜索一个随机数，使得被哈希时，如使用 SHA-256，得到的哈希值以数个 0 比特开始。平均所需工作 量将随所需 0 比特呈指数级增长而验证却只需执行一次哈希。</p>
<p><em>Bitcoin: A Peer-to-Peer Electronic Cash System<sup><a href="#foot_note_4">[4]</a></sup></em></p>
</blockquote>
<p>比特币运行的步骤：</p>
<blockquote>
<ol>
<li>向所有节点广播<strong>新交易</strong></li>
<li>区块链节点将收集的新交易组成一个区块（如<a href="#pic_3">图3</a>）</li>
<li>计算满足要求（<em>工作量证明</em>）的哈希，既得到某个随机数</li>
<li>将这个区块（包含了满足要求的随机数）广播</li>
<li>其他节点确认区块中所有交易都没有被支付过，而且区块确实能够计算出满足要求的哈希</li>
<li>节点通过在这个区块之上继续计算表示对这个区块的接受</li>
</ol>
</blockquote>
<p>这样计算哈希的难度大大增加，恶意节点想要赶上并超过其他所有节点计算哈希的速度，就必须拥有巨量的计算力，而如果拥有这样的计算力，用作正常贡献获得的激励会超过作恶，这样就从动机上消除了作恶。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><span id="foot_note_1"><sub>[1]: SOSP</sub></span><br><span id="foot_note_2"><sub>[2]: Lind, J., Naor, O., Eyal, I., Kelbert, F., Sirer, E. G., &amp; Pietzuch, P. (2019, October). Teechain: a secure payment network with asynchronous blockchain access. In <em>Proceedings of the 27th ACM Symposium on Operating Systems Principles</em> (pp. 63-79). ACM.</sub></span></p>
<p><span id="foot_note_3"><sub>[3]: 可以通过我另一片博客了解：<a href="[https://zhang-tianxu.github.io/chinese/2019/11/15/%E7%94%A8%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E8%A7%A3%E9%87%8ARSA%E5%8E%9F%E7%90%86/](https://zhang-tianxu.github.io/chinese/2019/11/15/用一个例子解释RSA原理/)">《用一个例子解释RSA原理》</a></sub></span></p>
<p><span id="foot_note_4"><sub>[4]: Bitcoin: A Peer-to-Peer Electronic Cash System. Satoshi Nakamoto.<a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener">https://bitcoin.org/bitcoin.pdf</a></sub></span></p>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>安全</category>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>bitcoin</tag>
        <tag>blockchain</tag>
        <tag>比特币</tag>
        <tag>区块链</tag>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title>C与Python中的socket</title>
    <url>/chinese/2019/11/15/C%E4%B8%8EPython%E4%B8%AD%E7%9A%84socket/</url>
    <content><![CDATA[<h1 id="C与Python中的socket"><a href="#C与Python中的socket" class="headerlink" title="C与Python中的socket"></a>C与Python中的socket</h1><p>本文主要是想实现一下C与Python的socket通信，顺便说一下两者各自的socket编程。所以全篇结构如下：</p>
<ul>
<li>C中的socket</li>
<li>Python中的socket</li>
<li>C与Python的socket通信</li>
</ul>
<a id="more"></a>

<h2 id="C-中的socket"><a href="#C-中的socket" class="headerlink" title="C 中的socket"></a>C 中的socket</h2><p>这部分主要参考《UNIX环境高级编程（第3版）》</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOST <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 65432</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG <span class="meta-string">"Hello FROM C Server"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_fd;</span><br><span class="line">    <span class="keyword">int</span> client_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[BUFF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">local_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">remote_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;local_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(local_addr)); <span class="comment">//清零local_addr</span></span><br><span class="line">    local_addr.sin_family = AF_INET;</span><br><span class="line">    local_addr.sin_addr.s_addr = inet_addr(HOST);</span><br><span class="line">    local_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((server_fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span> ) <span class="comment">// 新建socket</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((bind(server_fd, (struct sockaddr *)&amp;local_addr, <span class="keyword">sizeof</span>(struct sockaddr))) &lt; <span class="number">0</span>) <span class="comment">// 绑定socket</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    listen(server_fd, <span class="number">10</span>); <span class="comment">// 监听socket</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sin_size = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">        <span class="keyword">if</span>( (client_fd = accept(server_fd, (struct sockaddr *)&amp;remote_addr, &amp;sin_size )) &lt;<span class="number">0</span> ) <span class="comment">// 接受client的链接请求</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"accept:"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">pid_t</span> handle_pid;</span><br><span class="line">        handle_pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(handle_pid == <span class="number">0</span>) <span class="comment">// 子进程处理请求</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(close(server_fd) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"close:"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> len = send(client_fd, MSG, <span class="keyword">sizeof</span>(MSG),<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"len = %d\n"</span>,len);</span><br><span class="line">            <span class="keyword">if</span>(len != <span class="keyword">sizeof</span>(MSG))</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"send:"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(close(client_fd) &lt; <span class="number">0</span>) <span class="comment">// 父进程关闭client的socket，继续监听。</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"close:"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(close(client_fd) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"close:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOST <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 65432</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFF_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(HOST);</span><br><span class="line">    server_addr.sin_port = htons(PORT);</span><br><span class="line">    <span class="keyword">if</span>((server_fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span> ) <span class="comment">// 新建socket</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((connect(server_fd, (struct sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(struct sockaddr)) &lt; <span class="number">0</span>) ) <span class="comment">// 连接server</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"connect:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = recv(server_fd, buf, BUFF_SIZE, <span class="number">0</span>); <span class="comment">//连接成功后接收信息</span></span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">        len = recv(server_fd, buf, BUFF_SIZE, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(server_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Python-中的socket"><a href="#Python-中的socket" class="headerlink" title="Python 中的socket"></a>Python 中的socket</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#server.py</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">65432</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">  s.bind((HOST, PORT))</span><br><span class="line">  s.listen(<span class="number">5</span>)</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, addr = s.accept()</span><br><span class="line">    <span class="keyword">with</span> conn:</span><br><span class="line">      conn.send(<span class="string">b"Hello From Python Server!"</span>)</span><br><span class="line">      conn.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#client.py</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">65432</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">  s.connect((HOST, PORT))</span><br><span class="line">  msg_part = s.recv(<span class="number">10</span>)</span><br><span class="line">  msg = msg_part</span><br><span class="line">  <span class="keyword">while</span> len(msg_parg) == <span class="number">10</span>:</span><br><span class="line">    msg += msg_parg</span><br><span class="line">    msg_parg = s.recv(<span class="number">10</span>)</span><br><span class="line">  msg += msg_part</span><br><span class="line">  print(msg)</span><br></pre></td></tr></table></figure>



<h2 id="C与Python的socket通信"><a href="#C与Python的socket通信" class="headerlink" title="C与Python的socket通信"></a>C与Python的socket通信</h2><p>C和Python通过套接字是可以直接通信的。需要注意的是消息的格式。socket传输的内容是byte流，C中可以使用强制类型转换，Python中则需要<code>pack()</code>与<code>unpack()</code>。</p>
<p>比如：</p>
<p>在C写的server端发送：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> msg = htonl(<span class="number">999</span>);</span><br><span class="line">send(client_fd, (<span class="keyword">const</span> <span class="keyword">void</span> *)&amp;msg, <span class="keyword">sizeof</span>(msg),<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>Python端接收：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> *</span><br><span class="line">(msg,) = unpack(<span class="string">'&gt;1I'</span>,socket.socket.recv(<span class="number">4</span>))</span><br><span class="line">print(msg)</span><br></pre></td></tr></table></figure>

<p><code>unpack()</code>的第一个参数表示格式，<code>&gt;1I</code>中的<code>&gt;</code>表示大端（相应的<code>&lt;</code>就表示小端），<code>1I</code>表示一个整数。</p>
<p><code>pack()</code>与<code>unpack()</code>的详细操作见<em>博主 *</em>三月沙** 的《<a href="https://sanyuesha.com/2018/03/10/why-pack-unpack/" target="_blank" rel="noopener">Python 中的 pack 和 unpack</a>》*。</p>
<hr>
<p>反过来也是一样：</p>
<p>在Python写的server中发送</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conn.send(pack(<span class="string">'&gt;I'</span>,<span class="number">999</span>))</span><br></pre></td></tr></table></figure>

<p>C写的client中接收：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> msg;</span><br><span class="line"><span class="keyword">int</span> len = recv(server_fd, (<span class="keyword">int</span> *)&amp;msg, <span class="keyword">sizeof</span>(<span class="keyword">int</span>),<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ntohl(*msg));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>专业学习</category>
        <category>后端</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>C</tag>
        <tag>socket</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 53 Maximum SubArray</title>
    <url>/chinese/2019/02/26/leetcode-53-Maximum-SubArray/</url>
    <content><![CDATA[<h1 id="leetcode-53-Maximum-Subarray"><a href="#leetcode-53-Maximum-Subarray" class="headerlink" title="leetcode 53 Maximum Subarray"></a>leetcode 53 Maximum Subarray</h1><p><strong>最大子序列和</strong>问题是用于讲解<strong>分治策略</strong>的一个经典例题，这个例题可以帮助我们很好的理解分治策略。但对于这个问题，分治策略并不是最高效的算法。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个整数数组 <code>nums</code> ，找到<strong>其中一个</strong>具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],</p>
<p>输出: 6</p>
<p>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
</blockquote>
<a id="more"></a>

<h2 id="解体思路"><a href="#解体思路" class="headerlink" title="解体思路"></a>解体思路</h2><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>暴力法的思路很简单，就是尝试所有可能的子序列起始点，根据排列组合知识很容易知道一共有$A^2_n = n \times (n - 1)$种可能。遍历所有可能并找出最大和，时间复杂度为$\Theta(n^2)$。</p>
<h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>分治策略的思想就是递归的解决一个问题，《算法导论》中给出了分治策略的三个步骤：</p>
<ol>
<li>分解（Divide）：<br>将原问题划分为一些子问题，这些子问题和原问题一样，只不过规模更下。</li>
<li>解决（Conquer）：<br>递归地解决这些子问题，如果子问题的规模足够小，就停止递归，直接求解。</li>
<li>合并（Combine）：<br>将子问题的解合并为原问题的解。</li>
</ol>
<p><strong>最大子序列和</strong>问题的分治策略也可以对应上面三步：</p>
<ol>
<li><p>分解：<br>将整个数组划分为左右两个子数组，分别求两个子数组的最大子序列和。这样两个子问题和原问题一样，规模变为原来一半。</p>
</li>
<li><p>解决：<br>递归地分解数组，知道数组中只有一个元素时，可以直接把这个元素作为最大子序列和，返回给上一层。</p>
</li>
<li><p>合并：<br>合并过程是这个问题的<strong>关键</strong>。在分解步骤中你可能已经发现，两个子数组的最大子序列和中较大的那个并不一定就是原问题的最大子序列和。这是因为在划分数组的时候将两个子数组完全隔开了，而最大子序列可能会跨越两个子数组，所以要考虑这种情况。<br>所以原问题的最大子序列和一共有<strong>三种</strong>可能的情况：</p>
<ol>
<li>完全在左边子数组中</li>
<li>完全在右边子数组中</li>
<li>跨越左右两个子数组</li>
</ol>
<p>上面两种情况只需要递归的解决就可以，而第3种情况需要仔细考虑，想要找出跨越两个数组的最大子序列和需要遍历整个数组，所以这一过程的时间复杂度是$\Theta(n)$。那么可以得出分治策略解决该问题的运行时间：</p>
</li>
</ol>
<p>$$<br>T(n) =<br>\begin{cases}<br>\Theta(1)&amp;if\ \ n\ =\ 1 \<br>2T(\frac{n}{2}) + \Theta(n)&amp;if\ \ n\  &gt; \ 1<br>\end{cases}<br>$$</p>
<p>用<strong>主方法</strong>解此递归式得时间复杂度为$\Theta(nlog_2n)$。</p>
<h3 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h3><p>这个问题最重要的是理解分治策略，理解了分治策略后我们可以进一步优化时间复杂度。实际上我们可以在一次遍历内找出最大子序列和。</p>
<p>从头开始遍历时，每加入一个元素我们都可以比较加入和不加入两种情况下哪一个和更大，这样就会得到这一步的最大子序列和。然后用一个变量保存全局最大子序列和，就能得到我们想要的值。这其实有点类似动态规划。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="暴力法-1"><a href="#暴力法-1" class="headerlink" title="暴力法"></a>暴力法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_p</span><span class="params">(nums: List[int], s: int, e: int)</span> -&gt; int:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(s,e+<span class="number">1</span>):</span><br><span class="line">       sum += nums[i]</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        max_subarray_sum = float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i,len(nums)):</span><br><span class="line">                <span class="keyword">if</span> sum_p(nums,i,j) &gt; max_subarray_sum:</span><br><span class="line">                    max_subarray_sum = sum_p(nums,i,j)</span><br><span class="line">        <span class="keyword">return</span> max_subarray_sum</span><br></pre></td></tr></table></figure>

<p>leetcode美国版超时。国内版96ms，击败9.45%。</p>
<h3 id="分治法-1"><a href="#分治法-1" class="headerlink" title="分治法"></a>分治法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_cross_subarray</span><span class="params">(nums: List[int],s: int, m: int, e: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># 求解跨越子数组的情况</span></span><br><span class="line">    left_sum = <span class="number">0</span></span><br><span class="line">    left_max_sum = float(<span class="string">'-inf'</span>)</span><br><span class="line">    print(left_max_sum)</span><br><span class="line">    left_i = left_max_i = m</span><br><span class="line">    <span class="keyword">while</span> left_i &gt;= s:</span><br><span class="line">        left_sum += nums[left_i]</span><br><span class="line">        <span class="keyword">if</span> left_sum &gt; left_max_sum:</span><br><span class="line">            left_max_sum = left_sum</span><br><span class="line">            left_max_i = left_i</span><br><span class="line">        left_i -= <span class="number">1</span></span><br><span class="line">    right_sum = <span class="number">0</span></span><br><span class="line">    right_max_sum = float(<span class="string">'-inf'</span>)</span><br><span class="line">    right_i = right_max_i = m + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> right_i &lt;= e:</span><br><span class="line">        right_sum += nums[right_i]</span><br><span class="line">        <span class="keyword">if</span> right_sum &gt; right_max_sum:</span><br><span class="line">            right_max_sum = right_sum</span><br><span class="line">            right_max_i = right_i</span><br><span class="line">        right_i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> left_max_sum + right_max_sum</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray2</span><span class="params">(nums: List[int],s: int, e:int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> s == e:</span><br><span class="line">        <span class="keyword">return</span> nums[s]</span><br><span class="line">    m = (s + e) // <span class="number">2</span></span><br><span class="line">    maxnum1 = maxSubArray2(nums,s,m)</span><br><span class="line">    maxnum2 = maxSubArray2(nums,m+<span class="number">1</span>,e)</span><br><span class="line">    maxnum3 = max_cross_subarray(nums,s,m,e)</span><br><span class="line">    <span class="keyword">return</span> max(maxnum1,maxnum2,maxnum3)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> maxSubArray2(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>leetcode用时：124ms，击败5.41%。</p>
<h3 id="一次遍历-1"><a href="#一次遍历-1" class="headerlink" title="一次遍历"></a>一次遍历</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        local_max = nums[<span class="number">0</span>]</span><br><span class="line">        global_max = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            local_max = max(local_max + nums[i],nums[i])</span><br><span class="line">            <span class="keyword">if</span> local_max &gt; global_max:</span><br><span class="line">                global_max = local_max</span><br><span class="line">        <span class="keyword">return</span> global_max</span><br></pre></td></tr></table></figure>

<p>leetcode用时：48ms，击败66.85%。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Leetcode国际版：<a href="https://leetcode.com/" target="_blank" rel="noopener">https://leetcode.com/</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>领扣</tag>
        <tag>easy</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 56 Merge Intervals</title>
    <url>/chinese/2019/02/13/leetcode-56-Merge-Intervals/</url>
    <content><![CDATA[<h1 id="leetcode-56-区间合并——Merge-Intervals"><a href="#leetcode-56-区间合并——Merge-Intervals" class="headerlink" title="leetcode 56 区间合并——Merge Intervals"></a>leetcode 56 区间合并——Merge Intervals</h1><p>排序算法有很多应用，区间排序就是一种典型的应用。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一组区间，合并所有重叠的区间。</p>
<p>例子1：</p>
<blockquote>
<p>输入：[[1,3],[2,6],[8,10],[15,18]]</p>
<p>输出：[[1,6],[8,10],[15,18]]</p>
</blockquote>
<p>例子2：</p>
<blockquote>
<p>输入：[[1,4],[4,5]]</p>
<p>输出：[[1,5]]</p>
</blockquote>
<a id="more"></a>

<h2 id="解体思路"><a href="#解体思路" class="headerlink" title="解体思路"></a>解体思路</h2><p>按照区间的起始点对区间进行排序，那么可以合并的区间一定是相邻的。</p>
<p>算法步骤如下：</p>
<ol>
<li>将给定的一组区间<strong>按照起始点进行排序</strong>。</li>
<li>设置<em>new_start</em>和<em>new_end</em>两个变量来存储即将插入结果队列的区间起始点和终点，从左往右开始遍历排好序的区间。</li>
<li>如果当前区间和下一个区间有重叠，更新<em>new_end</em>，<strong>注意新的值一定要大于当前<em>new_end</em></strong>。</li>
<li>如果当前区间和下一个区间没有重叠，将<em>new_start</em>和<em>new_end</em>作为起始点和终点的区间插入结果。</li>
</ol>
<ul>
<li>时间复杂度<br>对序列排序的时间复杂度是$\Theta(n \times log_2{n})$，而对序列遍历的时间复杂度是$\Theta(n)$。所以整个算法的时间复杂度是$\Theta(n \times log_2{n})$。</li>
<li>空间复杂度<br>空间复杂度和排序算法有关。比如<strong>空间复杂度</strong>是$\Theta(1)$，而合并排序的时间复杂度是$\Theta(n)$。</li>
</ul>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>我一开始的实现不够简洁，逻辑虽然简单，但是代码看上去很臃肿。具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="comment"># class Interval:</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: <span class="string">'List[Interval]'</span>)</span> -&gt; 'List[Interval]':</span></span><br><span class="line">        sorted_int = sorted(intervals,key=<span class="keyword">lambda</span> x:x.start) <span class="comment">#sort intervals by start</span></span><br><span class="line">        </span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        length = len(sorted_int)</span><br><span class="line">        <span class="keyword">if</span> length &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        new_start = sorted_int[<span class="number">0</span>].start</span><br><span class="line">        new_end = sorted_int[<span class="number">0</span>].end</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; length):</span><br><span class="line">            <span class="keyword">if</span> new_end &gt;= sorted_int[i].start:</span><br><span class="line">                new_end = max(sorted_int[i].end,new_end)</span><br><span class="line">                i = i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = Interval(new_start,new_end)</span><br><span class="line">                result.append(tmp)</span><br><span class="line">                new_start = sorted_int[i].start</span><br><span class="line">                new_end = sorted_int[i].end</span><br><span class="line">                </span><br><span class="line">        tmp = Interval(new_start,new_end)//处理最后一个区间</span><br><span class="line">        result.append(tmp)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p><strong>leetcode用时：60ms，排名85.63%。</strong></p>
<p>在看过大神的代码后学到了一个<strong>技巧</strong>，就是对<strong>访问列表是对负数的应用</strong>。例如<code>list[-1]</code>表示访问列表的最后一个元素，这个技巧在这个题目中可以使得代码变得简洁。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="comment"># class Interval:</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: <span class="string">'List[Interval]'</span>)</span> -&gt; 'List[Interval]':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        sorted_int = sorted(intervals,key=<span class="keyword">lambda</span> x:x.start) <span class="comment">#sort intervals by start</span></span><br><span class="line">        </span><br><span class="line">        result = [sorted_int[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(sorted_int)):</span><br><span class="line">            <span class="keyword">if</span> result[<span class="number">-1</span>].end &gt;= sorted_int[i].start:</span><br><span class="line">                <span class="keyword">if</span>(result[<span class="number">-1</span>].end &lt; sorted_int[i].end):</span><br><span class="line">                    result[<span class="number">-1</span>].end = sorted_int[i].end</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(sorted_int[i])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p><strong>leetcode用时：56ms，排名99.24%。</strong></p>
<p>这个实现相比于第一个实现不仅变得简洁，而且<strong>省去了新建区间的过程</strong>，直接利用已有区间，这样省下了一定的时间，时间性能排名上升。</p>
<h2 id="超慢实现"><a href="#超慢实现" class="headerlink" title="超慢实现"></a>超慢实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="comment"># class Interval:</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type intervals: List[Interval]</span></span><br><span class="line"><span class="string">        :rtype: List[Interval]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> i: i.start)</span><br><span class="line">        temp = intervals[<span class="number">0</span>]</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(intervals[:]):<span class="comment">#在循环中使用len()函数，非常影响性能</span></span><br><span class="line">            next = intervals[i]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> temp.end &lt; next.start:</span><br><span class="line">                res.append(temp)</span><br><span class="line">                temp = next</span><br><span class="line">            <span class="keyword">elif</span> temp.end &gt;= next.start:</span><br><span class="line">                temp = Interval(temp.start, max(temp.end, next.end))</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        res.append(temp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><strong>leetcode用时：748ms</strong></p>
<p>这个超慢实现还是常见的<strong>低效循环</strong>错误，课件只要避免在<a href="https://freshmanhaner.github.io/2018/10/05/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/#more" target="_blank" rel="noopener">如何优化程序性能</a>提到过的常见错误，可以很大程度上提升程序的时间性能。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Leetcode国际版：<a href="https://leetcode.com/" target="_blank" rel="noopener">https://leetcode.com/</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>领扣</tag>
        <tag>中等</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 2 AddTwoNumbers</title>
    <url>/chinese/2019/02/10/leetcode-2-AddTwoNumbers/</url>
    <content><![CDATA[<h1 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定两个<strong>非空</strong>链表来表示两个非负整数。整数的数位反向存储，每个链表节点存储一个数字。将两个整数相加并以相同的格式返回结果。</p>
<p>例如：</p>
<blockquote>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p>
<p>输出：7 -&gt; 0 -&gt; 8</p>
<p>其实就是 342 + 465 = 807</p>
</blockquote>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个题目本身难度不大，不知道难度为什么是<em>中等</em>。我解题过程中主要的纠结点是对结果链表头部的处理，因为链表头部相对于其他节点比较特殊，需要单独考虑。其他没有发现什么难点，无非是对链表和指针的操作。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>对于链表头节点的问题，我选择创建一个空的头节点，这样可以统一处理头节点和其他节点，在最后返回时跳过空的头节点。</p>
<p>我的第一次实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: <span class="string">'ListNode'</span>, l2: <span class="string">'ListNode'</span>)</span> -&gt; 'ListNode':</span></span><br><span class="line">        carry = <span class="number">0</span> <span class="comment">#进位</span></span><br><span class="line">        </span><br><span class="line">        lp1 = l1</span><br><span class="line">        lp2 = l2</span><br><span class="line">        </span><br><span class="line">        lsum = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        res = ListNode(<span class="number">0</span>)</span><br><span class="line">        lpr = res</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lp1:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lp2:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(lp1 <span class="keyword">and</span> lp2):</span><br><span class="line">            lsum = lp1.val + lp2.val + carry</span><br><span class="line">            <span class="keyword">if</span>(lsum &gt;= <span class="number">10</span>):</span><br><span class="line">                lsum -= <span class="number">10</span></span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            new_digit = ListNode(lsum)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">            lpr = lpr.next</span><br><span class="line">            lp1 = lp1.next</span><br><span class="line">            lp2 = lp2.next</span><br><span class="line">        <span class="keyword">while</span>(lp1):</span><br><span class="line">            lsum = lp1.val + carry</span><br><span class="line">            <span class="keyword">if</span> lsum &gt;= <span class="number">10</span>:</span><br><span class="line">                lsum -= <span class="number">10</span></span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            new_digit = ListNode(lsum)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">            lpr = lpr.next</span><br><span class="line">            lp1 = lp1.next</span><br><span class="line">        <span class="keyword">while</span>(lp2):</span><br><span class="line">            lsum = lp2.val + carry</span><br><span class="line">            <span class="keyword">if</span> lsum &gt;= <span class="number">10</span>:</span><br><span class="line">                lsum -= <span class="number">10</span></span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            new_digit = ListNode(lsum)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">            lpr = lpr.next</span><br><span class="line">            lp2 = lp2.next</span><br><span class="line">        <span class="keyword">if</span> carry != <span class="number">0</span>:</span><br><span class="line">            new_digit = ListNode(carry)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">        res = res.next</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>leetcode运行时间128ms。</p>
<p>第一次的实现表现不佳，用时排名接近50%。主要问题在于每次循环都用if/else判断lsum是否大于等于10，这样其实浪费了不少时间。那么我们能不能无论lsum是否小于10，都统一处理呢？可以！</p>
<p>优化后代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: <span class="string">'ListNode'</span>, l2: <span class="string">'ListNode'</span>)</span> -&gt; 'ListNode':</span></span><br><span class="line">        carry = <span class="number">0</span> <span class="comment">#进位</span></span><br><span class="line">        </span><br><span class="line">        lp1 = l1</span><br><span class="line">        lp2 = l2</span><br><span class="line">        </span><br><span class="line">        lsum = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        res = ListNode(<span class="number">0</span>)</span><br><span class="line">        lpr = res</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(lp1 <span class="keyword">and</span> lp2):</span><br><span class="line">            lsum = lp1.val + lp2.val + carry</span><br><span class="line">            carry = lsum // <span class="number">10</span></span><br><span class="line">            lsum = lsum % <span class="number">10</span></span><br><span class="line">            new_digit = ListNode(lsum)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">            lpr = lpr.next</span><br><span class="line">            lp1 = lp1.next</span><br><span class="line">            lp2 = lp2.next</span><br><span class="line">        <span class="keyword">while</span>(lp1):</span><br><span class="line">            lsum = lp1.val + carry</span><br><span class="line">            carry = lsum // <span class="number">10</span></span><br><span class="line">            lsum = lsum % <span class="number">10</span></span><br><span class="line">            new_digit = ListNode(lsum)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">            lpr = lpr.next</span><br><span class="line">            lp1 = lp1.next</span><br><span class="line">        <span class="keyword">while</span>(lp2):</span><br><span class="line">            lsum = lp2.val + carry</span><br><span class="line">            carry = lsum // <span class="number">10</span></span><br><span class="line">            lsum = lsum % <span class="number">10</span></span><br><span class="line">            new_digit = ListNode(lsum)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">            lpr = lpr.next</span><br><span class="line">            lp2 = lp2.next</span><br><span class="line">        <span class="keyword">if</span> carry != <span class="number">0</span>:</span><br><span class="line">            new_digit = ListNode(carry)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">        <span class="keyword">return</span> res.next</span><br></pre></td></tr></table></figure>

<p>leetcode运行时间96ms。</p>
<p>96ms的表现已经超越99.26%的实现。</p>
<h2 id="超慢实现"><a href="#超慢实现" class="headerlink" title="超慢实现"></a>超慢实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l3val = <span class="number">0</span></span><br><span class="line">            add1 =<span class="number">0</span> </span><br><span class="line">            l3 = ListNode(<span class="number">0</span>)</span><br><span class="line">            l3last = l3</span><br><span class="line">            <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 :</span><br><span class="line">                l3val=<span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> l1 :</span><br><span class="line">                    l3val = l1.val</span><br><span class="line">                    <span class="comment">#print(l1.val)</span></span><br><span class="line">                    l1 = l1.next</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">if</span> l2 :</span><br><span class="line">                    l3val += l2.val</span><br><span class="line">                    <span class="comment">#print(l2.val)</span></span><br><span class="line">                    l2 = l2.next</span><br><span class="line">                l3val += add1</span><br><span class="line">                add1 = l3val//<span class="number">10</span></span><br><span class="line">                l3last.next = ListNode(l3val%<span class="number">10</span>)</span><br><span class="line">                l3last = l3last.next</span><br><span class="line">                print(add1)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> add1==<span class="number">1</span>:</span><br><span class="line">                l3last.next = ListNode(<span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> l3.next</span><br></pre></td></tr></table></figure>

<p>leetcode用时312ms。</p>
<p>这个超慢实现，我不太确定慢的原因。我觉得可能的原因有：</p>
<ol>
<li>循环中的两个分支多数情况下都要经过，这限制了处理器的预执行优化，影响性能。</li>
<li>实现中有<code>print()</code></li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Leetcode国际版：<a href="https://leetcode.com/" target="_blank" rel="noopener">https://leetcode.com/</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>中等</tag>
        <tag>力扣</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 162 Find Peak Element</title>
    <url>/chinese/2019/01/23/leetcode-162-Find-Peak-Element/</url>
    <content><![CDATA[<h1 id="leetcode-162-Find-Peak-Element"><a href="#leetcode-162-Find-Peak-Element" class="headerlink" title="leetcode 162 Find Peak Element"></a>leetcode 162 Find Peak Element</h1><p>这个题目是MIT 6.006算法课中提到的第一个问题，也就是一维数组的Peak Finder问题。如果感兴趣看一看一下我的<a href="https://freshmanhaner.github.io/2019/01/20/MIT-6-006-Lecture-1-b-%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">MIT 6.006 Lecture 1-b 笔记</a>。</p>
<p>在对比不同解题思路的同时，我还对比了不同语言（c、C++、Python）。能够非常明显的看出在<strong>效率方面</strong>：c &gt; C++ &gt; Python；时间复杂度最高的<strong>简单算法用c语言写</strong>的效率也要大于C++写的低时间复杂度的算法，更不用说Python。当然如果看简洁程度，Python还是更优。详细情况请看具体实现。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote>
<p>A peak element is an element that is greater than its neighbors.</p>
<p>峰值元素是指比相邻元素大的元素</p>
<p>Given an input array <code>nums</code>, where nums[i] $\neq$ nums[i+1], find a peak element and return its index.</p>
<p>给定输入数组<code>nums</code>，规定nums[i]$\neq$nums[i+1]。从该数组中找到一个峰值元素并返回它的索引值。</p>
<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>
<p>给定的数组中可能含有多个峰值，只需找到其中任意一个即可。</p>
<p>You may imagine that nums[-1] = nums[n] = $-\infty$.</p>
<p>你可以假设nums[-1] = nums[n] = $-\infty$。</p>
</blockquote>
<a id="more"></a>

<h2 id="解体思路"><a href="#解体思路" class="headerlink" title="解体思路"></a>解体思路</h2><p>题目中很多的假设可以用来提升我们算法的效率，比如nums[i]$\neq$nums[i+1]、nums[-1] = nums[n] = $-\infty$。</p>
<h3 id="线性扫描"><a href="#线性扫描" class="headerlink" title="线性扫描"></a>线性扫描</h3><p>从左往右扫描整个数组，找出第一个出现的峰值元素。第一反应是看每个元素的左右两边来判断是否为峰值，其实只需要可能右边邻居，因为左边已经比较过了，一定是小于该元素的。</p>
<ul>
<li><p>时间复杂度<br>最坏情况下（元素自左向右递增）我们要扫描整个数组。所以时间复杂度为$O(n)$。</p>
</li>
<li><p>空间复杂度</p>
<p>只用到了常数额外空间，所以空间复杂度是$O(1)$。</p>
</li>
</ul>
<h3 id="递归二分搜索"><a href="#递归二分搜索" class="headerlink" title="递归二分搜索"></a>递归二分搜索</h3><p>递归二分搜索算法和下面的迭代二分搜索都属于<strong>分治策略</strong>_devide&amp;conquer_的一种。根据题目我们可以看出，考虑中间元素<code>mid</code>，如果<code>nums[mid] &lt; nums[mid+1]</code>，那么<code>mid</code>元素的右边一定存在峰值元素。因为我们只需找出峰值元素中的任意一个，我们就不再需要考虑<code>mid</code>元素的左边一半了，这样问题的规模也就缩小了一半。</p>
<ul>
<li>时间复杂度<br>$T(n) = T(\frac{n}{2}) + \Theta(1) = T(\frac{n}{4}) + 2\Theta(1) = … = log_2(n) \times \Theta(1)=O(log_2(n))$</li>
<li>空间复杂度<br>递归二分搜索中，每次递归表用都会占用上次一半的额外空间，所以总的额外空间是$log_2(n)$。也就是说空间复杂度也是$O(log_2(n))$。</li>
</ul>
<h3 id="迭代二分搜索"><a href="#迭代二分搜索" class="headerlink" title="迭代二分搜索"></a>迭代二分搜索</h3><p>迭代二分搜索和递归二分搜索整体思路一样，<strong>时间复杂度也是相同的</strong>（迭代在常数项上一般优于递归）。差别在于迭代二分搜索不会占用太多的额外空间，所以空间复杂度是$O(1)$。</p>
<p>所以能用迭代的地方尽量不用递归。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="线性扫描算法——c语言实现"><a href="#线性扫描算法——c语言实现" class="headerlink" title="线性扫描算法——c语言实现"></a>线性扫描算法——c语言实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; nums[i + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然是$\Theta(n)$的时间复杂度，但是用c语言编写的话用时为<strong>0ms</strong>。</p>
<h3 id="递归二分搜索——C-实现"><a href="#递归二分搜索——C-实现" class="headerlink" title="递归二分搜索——C++实现"></a>递归二分搜索——C++实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == e)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> mid = (s + e) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[mid + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> search(nums,mid+<span class="number">1</span>,e);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> search(nums,s,mid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">return</span> search(nums,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>用时<strong>4ms</strong></p>
<h3 id="迭代二分搜索——Python3实现"><a href="#迭代二分搜索——Python3实现" class="headerlink" title="迭代二分搜索——Python3实现"></a>迭代二分搜索——Python3实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start = <span class="number">0</span> </span><br><span class="line">        end = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">            <span class="keyword">if</span> start == end:</span><br><span class="line">                <span class="keyword">return</span> start</span><br><span class="line">            mid = (start + end)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid+ <span class="number">1</span>]):</span><br><span class="line">                start = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br></pre></td></tr></table></figure>

<p>单纯按照时间复杂度来比较，迭代二分搜索应该是最快的，但是用Python实现用时却是同样时间复杂度C++实现的8倍，用时<strong>32ms</strong>。</p>
<h2 id="超慢实现"><a href="#超慢实现" class="headerlink" title="超慢实现"></a>超慢实现</h2><p>通过分析超慢实现，我们可以避免影响算法效率的低级错误。</p>
<h3 id="c语言超慢实现"><a href="#c语言超慢实现" class="headerlink" title="c语言超慢实现"></a>c语言超慢实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = numsSize  <span class="number">-1</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt;  nums[m+<span class="number">1</span>]) &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细看这段代码，其实并没有什么低价错误，只不过是在计算中间值m的时候算式稍微复杂些。和最优实现0ms差别也不大，用时4ms。</p>
<h3 id="C-超慢实现"><a href="#C-超慢实现" class="headerlink" title="C++超慢实现"></a>C++超慢实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">2</span>)            </span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//----------------------------------------------</span></span><br><span class="line">        <span class="keyword">int</span> peak = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;            </span><br><span class="line">            <span class="keyword">if</span> (i<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; i+<span class="number">1</span> &lt; nums.size() )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>] &amp;&amp; nums[i] &gt; nums[i+<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i+<span class="number">1</span> == nums.size() &amp;&amp; nums[i] &gt; nums[i<span class="number">-1</span>])                </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> peak;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>和上段代码不同，这段代码就明显犯了<strong>低级错误：在循环代码中加入了低效率因素。</strong>在<code>for</code>循环语句中使用<code>nums.size()</code>，使得每次循环都会调用<code>size()</code>函数，严重影响算法性能，用时8ms。</p>
<p>至于如何优化算法性能，请见<a href="https://freshmanhaner.github.io/2018/10/05/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/#more" target="_blank" rel="noopener">如何优化程序性能</a></p>
<h3 id="Python3超慢实现"><a href="#Python3超慢实现" class="headerlink" title="Python3超慢实现"></a>Python3超慢实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> nums[<span class="number">0</span>] &gt;= nums[<span class="number">1</span>] <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            </span><br><span class="line">            mid = low + (high - low) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">and</span> nums[<span class="number">0</span>] &gt;= nums[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> mid == len(nums)<span class="number">-1</span> <span class="keyword">and</span> nums[<span class="number">-1</span>] &gt;= nums[<span class="number">-2</span>]:</span><br><span class="line">                <span class="keyword">return</span> len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid<span class="number">-1</span>] &lt;= nums[mid] <span class="keyword">and</span> nums[mid] &gt;= nums[mid+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> nums[mid+<span class="number">1</span>] &gt; nums[mid]:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure>

<p>循环中加入了太多的分支，一定程度上拖慢了程序的性能，用时76ms。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Leetcode国际版：<a href="https://leetcode.com/" target="_blank" rel="noopener">https://leetcode.com/</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>领扣</tag>
        <tag>easy</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>使用virtualenv和virtualenvwrapper建立多个独立python环境</title>
    <url>/chinese/2019/01/22/%E4%BD%BF%E7%94%A8virtualenv%E5%92%8Cvirtualenvwrapper%E5%BB%BA%E7%AB%8B%E5%A4%9A/</url>
    <content><![CDATA[<p>Python丰富的库是它的优势之一，但是对于我这样的强迫症来说却多少有些不太友好。安装的库越来越多，加上各种库之间的依赖关系。即使能够方便地查看，也会觉得混乱。更不要说还有安装失败的时候，强迫症心里表示很不舒服。<br>如果你在使用Python，也像我一样是个强迫症，那么救星来了。</p>
<p><img src="https://www.python.org/static/img/python-logo.png" alt="Python"></p>
<a id="more"></a>  

<h1 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h1><p><a href="https://pypi.org/project/virtualenv/" target="_blank" rel="noopener">virtualenv</a>是建立独立Python环境的工具，独立的Python环境在实际中是非常必要的。比如你的某个软件依赖某个库的版本1，另一个软件依赖这个库的版本2，如果你把这个库装在同一个python环境中，你很可能把某些你不想升级的库升级了，从而导致一些软件的失效。<br>搞清楚了有什么用，下面我们来安装吧，这里以Windows环境为例。有了神器pip的帮助，virtualenv的安装很简单，进入cmd，然后只需<code>pip install virtualenv</code>这条命令就能安装成功。如果遇到问题，详细解决请参见<a href="https://virtualenv.pypa.io/en/latest/" target="_blank" rel="noopener">官方文件</a>。<br>安装简单，使用起来还很简答。进入你需要防止独立Python环境的目录下，执行<code>virtualenv your_env_name</code>Python虚拟环境就能创建成功。如果现在就想使用这个环境，只需要<code>cd your_env_name/Scripts</code>，找到<em>Scripts</em>目录下的<em>avtivate.bat</em>这个脚本文件，执行就能进入虚拟环境。你可以像在真实环境下一样通过<code>pip list</code>查看已经看装的库，或者安装/卸载你需要的库，我就不再多说了。当你想要退出的时候，也只需要运行<em>deactivate.bat</em>文件就可以了。<br>这些虚拟环境可以任意放置，而每次使用都要进入虚拟环境目录下来运行脚本文件。管理起来，使用起来未免还是有些麻烦，对晚期强迫症来说还是不够，如果有工具能够帮助我们管理虚拟环境，在任意位置都能使用就好了。  </p>
<h1 id="virtualenvwrapper"><a href="#virtualenvwrapper" class="headerlink" title="virtualenvwrapper"></a>virtualenvwrapper</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://pypi.org/project/virtualenvwrapper/" target="_blank" rel="noopener">virtualenvwrapper</a>就是你需要的管理软件，看名字就可以看出，它主要是对virtualenv的一些功能做了封装，方便我们使用。官方列出的功能如下：</p>
<blockquote>
<ol>
<li>Organizes all of your virtual environments in one place.</li>
<li>Wrappers for creating, copying and deleting environments, including user-configurable hooks.</li>
<li>Use a single command to switch between environments.</li>
<li>Tab completion for commands that take a virtual environment as argument.</li>
<li>User-configurable hooks for all operations.</li>
<li>Plugin system for more creating sharable extensions.</li>
</ol>
</blockquote>
<p>我就不翻译了，反正你知道它很有用就是了。下面介绍安装和简单的使用，还是以Windows环境为例。安装还是依靠咱们的<em>pip</em>神器，<code>pip install virtualenvwrapper-win</code>（linux下是<code>pip install virtualenvwrapper</code>就可以了）。安装成功后的简单使用如下：</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="新建virtualenv"><a href="#新建virtualenv" class="headerlink" title="新建virtualenv"></a>新建virtualenv</h3><p><code>mkvirtualenv your_env_name</code>，所有的Python环境会被集中放置在同一目录下，命令返回的内容会告诉你在哪里。</p>
<h3 id="删除虚拟环境"><a href="#删除虚拟环境" class="headerlink" title="删除虚拟环境"></a>删除虚拟环境</h3><p><code>rmvirtualenv your_env_name</code>，用于删除某个指定的虚拟环境。</p>
<h3 id="查看所有Python环境"><a href="#查看所有Python环境" class="headerlink" title="查看所有Python环境"></a>查看所有Python环境</h3><p><code>workon</code></p>
<h3 id="进入某个Python环境"><a href="#进入某个Python环境" class="headerlink" title="进入某个Python环境"></a>进入某个Python环境</h3><p><code>workon the_env_you_want_enter</code></p>
<h3 id="退出当前Python环境"><a href="#退出当前Python环境" class="headerlink" title="退出当前Python环境"></a>退出当前Python环境</h3><p><code>deactivate</code><br>virtualenvwrapper的功能当然不知于此，更多功能等你探索。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="https://virtualenv.pypa.io/en/latest/" target="_blank" rel="noopener">https://virtualenv.pypa.io/en/latest/</a></li>
<li><a href="https://virtualenvwrapper.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://virtualenvwrapper.readthedocs.io/en/latest/</a></li>
</ol>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>virtualenv</tag>
        <tag>virtualenvwrapper</tag>
        <tag>虚拟python环境</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.828操作系统工程实验JOSOS Lab1 Booting a PC</title>
    <url>/chinese/2018/11/29/MIT6-828%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%AE%9E%E9%AA%8CJOSOS-Lab1-Boot/</url>
    <content><![CDATA[<p>先给出MIT的OS Lab1的网址，详细介绍和相关资源在里面都能找到，开始的配置可能要费些力气。<a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/" target="_blank" rel="noopener">MIT 6.828 Lab1（没被墙）</a><br>这个实验要求你有比较多的预备知识，包括</p>
<ol>
<li>汇编语言——<a href="https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf" target="_blank" rel="noopener">汇编参考资料（注意intel和AT&amp;T语法的不同）</a>/<a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html" target="_blank" rel="noopener">这是AT&amp;T的</a></li>
<li>GDB——<a href="https://www.gnu.org/software/gdb/" target="_blank" rel="noopener">官网</a></li>
</ol>
<p>整个实验1要实现的代码不难，但是要理解的细节非常多。编程难度不大，理解起来颇为费力，所以要有耐心，多花些时间来理解，如果遇到实在不能理解的东西，可以参考一些别人的理解。还是不行的话，我知道一个做的很好的<a href="https://github.com/Clann24/jos" target="_blank" rel="noopener">答案</a>，写的很详细，编码也很好，但是不到万不得已还是不要点的好。废话不多说，开始吧！</p>
<p>要了解操作系统，首先要了解操作系统是怎么被载入的，因为操作系统归根到底也是一个软件。从计算机启动到载入操作系统的大致过程如下：  </p>
<ol>
<li>处理器启动时默认访问特定内存地址，这段地址非易失地储存一些命令，完成一些设备的初始化，然后找到引导设备。</li>
<li>从引导设备中读入第一个block，了解loader的信息。</li>
<li>连续读入block来载入操作系统内核。</li>
</ol>
<p>接下来是关于实验一我的一些理解：</p>
<a id="more"></a>

<p>先给出地址空间的结构，后面是详细介绍：  </p>
<p><img src="https://web-source-1256501598.cos.ap-shanghai.myqcloud.com/image/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.PNG" alt="内存结构示意图"></p>
<p>基于intel 8088处理器的早期个人电脑只能够访问1MB的物理地址，所以地址只能是从0x00000000到0x000FFFFF。但是最多只有640KB可用，从0x000A0000到0x000FFFFF这384KB被硬件保留为特殊用途，<strong>最重要的用途是Basic Input/Output System也就是我们常说的BIOS（基本输入输出系统）</strong>，它占用了从0x000F0000到0x000FFFFF的64KB空间。BIOS的主要作用是基础系统的初始化（包括激活显卡，检查内存条数量等等）和操作系统的载入，后面我们再介绍具体怎么载入操作系统。   </p>
<p>intel 80286处理器的出现打破了1MB的限制，可访问的物理内存增加到了16MB，随后的intel 80386更是直接提升到了4GB。intel为了向下兼容，既让基于早期处理器设计的软件依然可以运行，保留了这1MB的结构。所以我们现在使用的电脑内存中会<strong>有一个“洞”</strong>，就是从0x000F0000到0x000FFFFF这64KB。这个“洞”把内存空间分为“传统内存”和“扩展内存”。   </p>
<p>现在的个人电脑处理器多数已经是64位了，64位处理器理论上支持的物理内存已经达到2^64字节也就是18EB（约180亿GB），当然只是理论上……如果你的电脑是64位处理器，并且内存超过4G的话，那你的内存中就会存在<strong>第二个“洞”</strong>。这是因为在32位的物理空间的最上方的一部分内存被保留，用来映射32位设备。（再次）为了兼容，这部分的地址空间也不能被使用。<br>介绍完了内存空间的结构，我们正式通过MIT的实验操作系统<em>JOS</em>来看操作系统是如何被载入的。</p>
<hr>
<p>讲解细节之前，先来说明一下我们初步目的。MIT给出的JOS操作系统中，kernal的装载主要是由<em>boot.S</em>和<em>main.c</em>这两个文件完成的。其中<em>boot.S</em>由汇编写成，用来初始化设备，将处理器切换为保护模式，最后跳转到<em>main.c</em>。<em>main.c</em>主要是用来装载kernal，在装载完成后跳转到kernal，并且把控制权交给kernal。接下来我们开始讲解这个目的在细节上是如何实现的。<br>按照<strong>实验文档</strong>里的方法顺利用GDB打开了<strong><em>qemu 模拟器</em></strong>上<em>JOS</em>的启动程序。然后我来逐条分析每条汇编语言的目的。<br>起始第一条命令是<code>ljmp</code>跳转指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b</span><br></pre></td></tr></table></figure>
<p>更详细地分析我们知道</p>
<ol>
<li>开始时CS(Code Segment)寄存器 = 0xf000，IP(Instruction Pointer)指令指针寄存器=0xfff0</li>
<li>第一条命令位于地址<em>0x000ffff0</em>处，这是由段地址（CS:IP）转换得到的。而这正是BIOS ROM最高的16bytes。</li>
<li>它要跳转到地址<em>0x000fe05b</em>处。</li>
</ol>
<p>从上面给出的内存地址空间图，我们可以看出0x000ffff0是BIOS的最后16byte，所以他要跳转到0x000fe05b。然后就能够执行BIOS了，BIOS的工作主要是设置中断表，初始化PCI总线和一些设备，最后寻找寻找引导设备（bootable device）。  </p>
<p>如果一个磁盘是bootable的，那它的第一个扇区称为引导扇区（boot sector），里面放置的就是引导装载程序（boot loader）。</p>
<p>BIOS找到引导设备后，会把引导扇区读入内存0x7c00到0x7dff这部分内存中，然后跳转到0x7c00开始执行引导装载程序。</p>
<p>下面是完成这些操作的汇编分析（注意我贴出的都是运行地址，不是链接地址）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[f000:e05b]    0xfe05b:	cmpl   $0x0,%cs:0x6ac8 #(gdb) print&#x2F;x *(0xf6ac8) 结果$1 &#x3D; 0x0</span><br><span class="line">[f000:e062]    0xfe062:	jne    0xfd2e1</span><br><span class="line">[f000:e066]    0xfe066:	xor    %dx,%dx #寄存器dx置零</span><br><span class="line">[f000:e068]    0xfe068:	mov    %dx,%ss #寄存器SS置零</span><br><span class="line">[f000:e06a]    0xfe06a:	mov    $0x7000,%esp #extended stack pointer（扩展栈指针）设置为0x7000</span><br><span class="line">[f000:e070]    0xfe070:	mov    $0xf34c2,%edx</span><br><span class="line">[f000:e076]    0xfe076:	jmp    0xfd15c</span><br><span class="line">[f000:d15c]    0xfd15c:	mov    %eax,%ecx</span><br></pre></td></tr></table></figure>
<p>这一段对然可以理解每句汇编的意思，但是看不出它的目的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[f000:d15f]    0xfd15f:	cli  #关中断</span><br><span class="line">[f000:d160]    0xfd160:	cld  #状态标志寄存器（flag）的第10位（方向标志位）置零，设置地址的变化方向</span><br></pre></td></tr></table></figure>
<p>如果你看反汇编生成的的<em>obj/boot/boot.asm</em>，你会发现这两句的链接地址在0x7c00，正是booter里boot.S开始的地方。这两句的意义也不难理解，整个装载过程肯定不能被中断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[f000:d161]    0xfd161:	mov    $0x8f,%eax #将al寄存器置为0x8f(10001111)</span><br><span class="line">[f000:d167]    0xfd167:	out    %al,$0x70  #讲0x8f写入0x70端口，0x70是变址寄存器端口</span><br><span class="line">[f000:d169]    0xfd169:	in     $0x71,%al  #将端口0x71的内容读入al寄存器，0x71是数据端口</span><br><span class="line">[f000:d16b]    0xfd16b:	in     $0x92,%al  #将端口0x92的内容读入al寄存器，0x92是系统控制端口A</span><br><span class="line">[f000:d16d]    0xfd16d:	or     $0x2,%al   #将al寄存器的第2位（位1）置1</span><br><span class="line">[f000:d16f]    0xfd16f:	out    %al,$0x92  #写回端口0x92</span><br></pre></td></tr></table></figure>

<p>这段命令目的在于初始化设备。</p>
<p>端口0x92各个位的意义：</p>
<ul>
<li>Bit 0 - Setting to 1 causes a fast reset </li>
<li>Bit 1 - 0: disable A20, 1: enable A20</li>
<li>Bit 2 - Manufacturer defined</li>
<li>Bit 3 - power on password bytes. 0: accessible, 1: inaccessible</li>
<li>Bits 4-5 - Manufacturer defined</li>
<li>Bits 6-7 - 00: HDD activity LED off, 01 or any value is “on”</li>
</ul>
<p>我们看到0x92端口的第2位（位1）置1表示激活A20，即第21个地址线被使能，A20地址线被激活，会使系统工作进入保护模式。  我打印出al寄存器，发现值就是2，也就是说除了位1，其他未全部为零。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[f000:d171]    0xfd171:	lidtw  %cs:0x6ab8 </span><br><span class="line">[f000:d177]    0xfd177:	lgdtw  %cs:0x6a74</span><br></pre></td></tr></table></figure>
<p>lidt指令：加载中断向量表寄存器(IDTR)。这个指令会把从地址0xf6ab8起始的后面6个字节的数据读入到中断向量表寄存器(IDTR)中。中断向量表中存放着中断处理程序的首地址，用来处理不同的中断。<br>lgdt指令：加载全局描述符表寄存器 GDT（Global Descriptor Table），在GDT中主要存放段描述符，还有其它描述符，它们都是64-bit长。把从0xf6a74为起始地址处的6个字节的值加载到全局描述符表格寄存器中GDTR中。<br>全局描述符表实现保护模式非常重要的一部分，因为在实模式下的段号（段描述符）只有16位，这对于32位以上的处理器来说就不够用了，为了向下兼容段号长度又不能更改，只能用一个表来存储段号，原先16位的段号来查找这些表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[f000:d17d]    0xfd17d:	mov    %cr0,%eax</span><br><span class="line">[f000:d180]    0xfd180:	or     $0x1,%eax</span><br><span class="line">[f000:d184]    0xfd184:	mov    %eax,%cr0</span><br></pre></td></tr></table></figure>
<p>这三条命令的目的很明显是将控制寄存器CR0的第1位（位0）置1，CR0的位0是启用保护（Protection Enable）标志。当设置该位时即开启了保护模式；当复位时即进入实地址模式。这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么PE和PG标志都要置位。</p>
<p>第一次打开A20地址线是为了检查可用资源，这次是正式进入保护模式了，然后我们需要装载内核了。<br>接下来boot.S会保存寄存器，并调用main.c的函数来实现引导扇区以及后续扇区的装载，等装载完成，操作权就交到操作系统手里了。<em>boot/main.c</em>最后执行的一条语句是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#((void (*)(void)) (ELFHDR-&gt;e_entry))();这次是链接地址</span><br><span class="line">   7d6b:       ff 15 18 00 01 00       call   *0x10018</span><br></pre></td></tr></table></figure>
<p>然后我们就进入了操作系统的entrypoint。<br>关于实验的各个练习及问题，<a href="https://github.com/Clann24/jos/" target="_blank" rel="noopener">这个连接</a>都给出了详细的答案。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>计算机及软件</category>
        <category>计算机系统</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>OS</tag>
        <tag>实验</tag>
        <tag>MIT</tag>
        <tag>Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 7 ReverseInteger</title>
    <url>/chinese/2018/11/19/leetcode-7-ReverseInteger/</url>
    <content><![CDATA[<h1 id="Reverse-Integer"><a href="#Reverse-Integer" class="headerlink" title="Reverse Integer"></a>Reverse Integer</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Given a 32-bit signed integer, reverse digits of an integer.</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: 123</span><br><span class="line">Output: 321  </span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: -123</span><br><span class="line">Output: -321  </span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong><br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range:$[-2^{31},2^{31}-1]$ . For the purpose of this problem, assume that your function <em>returns 0 when the reversed integer overflows</em>.</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个题目比较简单，也没有太多发挥的空间，主要的性能差异产生于实现的细节上。<br>大部分人的思路思路都是利用求余的方法从右往左取出x中的数字，然后在将他们组成结果。当然要记得处理超出范围的情况。<br>那么同样的思路在实现时可以产生许多的差异。比如：</p>
<ul>
<li>如何处理x的正负情况<ul>
<li><code>if/else</code>分别处理两种情况</li>
<li>利用编程语言的特性同时处理两种情况</li>
</ul>
</li>
<li>如何存储提取出的数字<ul>
<li>存储在<strong>队列</strong>中</li>
<li>边提取边处理，不做存储</li>
</ul>
</li>
<li>如何判断超出范围的情况<ul>
<li>在溢出前做处理</li>
<li>用范围更大的数据类型存储结果，最后再判断是否超出范围</li>
</ul>
</li>
</ul>
<p>这些细节对结果不会产生太大的影响，但是当大家的性能非常接近时，每1ms的提升都可以超越许多人。  </p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>我选择了大多数人能实现的，较快的实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//leetcode表现：用时12ms</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(INT_MAX / <span class="number">10</span> &lt; result || INT_MIN/<span class="number">10</span> &gt; result)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            result = result*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="超慢实现"><a href="#超慢实现" class="headerlink" title="超慢实现"></a>超慢实现</h2><p>虽然这一题大家的实现在效率差不许多，我们还是来试着分析一下最慢的实现是怎么造成的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//leetcode表现：用时32ms</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">            res = res*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( (res&gt;=INT_MIN) &amp;&amp; (res&lt;=INT_MAX)) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个较慢实现看上去和较好的实现差别不大，唯二的差别是：</p>
<ul>
<li>较慢实现采用计算完成后再判断是否溢出</li>
<li>结果的数据类型一个是int一个是long long</li>
</ul>
<p>上述两点差别在这个题目中并不会造成多大影响。如果非要区别的话，第一个区别在溢出的情况下会多花时间；第二个区别则会造成一点空间上的浪费。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Leetcode国际版：<a href="https://leetcode.com/" target="_blank" rel="noopener">https://leetcode.com/</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>领扣</tag>
        <tag>easy</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ STL之map与unordered_map对比</title>
    <url>/chinese/2018/11/15/C-STL%E4%B9%8Bmap%E4%B8%8Eunordered-map%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>map和unordered_map都是STL中的容器，它们虽然用法相似，但是背后的原理值得了解，进而在不同场景中有针对性的应用它们。</p>
<a id="more"></a>
<h1 id="STL之map"><a href="#STL之map" class="headerlink" title="STL之map"></a>STL之map</h1><p>&emsp;<a href="http://www.cplusplus.com/reference/map/map/" target="_blank" rel="noopener">map</a>是C++标准模板库（<em>Standard Template Library</em>）中常用的关联容器（<em>associative container</em>），元素由键值（<em>key value</em>）和映射值（<em>mapped value</em>）组成，通过<strong>唯一键值</strong>来查找映射值。map中可以通过键值直接得到映射值，例如：  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="built_in">std</span>::<span class="built_in">string</span>&gt; name2description;</span><br><span class="line">    name2description[<span class="string">"Tom"</span>]=<span class="string">"A dumb cat"</span>;</span><br><span class="line">    name2description[<span class="string">"Jerry"</span>]=<span class="string">"A cunning mouse"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Tom is "</span> &lt;&lt; name2description[<span class="string">"Tom"</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="STL之unordered-map"><a href="#STL之unordered-map" class="headerlink" title="STL之unordered_map"></a>STL之unordered_map</h1><p>&emsp;<a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/" target="_blank" rel="noopener">unordered_map</a>也是C++标准模板库中的容器，但是不像map那样常用。unordered_map的基本用法和map几乎完全一样，只是不存在反向迭代器（<em>iterator</em>）。  </p>
<h1 id="map与unordered-map的区别"><a href="#map与unordered-map的区别" class="headerlink" title="map与unordered_map的区别"></a>map与unordered_map的区别</h1><p>&emsp;虽然两者在使用上几乎没什么区别，但是在用途上却有不小的差别。原因在于<strong>map的内部实现是二叉搜索树（<em>Binary Search Tree</em>）</strong>，而且是按键值有序的（可以自定义排序方法）。相对的<strong>unordered_map的内部实现是哈希表</strong>，而且是无序的。它们的内部实现让它们具有了各自的优缺点。<br>&emsp;我们知道二叉搜索树各种操作上的性能比较平均也可以接受。不管是查找的O（log N），插入的O（N）还是删除的O（N），虽然都不是最好的情况，但也都是不错的时间复杂度，再加上它是有序的。这使得map容器很常用。<br>&emsp;相比于BST的平均，哈希表则更擅长搜索，搜索的摊分时间复杂度达到O（1）。但是它的无序性影响了他的通用性。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>计算机及软件</category>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>标准模板库</tag>
        <tag>map</tag>
        <tag>unordered_map</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_1_TwoSum</title>
    <url>/chinese/2018/11/15/leetcode/</url>
    <content><![CDATA[<h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.<br>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the same element twice.  </p>
<a id="more"></a>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="Brute-Force——暴力法"><a href="#Brute-Force——暴力法" class="headerlink" title="Brute Force——暴力法"></a>Brute Force——暴力法</h3><p>直接采用两层循环扫描所有元素，找到和为target的两个数，然后返回。<br><strong>时间复杂度：$O(N^2)$，空间复杂度：$O(1)$</strong>  </p>
<h3 id="Two-pass-Hash-Table——两遍哈希表法"><a href="#Two-pass-Hash-Table——两遍哈希表法" class="headerlink" title="Two-pass Hash Table——两遍哈希表法"></a>Two-pass Hash Table——两遍哈希表法</h3><p>算法在很多时候就是在时间复杂度与空间复杂度的权衡（trade-off）。暴力法空间复杂度很小，时间复杂度却比较大，显然不适用于对时间要求较高的应用。两遍哈希表法就是牺牲一点空间来换取一些时间。之所以叫两遍哈希表法（Hash Table），是因为要循环（iteration）两遍。第一遍建立哈希表存储每个元素的值和索引（Index）。第二遍循环利用建好的哈希表快速查找（Look Up）每个元素是否存在互补元素（即与之相加和为target的元素），就能在$O(N)$的时间复杂度下找到答案。<br><strong>时间复杂度：$O(N)$，空间复杂度$O(N)$</strong><br>&emsp;注意：哈希表的查找速度接近$O(1)$的时间复杂度，但具有不确定性。如果哈希表构建的不够好，碰撞（Collision）很多的话，查找速度也可能退化(Degenerate)为$O(N)$，但是一般而言，哈希表的摊分时间复杂度（Amortized Time Complexity）可以达到$O(1)$。  </p>
<h3 id="One-pass-Hash-Table——一遍哈希表法。"><a href="#One-pass-Hash-Table——一遍哈希表法。" class="headerlink" title="One-pass Hash Table——一遍哈希表法。"></a>One-pass Hash Table——一遍哈希表法。</h3><p>其实我们深入研究一下两遍哈希表法会发现，其实可以一次遍历做完<strong>插入</strong>和<strong>查找</strong>两件事。插入之前先看一下现在的哈希表中有没有待插入值的互补值，如果有，后面就不用继续执行了。既减少了遍历的次数，也减少了遍历的长度。当然，这两点只能影响到系数，并不会真正提升时间复杂度。<br><strong>时间复杂度：$O(N)$，空间复杂度：$O(N)$</strong></p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Brute Force</span></span><br><span class="line"><span class="comment">//leetcode表现：用时76ms</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">         <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = i + <span class="number">1</span>;j &lt; length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    result.push_back(i);</span><br><span class="line">                    result.push_back(j);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="两遍哈希表法"><a href="#两遍哈希表法" class="headerlink" title="两遍哈希表法"></a>两遍哈希表法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Two-pass Hash Table</span></span><br><span class="line"><span class="comment">//Leetcode表现：用时4ms</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">         <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash_table;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">            hash_table.insert(&#123;nums[i],i&#125;);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            it = hash_table.find(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it != hash_table.end() &amp;&amp; (*it).second != i)</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(i);</span><br><span class="line">                result.push_back((*it).second);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="一遍哈希表法"><a href="#一遍哈希表法" class="headerlink" title="一遍哈希表法"></a>一遍哈希表法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;One-pass</span><br><span class="line">&#x2F;&#x2F;leetcode表现：用时4ms</span><br><span class="line">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">         vector&lt;int&gt; result;</span><br><span class="line">        unordered_map&lt;int,int&gt; hash_table;</span><br><span class="line">        int len &#x3D; nums.size();</span><br><span class="line">        unordered_map&lt;int,int&gt;::iterator it;</span><br><span class="line">        int i;</span><br><span class="line">        for(i &#x3D; 0;i &lt; len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            it &#x3D; hash_table.find(target - nums[i]);</span><br><span class="line">            if(it !&#x3D; hash_table.end())</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(i);</span><br><span class="line">                result.push_back((*it).second);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                hash_table.insert(&#123;nums[i],i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="超慢实现"><a href="#超慢实现" class="headerlink" title="超慢实现"></a>超慢实现</h2><ol>
<li>其一：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//leetcode表现：用时288ms</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; answer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j &amp;&amp; (nums[i] + nums[j]) == target) &#123;</span><br><span class="line">                    answer.push_back(i);</span><br><span class="line">                    answer.push_back(j);</span><br><span class="line">                    <span class="keyword">return</span> answer;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
同样是暴力法解决问题，却花费了上一种暴力法接近<strong>四倍</strong>的时间。其中原由我在啊<a href="https://freshmanhaner.github.io/2018/10/05/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/#more" target="_blank" rel="noopener">如何优化程序性能</a>一文中已经提过，这里简单说一下原因。主要原因是在<strong>循环中出现了低效代码*</strong>nums.size()*，每次循环（而且还是两层循环）都要调用这个函数，造成了时间上的浪费。这种浪费是非常可怕的，尤其是对于大型程序来说，这样一个简单算法就有数倍的差别，可想而知对于大量数据或者大型程序将有多么大的差别。如果提前把他赋予一个常量，就可以避免这种浪费。<br>你以为这已经差到不能更差了？你错了！</li>
<li>其二：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//leetcode表现：用时292ms</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i!=j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]+nums[j]==target)</span><br><span class="line">                    &#123;</span><br><span class="line">                        d.emplace_back(i);</span><br><span class="line">                        d.emplace_back(j);</span><br><span class="line">                        <span class="keyword">return</span> d;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
你能找出这个解决方案比“最差”更差的原因吗？要知道<em>emplace_back()</em>是比<em>push_back()</em>要高效的。<br>上一种解决方案能别这一种快4ms，在于上一种解决方案少了一些判断。对于<em>if（断言1 &amp;&amp; 断言2）</em>这种形式，如果断言1不满足，后面的断言二就不会被判断了。上一种解决方案的一些情况中断言2不会被判断，一定程度上节省了时间，二这个解决方案无论什么情况下都会完成两个断言的判断。</li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Leetcode国际版：<a href="https://leetcode.com/" target="_blank" rel="noopener">https://leetcode.com/</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>专业学习</category>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>领扣</tag>
        <tag>easy</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>CSE Lab2 RPC and Lock Server</title>
    <url>/chinese/2018/11/10/CSE-Lab2-RPC-and-Lock-Server/</url>
    <content><![CDATA[<p>从这个实验中我们可以学到：    </p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank" rel="noopener">远程过程调用（Remote procedure call）——RPC</a></li>
<li>多线程并发，主要是下面四个函数：<ul>
<li><em>pthread_mutex_lock(&amp;mutex)</em>&amp;<em>pthread_mutex_unlock(&amp;mutex)</em></li>
<li><em>pthread_cond_wait(&amp;cond, &amp;mutex)</em>&amp;<em>pthread_cond_signal(&amp;cond)</em></li>
</ul>
</li>
<li>用上面四个函数实现<em>acquire(lock_id)</em>&amp;_release(lock_id)_两个函数，用来实现互斥。<a id="more"></a>
<h2 id="学习材料"><a href="#学习材料" class="headerlink" title="学习材料"></a>学习材料</h2></li>
</ol>
<ul>
<li>上面四个函数是在_pthread.h_中实现的，详见<a href="http://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread.h.html" target="_blank" rel="noopener">传送门</a>  </li>
<li><a href="https://ipads.se.sjtu.edu.cn/courses/cse/labs/Lab-2.html" target="_blank" rel="noopener">lab2: RPC&amp;Lock Server</a>  </li>
<li><a href="https://github.com/kururu002/CSE_Lab-MIT" target="_blank" rel="noopener">代码参考</a></li>
</ul>
<h2 id="远程过程调用-Remote-Procedure-Call"><a href="#远程过程调用-Remote-Procedure-Call" class="headerlink" title="远程过程调用 Remote Procedure Call"></a>远程过程调用 Remote Procedure Call</h2><p>&emsp;远程过程调用其实是一种进程间的通讯，它让进程可以像调用本地过程那样调用网路中另一地址空间中的过程。RPC是分布式计算的基础之一，简单易用，但是收到网络的影响。<br>&emsp;RPC 系统包含一下五个部分：</p>
<ol>
<li>RPC数据和信息的<strong>报文格式标准</strong></li>
<li>打包(marshal)/解包(unmarshal)工具库</li>
<li>RPC编译器</li>
<li>服务端框架</li>
<li>客户端框架</li>
<li>捆绑方法</li>
</ol>
<p>&emsp;下图描绘了RPC的调用过程：<br><img src="https://upload-images.jianshu.io/upload_images/7143349-a9db3c3c85194c6e.png" alt="RPC_call"><br>&emsp;这里我们不讨论RPC的实现细节，知识了解RPC以及它的简单实用。RPC的使用如下</p>
<ul>
<li>RPC server使用RPC library创建一个RPC server对象去监听某个端口，并且用reg()函数记录不同的RPC handler。</li>
<li>RPC client创建一个RPC client对象连接RPC server（利用地址+端口），然后调用RPC server上的远程过程。</li>
<li>RPC有接口标准规定server和client之间参数的传递。</li>
<li>server和client之间的数据传输需要经过mashal（发送端）和unmashal（接收端）。</li>
</ul>
<p>&emsp;因为实验对RPC不要求理解原理，大部分的代码已经实现，只需在extent_client.cc中去调用extent_server.cc中的函数就可以了。注意参数的类型和顺序，因为RPC库并不会检查传入参数的类型，如果传递了错误的类型也会被接受，进而出错。</p>
<h2 id="Lock-Server-amp-Locking"><a href="#Lock-Server-amp-Locking" class="headerlink" title="Lock Server&amp;Locking"></a>Lock Server&amp;Locking</h2><h3 id="Lock-Server"><a href="#Lock-Server" class="headerlink" title="Lock Server"></a>Lock Server</h3><p>&emsp;Lock Server主要是由<em>acquire(lock_id)</em>&amp;<em>release(lock_id)_这两个函数组成的，Lock Server可以管理许多个“锁”每个“锁”有唯一的整数id，而且每把”锁“在同一时间只能分配给一个client。“锁”的数量是不限制的，如果传入_acquire(lock_id)_的lock_id之前没有出现过，Locker Server会默认加入管理。_acquire(lock_id)</em>&amp;_release(lock_id)_两个函数的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">lockid_t</span>,<span class="keyword">bool</span>&gt; lock_table;<span class="comment">//全局变量，用来管理“锁”</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;<span class="comment">//条件变量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;<span class="comment">//互斥变量</span></span><br><span class="line"></span><br><span class="line">lock_protocol::status</span><br><span class="line">lock_server::acquire(<span class="keyword">int</span> clt, lock_protocol::<span class="keyword">lockid_t</span> lid, <span class="keyword">int</span> &amp;r)</span><br><span class="line">&#123;<span class="comment">//clt是client_id</span></span><br><span class="line">  lock_protocol::status ret = lock_protocol::OK;</span><br><span class="line">        <span class="comment">// Your lab2 part2 code goes here</span></span><br><span class="line">  pthread_mutex_lock(&amp;mutex);<span class="comment">//用于对锁操作的互斥</span></span><br><span class="line">  <span class="keyword">if</span>(lock_table.find(lid) != lock_table.end())</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="keyword">while</span>(lock_table[lid] == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_cond_wait(&amp;cond,&amp;mutex);</span><br><span class="line">      <span class="comment">//这个函数需要理解一下，它是带锁wait的吗？它可以带锁wait吗？</span></span><br><span class="line">    &#125;</span><br><span class="line">    lock_table[lid] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    lock_table.insert(<span class="built_in">std</span>::pair&lt;lock_protocol::<span class="keyword">lockid_t</span>,<span class="keyword">bool</span>&gt;(lid,<span class="literal">true</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock_protocol::status</span><br><span class="line">lock_server::release(<span class="keyword">int</span> clt, lock_protocol::<span class="keyword">lockid_t</span> lid, <span class="keyword">int</span> &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">  lock_protocol::status ret = lock_protocol::OK;</span><br><span class="line">        <span class="comment">// Your lab2 part2 code goes here</span></span><br><span class="line">  pthread_mutex_lock(&amp;mutex);</span><br><span class="line">  <span class="keyword">if</span>(lock_table.find(lid) != lock_table.end())</span><br><span class="line">  &#123;</span><br><span class="line">    lock_table[lid] = <span class="literal">false</span>;</span><br><span class="line">    pthread_cond_signal(&amp;cond);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> lock_protocol::NOENT;</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;mutex);<span class="comment">//对于互斥变量的操作一定要非常小心，不然容易造成饥饿或死锁。</span></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h3><p>&emsp;有了<em>acquire(lock_id)</em>&amp;_release(lock_id)_这两个函数，我们就可以对yfs_client.cc中的函数（读写磁盘）的函数加锁以实现并行操作了。需要注意的是，有调用关系的函数在加锁是要格外注意。考虑下面两个函数的加锁情况，会出现死锁吗？    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isFileExist</span><span class="params">(<span class="keyword">int</span> inode_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    acquire(inode_id);<span class="comment">//对inode的加锁，一般直接用inode number做id</span></span><br><span class="line">    Read(inode_id);</span><br><span class="line">    WriteDisk(inode_id);</span><br><span class="line">    release(inod_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFile</span><span class="params">(<span class="keyword">int</span> inode_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    acquire(inode_id);</span><br><span class="line">    isFileExist(inode_id);</span><br><span class="line">    release(inode_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;上面的代码明显是不可以的，readFile里已经对inode_id对应的锁加了锁，去查看该文件是否存在时又要这把锁的花，就已经被占用了，isFileExist()会等待readFile()放开这把锁，这在isFileExist()函数返回之前，明显是不可能发生的，这就造成了死锁。<br>&emsp;所以<strong>对于需要加锁的函数，应该尽量避免相互调用</strong>。因为这会是的加锁关系相当的复杂，要么不能保证互斥，要么会产生死锁。如果一定要存在调用关系的话，被调用的函数一般是不加锁的。当然你要仔细考量，保证互斥。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>计算机及软件</category>
        <category>计算机系统</category>
        <category>CSE</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>lab</tag>
        <tag>计算机系统工程</tag>
        <tag>CSE</tag>
        <tag>计算机系统</tag>
        <tag>RPC</tag>
        <tag>Lock</tag>
        <tag>并发</tag>
        <tag>分布式计算</tag>
      </tags>
  </entry>
</search>
