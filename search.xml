<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>斯坦福大学IOS7开发课程2</title>
    <url>/chinese/2021/03/15/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B2/</url>
    <content><![CDATA[<h1 id="斯坦福大学IOS7开发课程2"><a href="#斯坦福大学IOS7开发课程2" class="headerlink" title="斯坦福大学IOS7开发课程2"></a>斯坦福大学IOS7开发课程2</h1><p>这节课就着手开始实现”Card Matching Game”，纸牌匹配游戏。</p>
<p>具体来说就是实现涉及的各种类，以及XCode的简单使用。</p>
<a id="more"></a>

<h2 id="Card类"><a href="#Card类" class="headerlink" title="Card类"></a>Card类</h2><p>下面代码是<a href="https://zhang-tianxu.github.io/chinese/2021/03/15/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B1/">课程1</a>结束时的Card类，包括<code>Card.h</code>和<code>Card.m</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Card.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation&gt;</span><br><span class="line">@interface Card : NSObject</span><br><span class="line">@property (strong nonatomic) NSString *contents;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, getter&#x3D;isChosen) BOOL chosen;</span><br><span class="line">@property (nonatomic, getter&#x3D;isMatched) BOOL matched;</span><br><span class="line">- (int)match:(NSArray *)otherCards;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Card.m</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line">@interface Card()</span><br><span class="line">@end</span><br><span class="line">@implementation Card</span><br><span class="line"></span><br><span class="line">- (int)match:(NSArray *)otherCards</span><br><span class="line">&#123;</span><br><span class="line">  int score &#x3D; 0;</span><br><span class="line">  for(Card *card in otherCards) &#123;</span><br><span class="line">    if([card.contents isEqualToString:self.contents])</span><br><span class="line">      score &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="Deck类"><a href="#Deck类" class="headerlink" title="Deck类"></a>Deck类</h2><p>这节课首先添加另外一个类：整幅牌Deck，下面是上节课学的类的基本结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Deck : NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.m</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">@interface Deck()</span><br><span class="line">@end</span><br><span class="line">@implementation Deck</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>接下来为Deck类添加两个基础的方法:</p>
<ul>
<li>向Deck中添加牌的<code>addCard</code>，其中atTop表示是否将新的牌放在牌堆的顶部。</li>
<li>另一个是从Deck中随机抽取牌的<code>drawRandomCard</code>：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line"></span><br><span class="line">@interface Deck : NSObject</span><br><span class="line">- (void)addCard:(Card *)card atTop:(BOOL)atTop;</span><br><span class="line"></span><br><span class="line">- (Card *)drawRandomCard;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>如果希望<code>addCard</code>的参数<code>atTop</code>是<strong>可选参数</strong>，在Objective-C中唯一的方法就是声明一个新的函数，这个函数也叫<code>addCard</code>，但是没有参数<code>atTop</code>。这两个<code>addCard</code>是两个不同的函数，相互之间并没有关联。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line"></span><br><span class="line">@interface Deck : NSObject</span><br><span class="line">- (void)addCard:(Card *)card atTop:(BOOL)atTop;</span><br><span class="line">- (void)addCard:(Card *)card;</span><br><span class="line"></span><br><span class="line">- (Card *)drawRandomCard;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>为了存储牌堆中的牌，需要在私密API中添加一个属性，类型是可变数组<code>NSMutableArray</code>。mutable意味着可以向数组中添加或删除数据，而普通的<code>NSArray</code>是不能修改的，一旦被建立，不能添加数据也不能删除。</p>
<p><strong>在Objective-C中声明数组没办法指定数据类型。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.m</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">@interface Deck()</span><br><span class="line">@property (strong, nonatomic) NSMutableArray *cards; &#x2F;&#x2F; of Card</span><br><span class="line">@end</span><br><span class="line">@implementation Deck</span><br><span class="line">  </span><br><span class="line">- (void)addCard:(Card *)card atTop:(BOOL)atTop</span><br><span class="line">&#123;</span><br><span class="line">  if (atTop) &#123;</span><br><span class="line">    [self.cards insertObject:card atIndex:0];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    [self.cards addObject:card];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addCard:(Card *)card</span><br><span class="line">&#123;</span><br><span class="line">  [self addCard:card atTop:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Card *)drawRandomCard</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>根据上节课说到构建属性时自动生成的getter和setter，新建一个Deck类后，其所有的变量和属性都<strong><em>会被自动初始化为0/nil</em></strong>，属性<code>cards</code>是一个空指针，因此调用<code>addCard</code>时虽然不会导致程序的崩溃，但是也不能正常工作。</p>
<p>那么怎么解决这个问题呢？方法是重写属性的getter函数，在getter中添加一个判断结构，属性cards自动生成的getter是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSMutableArray *)cards</span><br><span class="line">&#123;</span><br><span class="line">  return _cards;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了在其中添加一个判断逻辑，需要手动重写这个getter：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.m</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">@interface Deck()</span><br><span class="line">@property (strong, nonatomic) NSMutableArray *cards; &#x2F;&#x2F; of Card</span><br><span class="line">@end</span><br><span class="line">@implementation Deck</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 为了处理cards为空指针的情况，手动重写getter</span><br><span class="line">- (NSMutableArray *)cards</span><br><span class="line">&#123;</span><br><span class="line">  if(!_cards) _cards &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">  return _cards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addCard:(Card *)card atTop:(BOOL)atTop</span><br><span class="line">&#123;</span><br><span class="line">  if (atTop) &#123;</span><br><span class="line">    [self.cards insertObject:card atIndex:0];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    [self.cards addObject:card];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addCard:(Card *)card</span><br><span class="line">&#123;</span><br><span class="line">  [self addCard:card atTop:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Card *)drawRandomCard</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>接下来实现<code>drawRandomCard</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.m</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">@interface Deck()</span><br><span class="line">@property (strong, nonatomic) NSMutableArray *cards; &#x2F;&#x2F; of Card</span><br><span class="line">@end</span><br><span class="line">@implementation Deck</span><br><span class="line"></span><br><span class="line">- (  NSMutableArray *)cards</span><br><span class="line">&#123;</span><br><span class="line">  if(!_cards) _cards &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">  return _cards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addCard:(Card *)card atTop:(BOOL)atTop</span><br><span class="line">&#123;</span><br><span class="line">  if (atTop) &#123;</span><br><span class="line">    [self.cards insertObject:card atIndex:0];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    [self.cards addObject:card];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addCard:(Card *)card</span><br><span class="line">&#123;</span><br><span class="line">  [self addCard:card atTop:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Card *)drawRandomCard</span><br><span class="line">&#123;</span><br><span class="line">  Card *randomCard &#x3D; nil;</span><br><span class="line">  </span><br><span class="line">  if([self.cards count]) &#123;</span><br><span class="line">    unsigned index &#x3D; arc4random() % [self.cards count];</span><br><span class="line">    randomCard &#x3D; self.cards[index];</span><br><span class="line">    [self.cards removeObjectAtIndex:index];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return randomCard;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>至此，Deck类已经完成。</p>
<h2 id="PlayingCard类"><a href="#PlayingCard类" class="headerlink" title="PlayingCard类"></a>PlayingCard类</h2><p>接下来再添加一个类：<code>PlayingCard</code>，同样的，基本结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.h</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line">@interface PlayingCard : Card &#x2F;&#x2F; 终于有个类的父类不是NSObject了</span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>给类添加两个属性<code>suit</code>和<code>rank</code>，前者表示牌的花色“桃（hearts）”、“（方片）diamons”、“（梅花）clubs”，后者表示1到13。另外在<code>.m</code>文件中，重写父类属性content的getter。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.h</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line">@interface PlayingCard : Card</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) NSString *suit;</span><br><span class="line">@property (nonatomic) NSUInteger rank;</span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  return [NSString stringWithFormat:@&quot;%d%@&quot;,self.rank, self.suit];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>注意到，字符串前面有个<code>@</code>，这<strong><em>表示把字符串变成一个字符串类</em></strong>。其中<code>%@</code>表示一个对象，当然可以是字符串。</p>
<p>重写父类属性contents的getter之后，获取contents内容会返回“数字 + 花色”，比如“3红桃”、“1梅花”、“13方片”等。但是在纸牌中，我们一般会把1说成A，11说成J等……，为了符合这个习惯，上面的contents重写可以改成下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  NSArray *rankStrings &#x3D; @[@&quot;?&quot;,@&quot;A&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;10&quot;,@&quot;J&quot;,@&quot;Q&quot;,@&quot;K&quot;];</span><br><span class="line">  &#x2F;&#x2F; 将0-13表示为?,1,2,...,J,Q,K</span><br><span class="line">  return [rankStrings[self.rank] stringByAppendingString:self.suit];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>将rank的0设置为”？“是因为objective-C默认将rank初始化为0，”？“表示这是未知的，没有经过设置的。那如果花色没经过设置也会显示”？“就更好了，解决方法也是重写suit属性的getter函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  NSArray *rankStrings &#x3D; @[@&quot;?&quot;,@&quot;A&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;10&quot;,@&quot;J&quot;,@&quot;Q&quot;,@&quot;K&quot;];</span><br><span class="line">  &#x2F;&#x2F; 将0-13表示为?,1,2,...,J,Q,K</span><br><span class="line">  return [rankStrings[self.rank] stringByAppendingString:self.suit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  return _suit?_suit:@&quot;?&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>suit的选择应该只有四种，为了防止suit被设置为其他值，还要重写suit属性的setter：<code>setSuit</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  NSArray *rankStrings &#x3D; @[@&quot;?&quot;,@&quot;A&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;10&quot;,@&quot;J&quot;,@&quot;Q&quot;,@&quot;K&quot;];</span><br><span class="line">  &#x2F;&#x2F; 将0-13表示为?,1,2,...,J,Q,K</span><br><span class="line">  return [rankStrings[self.rank] stringByAppendingString:self.suit];</span><br><span class="line">&#125;</span><br><span class="line">@synthesize suit &#x3D; _suit;</span><br><span class="line">&#x2F;&#x2F; 因为重构了suit的getter和setter，所以要手写@synthesize</span><br><span class="line">- (void)setSuit:(NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  if([@[@&quot;♥️&quot;,@&quot;♦️&quot;,@&quot;♠️&quot;,@&quot;♣️&quot;] containsObject:suit]) &#123;</span><br><span class="line">    _suit &#x3D; suit;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  return _suit?_suit:@&quot;?&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>值得注意的是，<code>setSuit</code>中的第一个<code>@</code>表示创建新的数组，在这里，每次判断都会新建这个数组。为了性能和代码简介，可以新建函数来判断setter收到的suit是否有效。实际上，这种改变对性能的提升是极其有限的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  NSArray *rankStrings &#x3D; @[@&quot;?&quot;,@&quot;A&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;10&quot;,@&quot;J&quot;,@&quot;Q&quot;,@&quot;K&quot;];</span><br><span class="line">  &#x2F;&#x2F; 将0-13表示为?,1,2,...,J,Q,K</span><br><span class="line">  return [rankStrings[self.rank] stringByAppendingString:self.suit];</span><br><span class="line">&#125;</span><br><span class="line">@synthesize suit &#x3D; _suit;</span><br><span class="line">&#x2F;&#x2F; 因为重构了suit的getter和setter，所以要手写@synthesize</span><br><span class="line"></span><br><span class="line">+ (NSArray *)validSuits</span><br><span class="line">&#123;</span><br><span class="line">  return @[@&quot;♥️&quot;,@&quot;♦️&quot;,@&quot;♠️&quot;,@&quot;♣️&quot;];</span><br><span class="line">&#125;</span><br><span class="line">- (void)setSuit:(NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  if([[PlayingCard validSuits] containsObject:suit]) &#123;</span><br><span class="line">    &#x2F;&#x2F; 类的函数的调用方法。</span><br><span class="line">    _suit &#x3D; suit;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  return _suit?_suit:@&quot;?&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>这里在函数实现前面第一次出现了<code>+</code>符号，这个符号表示这个函数是<strong>类的函数</strong>（而不是对象的函数）。</p>
<p><strong><em>一般只在两种情况下使用类的函数：</em></strong></p>
<ol>
<li><p>工具函数（utility method），比如这里的<code>validSuits</code>。</p>
</li>
<li><p>创建类的函数，比如<code>stringWithFormat</code>。</p>
<p>对rank属性做同样的检查和优化，并添加一个公开API<code>maxRank</code>返回rank的最大值，比如现在是13。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.h</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line">@interface PlayingCard : Card</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) NSString *suit;</span><br><span class="line">@property (nonatomic) NSUInteger rank;</span><br><span class="line"></span><br><span class="line">+ (NSArray *)validSuits;</span><br><span class="line">+ (NSUInteger)maxRank;</span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  NSArray *rankStrings &#x3D; [PlayingCard rankStrings];</span><br><span class="line">  &#x2F;&#x2F; 将0-13表示为?,1,2,...,J,Q,K</span><br><span class="line">  return [rankStrings[self.rank] stringByAppendingString:self.suit];</span><br><span class="line">&#125;</span><br><span class="line">@synthesize suit &#x3D; _suit;</span><br><span class="line">&#x2F;&#x2F; 因为重构了suit的getter和setter，所以要手写@synthesize</span><br><span class="line"></span><br><span class="line">+ (NSArray *)validSuits</span><br><span class="line">&#123;</span><br><span class="line">  return @[@&quot;♥️&quot;,@&quot;♦️&quot;,@&quot;♠️&quot;,@&quot;♣️&quot;];</span><br><span class="line">&#125;</span><br><span class="line">- (void)setSuit:(NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  if([[PlayingCard validSuits] containsObject:suit]) &#123;</span><br><span class="line">    &#x2F;&#x2F; 类的函数的调用方法。</span><br><span class="line">    _suit &#x3D; suit;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  return _suit?_suit:@&quot;?&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSArray *)rankStrings</span><br><span class="line">&#123;</span><br><span class="line">  return @[@&quot;?&quot;,@&quot;A&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;10&quot;,@&quot;J&quot;,@&quot;Q&quot;,@&quot;K&quot;];</span><br><span class="line">&#125;</span><br><span class="line">+ (NSUInteger)maxRank</span><br><span class="line">&#123;</span><br><span class="line">  return [[self rankStrings] count]-1;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setRank:(NSUInteger)rank</span><br><span class="line">&#123;</span><br><span class="line">  if(rank &lt;&#x3D; [PlayingCard maxRank]) &#123;</span><br><span class="line">    _rank &#x3D; rank;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="PlayingCardDeck类"><a href="#PlayingCardDeck类" class="headerlink" title="PlayingCardDeck类"></a>PlayingCardDeck类</h2><p>接下来可以开始玩牌了，创建一个新的类<code>PlayingCardDeck</code>，继承自<code>Deck</code>类，但是需要<strong>重写构造函数</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCardDeck.h</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line"></span><br><span class="line">@interface PlayingCardDeck : Deck</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCardDeck.m</span><br><span class="line">#import &quot;PlayingCardDeck.h&quot;</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation PlayingCardDeck</span><br><span class="line">- (instancetype)init &#x2F;&#x2F; instancetype类只在init中使用</span><br><span class="line">&#123;</span><br><span class="line">  self &#x3D; [super init];</span><br><span class="line">  &#x2F;&#x2F; 调用父类的构造函数</span><br><span class="line">  if(self) &#123; </span><br><span class="line">    &#x2F;&#x2F; 父类正常完成构造，继续子类的构造函数</span><br><span class="line">    &#x2F;&#x2F; 如果父类无法完成构造，将不执行子类的构造代码</span><br><span class="line">    for (NSString *suit in [PlayingCard validSuits]) &#123;</span><br><span class="line">      for (NSUInteger rank &#x3D; 1; rank &lt;&#x3D; [PlayingCard maxRank]; rank++) &#123;</span><br><span class="line">        PlayingCard *card &#x3D; [[PlayingCard allo] init];</span><br><span class="line">        card.rank &#x3D; rank;</span><br><span class="line">        card.suit &#x3D; suit;</span><br><span class="line">        [self addCard:card];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="XCode的简单使用"><a href="#XCode的简单使用" class="headerlink" title="XCode的简单使用"></a>XCode的简单使用</h2><p>课程剩余的部分就是以纸牌游戏为例，简单介绍XCode的使用，开发一个简单的App，App内容是显示纸牌，点击纸牌将其翻转。</p>
<p>由于课程介绍的是XCode 5，笔者记笔记的时候已经是XCode 12.4了，有了不小的变化，参考笔者另一篇笔记（<a href="https://zhang-tianxu.github.io/chinese/2021/03/09/Objective-C-IOS%E5%BC%80%E5%8F%91%E4%B9%8BHelloWorld/">Objective-C IOS开发之HelloWorld</a>），应该也不难完成，就不再具体介绍实现了。</p>
<p>相较于HelloWorld这个App，课程中实现的App另外涉及了以下知识点：</p>
<ul>
<li><p>图像添加</p>
<p>直接将图片拖到<code>Assets.xcassets</code>文件夹中</p>
</li>
<li><p>button背景图片的设置</p>
<p>点击button，在属性中点击<code>Background</code>下拉菜单，就会显示上一步添加的图片选项，以及一些原始icon。</p>
</li>
<li><p>Action中的sender其实就是触发事件的View对象</p>
</li>
<li><p>类的添加</p>
<p>添加类的方法，XCode 12中其实就是新建<code>Cocoa Touch Class</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发入门</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福大学IOS7开发课程1</title>
    <url>/chinese/2021/03/15/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B1/</url>
    <content><![CDATA[<h1 id="斯坦福大学IOS7开发课程1"><a href="#斯坦福大学IOS7开发课程1" class="headerlink" title="斯坦福大学IOS7开发课程1"></a>斯坦福大学IOS7开发课程1</h1><p>IOS7开发课程讲了如何利用Objective-C语言开发IOS App，而且涉及到很多必须的基础知识，非常值得学习。</p>
<p>课程1讲了一些关于课程安排和作业的事情，自学就不需要了，只选取下面三个<strong>知识点：</strong></p>
<ul>
<li>IOS里有什么</li>
<li>MVC开发模型</li>
<li>Objective-C</li>
</ul>
<a id="more"></a>

<h2 id="IOS里有什么"><a href="#IOS里有什么" class="headerlink" title="IOS里有什么"></a>IOS里有什么</h2><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gok87jp5hnj20lq15ctky.jpg" class="inIOS" width="300" height="700" title="IOS里有什么" alt="加载失败">

<p>总的来说，可以将IOS涉及的组件分为4组或者说4层：</p>
<ul>
<li><p>Core OS</p>
<p>最接近硬件的一层，其实就是Unix操作系统，Unix内核中有的功能，Core OS都有，比如：</p>
<ul>
<li>OSX Kernel</li>
<li>Power Management</li>
<li>Sockets</li>
<li>File System</li>
</ul>
<p>等等……</p>
</li>
<li><p>Core Services</p>
<p>基于Core OS的面向对象层。</p>
<p>Core OS层的API几乎都是用C写的，为了以<em>面向对象</em>的方式编程，加入了Core Services层。这一层包括：</p>
<ul>
<li>Collections</li>
<li>File Access</li>
<li>Networking</li>
<li>Threading</li>
<li>SQLite</li>
<li>Core Location</li>
</ul>
<p>等等</p>
</li>
<li><p>Media</p>
<p>用于展现多媒体，包括视频、图片、声音、文件等等，是非常重要的一层。</p>
</li>
<li><p>Cocoa Touch</p>
<p>Cocoa的API起源于Mac OS X，已经有三十年左右的历史了，是UI层。对IOS开发者来说是需要花比较多时间来学习的一层。这一层可以用来构建按键、滑块、开关、文字输入、动画等等。包括：</p>
<ul>
<li>Multi-Touch</li>
<li>Alerts</li>
<li>Web View</li>
<li>Camera</li>
<li>Controls</li>
</ul>
<p>等等。</p>
</li>
</ul>
<h2 id="MVC开发模型"><a href="#MVC开发模型" class="headerlink" title="MVC开发模型"></a>MVC开发模型</h2><p>Model View Controller是一种用于组织应用程序中所有类的策略，将每个类分成Model 阵营、Controller 阵营或者View 阵营中的额一个。</p>
<p>Model用来描述你的程序是什么，以纸牌游戏为例，纸牌、牌桌甚至玩牌的规则都是独立于UI的，应该放在Model阵营中。至于纸牌是如何展示在屏幕上的，是由Controller负责的，Controller负责如何展现Model，以及展现Model的动画等。View是Controller的下属，是Controller用于构建UI的组件。</p>
<p>View是通用的，比如按键、开关等，是所有程序通用的，而Contrller是针对程序设计的，Model则是完全独立于UI的。</p>
<h3 id="MVC模型中三个阵营之间的通信"><a href="#MVC模型中三个阵营之间的通信" class="headerlink" title="MVC模型中三个阵营之间的通信"></a>MVC模型中三个阵营之间的通信</h3><h4 id="Controller-gt-Model"><a href="#Controller-gt-Model" class="headerlink" title="Controller -&gt; Model"></a>Controller -&gt; Model</h4><p>  Controller了解Model的一切，并且可以任意给Model发消息。</p>
<h4 id="Controller-gt-View"><a href="#Controller-gt-View" class="headerlink" title="Controller -&gt; View"></a>Controller -&gt; View</h4><p>  Controller也可以任意给View发送消息，如果Controller有个property指向View，把这个property成为<strong><em>outlet</em></strong>。</p>
<h4 id="Model-lt-gt-View"><a href="#Model-lt-gt-View" class="headerlink" title="Model &lt;-&gt; View"></a>Model &lt;-&gt; View</h4><p>  永远<strong>不要</strong>让Model和View之间直接通信。因为Model应该是完全独立于UI的，所以不应该给View发消息，而View是通用的，所以也不应该发消息给Model。</p>
<h4 id="View-gt-Controller"><a href="#View-gt-Controller" class="headerlink" title="View -&gt; Controller"></a>View -&gt; Controller</h4><p>View能向Controller发消息么？可以是可以，但是因为View是通用的，它对Controller并不了解，所以他们只能通过约定好的形式向Controller发送消息，有两种方式：</p>
<ul>
<li><p>target action</p>
<p>Controller在内部建立一个target，并给View一个action。当View执行一些操作，比如按键被按下的时候，view会向Controller内的target发射action，这种方式下，View可以不了解Controller，只需要知道某些操作被执行时向Controller发送action。</p>
</li>
<li><p>delegate</p>
<p>target action方式没办法处理非常复杂的通信。比如在一个滚动框中，用户按下手指准备滚动，需要让Controller知道用户要滚动了。因为是否允许用户的滚动请求，View是不知道的，所以需要让Controller代理其执行。有一种特殊的delegate，称为data source。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gok7sf8e9mj20xm0jadhu.jpg" alt="image-20210314123540992"></p>
</li>
</ul>
<p>View并不拥有它们展示的数据</p>
<h4 id="Model-gt-Controller"><a href="#Model-gt-Controller" class="headerlink" title="Model -&gt; Controller"></a>Model -&gt; Controller</h4><p>那么model能向Controller发送消息么？</p>
<p>model应该是完全独立于UI的，所以不能直接向Controller发送消息。但有的时候确实有这样的需求，比如Model中数据变化了，需要告诉Controller，这时可以通过广播的方式，向所有感兴趣的人发送消息，其中当然可以包括Controller</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gok7tedpf9j20wc0jstw6.jpg" alt="image-20210314123951433"></p>
<h3 id="MVCs模型"><a href="#MVCs模型" class="headerlink" title="MVCs模型"></a>MVCs模型</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gok7tphhwkj211q0mg4qp.jpg" alt="image-20210314124445333"></p>
<h2 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C"></a>Objective-C</h2><p>Objective-C的一些基础语法可以到<a href="https://www.yiibai.com/objective_c/" target="_blank" rel="noopener">易百Objective-C教程</a>学习，本课程中只是讲了一些和C/C++等语言不通的地方。和常见的编程语言C++或java相比，Objective-C有个重要的概念“Properties”，在Objective-C中一般不直接读写实例的变量，properties是Objective-C中读写实例的变量的方法，一般由getter函数和setter函数组成。</p>
<p>在Objective-C中，每个类由一个<code>.h</code>头文件的头文件和一个<code>.m</code>的实现文件。其中，<code>.h</code>中是公开的API，<code>.m</code>中是私密API和具体的实现。</p>
<p>在<code>.h</code>中声明类时，必须给定类的父类，其中<code>NSObject</code>是几乎所有类的父类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.h</span><br><span class="line">@interface Test: NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>由于使用了<code>NSObject</code>作为父类，所以需要引入这个类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.h</span><br><span class="line">#import &lt;Foundation&#x2F;NSObject.h&gt;</span><br><span class="line">@interface Test: NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在IOS中一般不会只引进这个类，而是将整个<code>Foundation</code>框架引进来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">@interface Test: NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在<code>.m</code>实现文件中当然要引入头文件，<code>@implementation</code>表示类的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.m</span><br><span class="line">#import &quot;Test.h&quot;</span><br><span class="line">@implementation Test</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>同时<code>.m</code>中可以添加一些私密API</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.m</span><br><span class="line">#import &quot;Test.h&quot;</span><br><span class="line">@interface Test()&#x2F;&#x2F;添加私密API</span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">@implementation Test</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>下面介绍Objective-C的Properties概念，通过<code>@property</code>在<code>.h</code>中添加一个属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">@interface Test: NSObject</span><br><span class="line">  @property (strong nonatomic) NSString *name;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>下面详细说一下<code>property</code>这行代码的构成：</p>
<p><strong>首先</strong>是关键字<code>(strong)</code>。在Objective-C中，所有的对象都被放在堆中，通过指针使用它们。通过这种方式，Objective-C不需要编程人员手动分配和释放内存地址，那么Objective-C如何知道何时释放内存呢？这就是属性声明中<code>(stong)</code>的作用，相应的还有<code>(weak)</code>。在内存管理时，只要有任意一个<code>strong</code>指针指向内存，内存就会被保留，最有一个<code>strong</code>指针被删除时，该地址会<strong>立即</strong>被回收，此时如果还有<code>weak</code>指针指向改地址，<code>weak</code>指针会被置为空。</p>
<p>对于元类型（int、bool等）的属性，不需要声明<code>strong</code>或<code>weak</code>，因为这种类型的属性并不存储在堆中，不需要内存管理。</p>
<p>与其他语言不通，在Objective-C中，引用空指针并不会导致程序崩溃，在Objective-C中你甚至可以给空指针发送数据，也不会导致程序崩溃，当然你给空指针发数据，虽然不会导致程序崩溃，也不会执行任何代码，如果发送的消息需要返回，返回值会被设为0。</p>
<p><strong>然后</strong>是关键字<code>nonatomic</code>，非原子操作。这个关键字的意思是属性的getter和setter<strong>不是线程安全的</strong>，在IOS中一般并不需要属性是线程安全的。在声明属性的同时，Objective-C会自动创建getter和setter方法。如果添加了<code>nonatomic</code>关键字，自动生成的代码是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@synthesize name &#x3D; _name;</span><br><span class="line">- (NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">  return _name;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">  _name &#x3D; name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>@synthesize</code>表示<code>_name</code>是<code>name</code>的别名。这些代码并不会显示出来，但可以直接使用。使用setter和getter的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myTest.name &#x3D; @&quot;Hello World&quot;;</span><br><span class="line">NSLog(@&quot;%@&quot;,myTest.name);</span><br></pre></td></tr></table></figure>

<p>当然也可以用中括号的方式调用，但建议使用上面的方式调用setter和getter。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[myTest setName:@&quot;Hello World&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[myTest name]);</span><br></pre></td></tr></table></figure>

<p>如果不添加<code>nonatomic</code>关键字，自动生成的代码会复杂很多，因为需要添加锁。为了简单，一般都会加上<code>nonatomic</code>关键字。</p>
<p><strong>另外</strong>，如果想要重命名属性的getter和setter，可以通过一下方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, getter &#x3D; getName, setter &#x3D; setName) NSString name;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发入门</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C IOS开发之SQLite数据库</title>
    <url>/chinese/2021/03/10/Objective-C-IOS%E5%BC%80%E5%8F%91%E4%B9%8BSQLite%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>IDE: XCode Version 12.4 (12D4e)</p>
<p>参考<a href="https://www.tutorialspoint.com/ios/ios_sqlite_database.htm" target="_blank" rel="noopener">IOS开发教程</a></p>
<h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><a id="more"></a>

<ol>
<li><p>Xcode创建一个APP</p>
</li>
<li><p>选中项目文件，选中TARGETS，然后在框架（frameworks, Libraries, and Embedded Content）中添加<strong>libsqlite3.tbd</strong>（libsqlite3.0.tbd也一样）</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof54maa10j314p0u0af4.jpg" class="addSQLiteLibImg" width="500" height="600" title="添加SQLite库" alt="加载失败">
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof54tkttyj30ng0qon0f.jpg" class="addSQLiteLibImg2" width="500" height="300" title="添加SQLite库2" alt="加载失败">
</li>
<li><p>新建Objective-C类（File-&gt;New-&gt;File）选择Cocoa Touch Class，点击Next，Subclass of选择NSObject，language选Objective-C。</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof56z2pxuj30u00xm4ee.jpg" class="addObjcClassImg" width="800" height="300" title="添加Objective-C类" alt="加载失败">
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof57eshyqj315i0te0y6.jpg" class="addObjcClassImg2" width="400" height="300" title="添加Objective-C类2" alt="加载失败">
</li>
<li><p>将类的名字命名为DBManager，点击Next创建</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof57v7yg2j31600u0gpo.jpg" class="addDBManager" width="400" height="300" title="创建DBManager" alt="加载失败">
</li>
<li><p>项目中会增加<code>DBManager.h</code>和<code>DBManager.m</code>两个文件，其代码是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;DBManager.h</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#import &lt;sqlite3.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface DBManager : NSObject &#123;</span><br><span class="line">    NSString *databasePath;</span><br><span class="line">&#125;</span><br><span class="line">+(DBManager*)getSharedInstance;</span><br><span class="line">-(BOOL)createDB;</span><br><span class="line">-(BOOL) saveData:(NSString*)registerNumber name:(NSString*)name department:(NSString*)department year:(NSString*)year;</span><br><span class="line">-(NSArray*) findByRegisterNumber:(NSString*)registerNumber;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;DBManager.m</span><br><span class="line"></span><br><span class="line">#import &quot;DBManager.h&quot;</span><br><span class="line"></span><br><span class="line">static DBManager *sharedInstance &#x3D; nil;</span><br><span class="line">static sqlite3 *database &#x3D; nil;</span><br><span class="line">static sqlite3_stmt *statement&#x3D; nil;</span><br><span class="line"></span><br><span class="line">@implementation DBManager</span><br><span class="line"></span><br><span class="line">+(DBManager*)getSharedInstance&#123;</span><br><span class="line">    if(!sharedInstance) &#123;</span><br><span class="line">        sharedInstance &#x3D; [[super allocWithZone:NULL]init];</span><br><span class="line">        [sharedInstance createDB];</span><br><span class="line">    &#125;</span><br><span class="line">    return sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(BOOL)createDB &#123;</span><br><span class="line">    NSString *docsDir;</span><br><span class="line">    NSArray *dirPaths;</span><br><span class="line">    &#x2F;&#x2F; get the documents directory</span><br><span class="line">    dirPaths &#x3D; NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">    docsDir &#x3D; dirPaths[0];</span><br><span class="line">    &#x2F;&#x2F; build the path to the database file</span><br><span class="line">    databasePath &#x3D; [[NSString alloc] initWithString:[docsDir stringByAppendingPathComponent:@&quot;student.db&quot;]];</span><br><span class="line">    BOOL isSuccess &#x3D; YES;</span><br><span class="line">    NSFileManager* filemgr &#x3D; [NSFileManager defaultManager];</span><br><span class="line">    </span><br><span class="line">    if([filemgr fileExistsAtPath:databasePath] !&#x3D; NO) &#123;</span><br><span class="line">        const char *dbpath &#x3D; [databasePath UTF8String];</span><br><span class="line">        if(sqlite3_open(dbpath, &amp;database) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">            char *errMsg;</span><br><span class="line">            const char *sql_stmt &#x3D;</span><br><span class="line">            &quot;create table if not exists studentsDetail (regno integer primary key, name text, department text, year text)&quot;;</span><br><span class="line">            if(sqlite3_exec(database, sql_stmt, NULL, NULL, &amp;errMsg) !&#x3D; SQLITE_OK) &#123;</span><br><span class="line">                isSuccess &#x3D; NO;</span><br><span class="line">                NSLog(@&quot;Fail to create table&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sqlite3_close(database);</span><br><span class="line">            return isSuccess;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            isSuccess &#x3D; NO;</span><br><span class="line">            NSLog(@&quot;Fail to open&#x2F;create database&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return isSuccess;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(BOOL)saveData:(NSString *)registerNumber name:(NSString *)name department:(NSString *)department year:(NSString *)year; &#123;</span><br><span class="line">    const char *dbpath &#x3D; [databasePath UTF8String];</span><br><span class="line">    </span><br><span class="line">    if(sqlite3_open(dbpath, &amp;database) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">        NSString *insertSQL &#x3D; [NSString stringWithFormat:@&quot;insert into studentsDetail (regno, name, department, year) values (\&quot;%ld\&quot;,\&quot;%@\&quot;,\&quot;%@\&quot;,\&quot;%@\&quot;)&quot;,(long)[registerNumber integerValue], name, department, year];</span><br><span class="line">        const char *insert_stmt &#x3D; [insertSQL UTF8String];</span><br><span class="line">        if(sqlite3_prepare_v2(database, insert_stmt, -1, &amp;statement, NULL) !&#x3D; SQLITE_OK) &#123;</span><br><span class="line">            NSLog(@&quot;Prepare failure:%s&quot;,sqlite3_errmsg(database));</span><br><span class="line">        &#125;</span><br><span class="line">        if(sqlite3_step(statement) &#x3D;&#x3D; SQLITE_DONE) &#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    sqlite3_reset(statement);</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSArray*)findByRegisterNumber:(NSString *)registerNumber&#123;</span><br><span class="line">    const char *dbpath &#x3D; [databasePath UTF8String];</span><br><span class="line">    if(sqlite3_open(dbpath, &amp;database) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">        NSString *querySQL &#x3D; [NSString stringWithFormat:@&quot;select name, department, year from studentsDetail where regno &#x3D; \&quot;%@\&quot;&quot;,registerNumber];</span><br><span class="line">        const char *query_stmt &#x3D; [querySQL UTF8String];</span><br><span class="line">        NSMutableArray *resultArray &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">        if(sqlite3_prepare_v2(database, query_stmt, -1, &amp;statement, NULL) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">            if(sqlite3_step(statement) &#x3D;&#x3D; SQLITE_ROW) &#123;</span><br><span class="line">                NSString *name &#x3D; [[NSString alloc] initWithUTF8String:(const char *)sqlite3_column_text(statement, 0)];</span><br><span class="line">                [resultArray addObject:name];</span><br><span class="line">                </span><br><span class="line">                NSString *department &#x3D; [[NSString alloc] initWithUTF8String:(const char*)sqlite3_column_text(statement, 1)];</span><br><span class="line">                [resultArray addObject:department];</span><br><span class="line">                </span><br><span class="line">                NSString *year &#x3D; [[NSString alloc] initWithUTF8String:(const char*)sqlite3_column_text(statement, 2)];</span><br><span class="line">                [resultArray addObject:year];</span><br><span class="line">                return resultArray;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                NSLog(@&quot;Not found&quot;);</span><br><span class="line">                return nil;</span><br><span class="line">            &#125;</span><br><span class="line">            sqlite3_reset(statement);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>Main.storyboard</code>中添加如下组件：</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof3hvfqacj30ga0gsgma.jpg" class="result" width="800" height="300" title="效果" alt="加载失败">
</li>
<li><p>为所有的输入框新建<code>Referencing Outlet</code></p>
</li>
<li><p>为两个button创建<code>Touch Up Inside</code>事件</p>
</li>
<li><p>创建完之后，<code>ViewController.h</code>自动被填写为:</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line">#import &quot;DBManager.h&quot;&#x2F;&#x2F;这个是手动添加的</span><br><span class="line"></span><br><span class="line">@interface ViewController : UIViewController</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *findByRegisterNumberTextField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *regNoTextField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *nameTextField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *departmentTextField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *yearTextField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UIScrollView *myScrollView;</span><br><span class="line"></span><br><span class="line">- (IBAction)findData:(id)sender;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UIButton *saveData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>ViewController.m</code>中实现<code>findData</code>和<code>saveData</code></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  ViewController.m</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)saveData:(id)sender &#123;</span><br><span class="line">    BOOL success &#x3D; NO;</span><br><span class="line">    NSString *alertString &#x3D; @&quot;Data Insertion failed&quot;;</span><br><span class="line">    if(_regNoTextField.text.length &gt; 0 &amp;&amp; _nameTextField.text.length &gt; 0 &amp;&amp; _departmentTextField.text.length &gt; 0 &amp;&amp; _yearTextField.text.length &gt; 0) &#123;</span><br><span class="line">        success &#x3D; [[DBManager getSharedInstance] saveData:_regNoTextField.text name:_nameTextField.text department:_departmentTextField.text year:_yearTextField.text];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        alertString &#x3D; @&quot;Enter all fields&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if(success &#x3D;&#x3D; NO) &#123;</span><br><span class="line">        UIAlertController *alert &#x3D; [UIAlertController alertControllerWithTitle:alertString message:nil preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">        UIAlertAction *okAction &#x3D; [UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">            NSLog(@&quot;点击了OK&quot;);</span><br><span class="line">        &#125;];</span><br><span class="line">        [alert addAction:okAction];</span><br><span class="line">        [self presentViewController:alert animated:YES completion:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)findData:(id)sender &#123;</span><br><span class="line">    NSArray *data &#x3D; [[DBManager getSharedInstance] findByRegisterNumber:_findByRegisterNumberTextField.text];</span><br><span class="line">    if(data &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        UIAlertController *alert &#x3D; [UIAlertController alertControllerWithTitle:@&quot;Data not found&quot; message:nil preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">        UIAlertAction *okAction &#x3D; [UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        &#125;];</span><br><span class="line">        [alert addAction:okAction];</span><br><span class="line">        [self presentViewController:alert animated:YES completion:nil];</span><br><span class="line">        _regNoTextField.text &#x3D; @&quot;&quot;;</span><br><span class="line">        _nameTextField.text &#x3D;@&quot;&quot;;</span><br><span class="line">        _departmentTextField.text &#x3D; @&quot;&quot;;</span><br><span class="line">        _yearTextField.text &#x3D;@&quot;&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        _regNoTextField.text &#x3D; _findByRegisterNumberTextField.text;</span><br><span class="line">        _nameTextField.text &#x3D;[data objectAtIndex:0];</span><br><span class="line">        _departmentTextField.text &#x3D;[data objectAtIndex:1];;</span><br><span class="line">        _yearTextField.text &#x3D;[data objectAtIndex:2];;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mart - Text field delegate</span><br><span class="line">-(void)textFieldDidBeginEditing:(UITextField *)textField &#123;</span><br><span class="line">    [_myScrollView setFrame:CGRectMake(10,50,300,200)];</span><br><span class="line">    [_myScrollView setContentSize:CGSizeMake(300, 350)];</span><br><span class="line">&#125;</span><br><span class="line">-(void)textFieldDidEndEditing:(UITextField *)textField &#123;</span><br><span class="line">    [_myScrollView setFrame:CGRectMake(10, 50, 300, 350)];</span><br><span class="line">&#125;</span><br><span class="line">-(BOOL) textFieldShouldReturn:(UITextField *)textField &#123;</span><br><span class="line">    [textField resignFirstResponder];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>至此，可以通过save按钮保存数据，find按钮可以查找数据，并显示在各自输入框中</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li><p><code>libsqlite3.dylib</code>vs<code>libsqlite3.tbd</code>vs<code>libsqlite3.0.tbd</code></p>
<p><code>.tbd</code> 在Xcode7后替代了<code>.dylib</code> 。而<code>libsqlite3.tbd</code>只是<code>libsqlite3.0.tbd</code>的链接，也就是两者是一摸一样的，引入任意一个的效果都是一样的。</p>
</li>
<li><p>sqlite3的使用</p>
<ol>
<li><p>创建数据库</p>
<p>SQLite的数据库就是一个文件，创建数据库也就是创建一个文件。</p>
</li>
<li><p>打开数据库</p>
<p>打开数据库其实就是用<code>sqlite3_open</code>函数打开一个文件。</p>
</li>
<li><p>执行SQL命令</p>
<p>SQLite中执行SQL命令有两种方式：</p>
<ul>
<li><code>sqlite3_exec()</code></li>
<li><code>sqlite3_prepare_v2()</code>+<code>sqlite3_step()</code></li>
</ul>
<p>两者的区别可以看<a href="https://stackoverflow.com/questions/27383724/sqlite3-prepare-v2-sqlite3-exec" target="_blank" rel="noopener">stackoverflow</a>。</p>
</li>
</ol>
</li>
<li><p>弹出框的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIAlertController *alert &#x3D; [UIAlertController alertControllerWithTitle:@&quot;警告的Title&quot; message:@&quot;警告的消息&quot;</span><br><span class="line">                           preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line"></span><br><span class="line">UIAlertAction *okAction &#x3D; [UIAlertAction actionWithTitle:@&quot;OK&quot;</span><br><span class="line">                           style:UIAlertActionStyleDefault</span><br><span class="line">                           handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">                             NSLog(@&quot;点击了OK&quot;);</span><br><span class="line">                           &#125;];</span><br><span class="line">UIAlertAction *cancelAction &#x3D; [UIAlertAction actionWithTitle:@&quot;Cancel&quot;</span><br><span class="line">                               style:UIAlertActionStyleCancel</span><br><span class="line">                               handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">                                 NSLog(@&quot;点击了Cancel&quot;);</span><br><span class="line">                               &#125;];</span><br><span class="line">[alert addAction:okAction];</span><br><span class="line">[alertController addAction:cancelAction];</span><br><span class="line"></span><br><span class="line">[self presentViewController:alert animated:YES completion:nil];</span><br></pre></td></tr></table></figure>


</li>
</ol>
]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发入门</tag>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C IOS开发之HelloWorld</title>
    <url>/chinese/2021/03/09/Objective-C-IOS%E5%BC%80%E5%8F%91%E4%B9%8BHelloWorld/</url>
    <content><![CDATA[<p>IDE: XCode Version 12.4 (12D4e)</p>
<a id="more"></a>
<ol>
<li>新建App</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofu3u9dcoj314y0ten0w.jpg" alt="image-20210311120542111"></p>
<ol start="2">
<li>给项目命名为<code>HelloWorld</code>，Interface选择<code>Storyboard</code>，Language选择<code>Objective-C</code>。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofu4wmsj2j314u0t6424.jpg" alt="image-20210311120644241"></p>
<ol start="3">
<li>打开文件<code>Main.storyboard</code>，添加一个<code>Label</code>和<code>Button</code>组件。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofubs0rgnj31iw0u0e02.jpg" alt=""></li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofudvnpftj312u0u0tcs.jpg" alt="image-20210311121521358"></p>
<ol start="4">
<li>打开两个面板，一个显示<code>Main.storyboard</code>，另一个显示<code>ViewController.h</code><br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofugj8ui9j31iq0fsdk5.jpg" alt=""></li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofuiw4hgvj31hx0u07i1.jpg" alt=""></p>
<ol start="5">
<li><p>为Label新建<code>New Referencing Outlet</code>（右键点击Label，点击<code>New Referencing Outlet</code>后的点不松开，拖到<code>ViewController.h</code>中。将新的<code>Referencing Outlet</code>命名为<code>helloLabel</code>。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofukdlay3j31gt0u0h9a.jpg" alt=""></p>
</li>
<li><p>为Button添加<code>Touch Up Inside</code>事件，将事件命名为<code>showHelloWorld</code>。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gog2epczyxj30wg0u0h1n.jpg" alt=""><br>这时，<code>ViewController.h</code>的代码变为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  ViewController.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController : UIViewController</span><br><span class="line"></span><br><span class="line">@property (weak, nonatomic) IBOutlet UILabel *helloLabel;</span><br><span class="line">- (IBAction)showHelloWorld:(id)sender;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>同时，<code>ViewController.m</code>中也自动添加了<code>- (IBAction)showHelloWorld(id)sender {}</code>函数，在其中添加<code>_helloLabel.text = @&quot;Hello World&quot;;</code></p>
</li>
</ol>
<p>至此，最简单的IOS App开发完成。</p>
]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发入门</tag>
      </tags>
  </entry>
  <entry>
    <title>github pages + hexo + next + Travis CI实现免费个人博客</title>
    <url>/chinese/2021/03/08/github-pages-hexo-next-Travis-CI%E5%AE%9E%E7%8E%B0%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>是GitHub提供的静态网页托管工具，可以用来建立个人网页，也可以建立网页介绍某个项目。</p>
<p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>是一个博客框架，而<a href="https://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT</a>是Hexo的一个主题。</p>
<p>最后Travis CI是针对GitHub的一款持续集成工具，这里用来完成网站的自动化部署。</p>
<a id="more"></a>
<h1 id="GitHub-Pages设置"><a href="#GitHub-Pages设置" class="headerlink" title="GitHub Pages设置"></a>GitHub Pages设置</h1><p>GitHub Pages主页中有建站的简单教程，为了支持MarkDown撰写博客，选择使用博客框架Hexo，并选择一个比较流行的框架NexT。</p>
<p>在此基础上可以添加许多功能：</p>
<ol>
<li><p>置顶</p>
<ol>
<li>移除默认安装的插件<code>npm uninstall hexo-generator-index --save</code></li>
<li>安装新插件<code>npm install hexo-generator-index-pin-top --save</code></li>
<li>在需要置顶的文章头部<code>top: true</code>或<code>top:整数</code>，其中整数越大的文章越靠前</li>
<li>为置顶的文章添加置顶标签,在<code>/themes/next/layout/_macro/post.swig</code>文件的<code>&lt;div class=&quot;post-meta&quot;&gt;</code>下方，插入如下代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">&lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">&lt;font color&#x3D;7D26CD&gt;置顶&lt;&#x2F;font&gt;</span><br><span class="line">&lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>数学公式</p>
<ol>
<li>编辑<code>theme/next/_config.yml</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">enable:  true</span><br><span class="line">per_page: false</span><br><span class="line">cdn: &#x2F;&#x2F;cdn.bootcss.com&#x2F;mathjax&#x2F;2.7.1&#x2F;latest.js?config&#x3D;TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure></li>
<li>为了更好的性能，不选择在所有页面下支持数学公式。在需要支持matchjax的文章头部，添加<code>mathjax: true</code></li>
</ol>
</li>
<li><p>评论功能</p>
<ol>
<li>评论功能和阅读统计都可以使用LeanCloud</li>
<li>编辑<code>theme/next/_config.yml</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">    enable: true</span><br><span class="line">    appid:  xxxxxxxx</span><br><span class="line">    appkey:  yyyyyyyyyyy</span><br><span class="line">    notify: false # mail notifier , https:&#x2F;&#x2F;github.com&#x2F;xCss&#x2F;Valine&#x2F;wiki</span><br><span class="line">    verify: false # Verification code</span><br><span class="line">    placeholder: 评论 # comment box placeholder</span><br><span class="line">    avatar: mm # gravatar style</span><br><span class="line">    guest_info: nick,mail,link # custom comment header</span><br><span class="line">    pageSize: 10 # pagination size</span><br></pre></td></tr></table></figure>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocmlo8c9sj317k0o8myh.jpg" class="commentsImg" width="400" height="600" title="评论功能" alt="加载失败"></li>
</ol>
</li>
<li><p>阅读统计<br> <a href="https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">为NexT主题添加文章阅读量统计功能</a></p>
</li>
<li><p>字数统计</p>
<ol>
<li>编辑<code>theme/next/_config.yml</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_wordcount:</span><br><span class="line">item_text: true</span><br><span class="line">wordcount: true</span><br><span class="line">min2read: true</span><br><span class="line">totalcount: true</span><br><span class="line">separated_meta: true</span><br></pre></td></tr></table></figure></li>
<li>执行<code>npm install hexo-wordcount@2 --save</code>，安装需要的库<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocmhvhwsnj30cw01iwei.jpg" class="wordCountImg" width="200" height="30" title="字数统计" alt="加载失败"></li>
</ol>
</li>
<li><p>添加网易云播放器</p>
<ol>
<li>去网易云音乐找一首喜欢的歌。</li>
<li>点击“生成外链播放器”，复制HTML代码。</li>
<li>将HTML代码添加到<code>/themes/hexo-theme-next/layout/_macro/sidebar.swig</code>中<code>&lt;aside id=&quot;sidebar&quot; class=&quot;sidebar”&gt;</code>后面，并用<code>&lt;div&gt;</code>包裹。<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocm3k2n6uj30ia0lujua.jpg" class="musicImg" width="400" height="200" title="网易云音乐" alt="加载失败"></li>
</ol>
</li>
<li><p>将标签云改为彩色</p>
<ol>
<li>在<code>themes/next/layout/</code>中新建<code>tag-color.swig</code>文件，代码为： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">     var alltags &#x3D; document.getElementsByClassName(&#39;tag-cloud-tags&#39;);</span><br><span class="line">     var tags &#x3D; alltags[0].getElementsByTagName(&#39;a&#39;);</span><br><span class="line">     for (var i &#x3D; tags.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">       var r&#x3D;Math.floor(Math.random()*75+130);</span><br><span class="line">       var g&#x3D;Math.floor(Math.random()*75+100);</span><br><span class="line">       var b&#x3D;Math.floor(Math.random()*75+80);</span><br><span class="line">       tags[i].style.background &#x3D; &quot;rgb(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .tag-cloud-tags&#123;</span><br><span class="line">    &#x2F;*font-family: Helvetica, Tahoma, Arial;*&#x2F;</span><br><span class="line">    &#x2F;*font-weight: 100;*&#x2F;</span><br><span class="line">    text-align: center;</span><br><span class="line">    counter-reset: tags;</span><br><span class="line">  &#125;</span><br><span class="line">  .tag-cloud-tags a&#123;</span><br><span class="line">    border-radius: 6px;</span><br><span class="line">    padding-right: 5px;</span><br><span class="line">    padding-left: 5px;</span><br><span class="line">    margin: 8px 5px 0px 0px;</span><br><span class="line">  &#125;</span><br><span class="line">  .tag-cloud-tags a:before&#123;</span><br><span class="line">    content: &quot;?&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .tag-cloud-tags a:hover&#123;</span><br><span class="line">     box-shadow: 0px 5px 15px 0px rgba(0,0,0,.4);</span><br><span class="line">     transform: scale(1.1);</span><br><span class="line">     &#x2F;*box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);*&#x2F;</span><br><span class="line">     transition-duration: 0.15s;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></li>
<li>在<code>/themes/next/layout/page.swig</code>中引入<code>tag-color.swig</code>，即在<code>&lt;div class=&quot;tag-cloud&quot;&gt;</code>代码段下方添加<code>{ % include &#39;tag-color.swig&#39; % }</code></li>
<li>也可以将标签云直接加入主页，在<code>/themes/next/layout/index.swig</code>中的block content代码块中加入以下代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;tag-cloud&quot;&gt;</span><br><span class="line">	  &lt;div class&#x3D;&quot;tag-cloud-tags&quot; id&#x3D;&quot;tags&quot;&gt;</span><br><span class="line">		&#123;&#123; tagcloud(&#123;min_font: 16, max_font: 16, amount: 300, color: true, start_color: &#39;#fff&#39;, end_color: &#39;#fff&#39;&#125;) &#125;&#125;</span><br><span class="line">	  &lt;&#x2F;div&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;br&gt;</span><br><span class="line">	</span><br><span class="line">	&#123;% include &#39;tag-color.swig&#39; %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>展示近期文章</p>
<ol>
<li><p>修改<code>themes/next/layout/_macro/sidebar.swig</code> 。找到<code>theme.social</code>，在该板块后隔一行添加如下代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;# recent posts #&#125;</span><br><span class="line">&#123;% if theme.recent_posts %&#125;</span><br><span class="line">&lt;div class&#x3D;&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme.recent_posts_layout  &#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;links-of-blogroll-title&quot;&gt;</span><br><span class="line">        &lt;!-- modify icon to fire by szw --&gt;</span><br><span class="line">        &lt;i class&#x3D;&quot;fa fa-history fa-&#123;&#123; theme.recent_posts_icon | lower &#125;&#125;&quot; aria-hidden&#x3D;&quot;true&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">        &#123;&#123; theme.recent_posts_title &#125;&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;ul class&#x3D;&quot;links-of-blogroll-list&quot;&gt;</span><br><span class="line">        &#123;% set posts &#x3D; site.posts.sort(&#39;-date&#39;) %&#125;</span><br><span class="line">        &#123;% for post in posts.slice(&#39;0&#39;, &#39;5&#39;) %&#125;</span><br><span class="line">        &lt;li class&#x3D;&quot;recent_posts_li&quot;&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title&#x3D;&quot;&#123;&#123; post.title &#125;&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">         &lt;&#x2F;li&gt;</span><br><span class="line">         &#123;% endfor %&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编辑<code>themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">li.recent_posts_li &#123;</span><br><span class="line">    text-align: cengter;</span><br><span class="line">    display: block;</span><br><span class="line">    word-break: keep-all;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>themes/next/_config.yml</code>中添加下方代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 近期文章设置</span><br><span class="line">recent_posts_title: 近期文章</span><br><span class="line">recent_posts_layout: block</span><br><span class="line">recent_posts: true</span><br></pre></td></tr></table></figure>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocmksvxlvj30da0460su.jpg" class="rencentPostImg" width="200" height="100" title="近期文章" alt="加载失败">

</li>
</ol>
</li>
</ol>
<h1 id="Travis-CI自动部署GitHub-Pages"><a href="#Travis-CI自动部署GitHub-Pages" class="headerlink" title="Travis CI自动部署GitHub Pages"></a>Travis CI自动部署GitHub Pages</h1><p><a href="https://docs.travis-ci.com/user/deployment/pages/" target="_blank" rel="noopener">Travis官方教程</a><br>有了Travis CI，更换电脑时，不需要在本地配置完整的环境，可以直接修改md文件，push到github后，Travis CI会自动生成和部署，非常的方便。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo: false</span><br><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - 10 # use nodejs v10 LTS</span><br><span class="line">before_script: # 配置环境</span><br><span class="line">    - npm install hexo-generator-searchdb --save # 用于支持本地搜索功能</span><br><span class="line">    - npm uninstall hexo-generator-index --save </span><br><span class="line">    - npm install hexo-generator-index-pin-top --save # 这两行用于支持置顶功能</span><br><span class="line">    - npm install --save hexo-filter-flowchart # 用于支持markdown中的流程图功能</span><br><span class="line">    - npm install hexo-wordcount@2 --save #用于支持字数统计功能</span><br><span class="line">cache: npm</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - master # build master branch only</span><br><span class="line">script:</span><br><span class="line">  - hexo generate # generate static files</span><br><span class="line">deploy:</span><br><span class="line">  provider: pages</span><br><span class="line">  skip-cleanup: true</span><br><span class="line">  github-token: $GH_TOKEN</span><br><span class="line">  keep-history: true</span><br><span class="line">  on:</span><br><span class="line">    branch: master</span><br><span class="line">  local-dir: public</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">notifications:</span><br><span class="line">   email:</span><br><span class="line">     recipients:</span><br><span class="line">       - xxx@xxx.com</span><br><span class="line">         #-</span><br><span class="line">     on_success: never # default: change</span><br><span class="line">     #on_success: change # default: change</span><br><span class="line">     on_failure: always # default: always</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>自媒体</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>GitHub Pages</tag>
        <tag>Travis</tag>
      </tags>
  </entry>
</search>
