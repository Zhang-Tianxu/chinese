<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>斯坦福大学IOS7开发课程5</title>
    <url>/chinese/2021/04/25/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B5/</url>
    <content><![CDATA[<p>这节课主要讲解：</p>
<ol>
<li>View Controller的<strong>生命周期</strong></li>
<li><strong>NotificationCenter</strong>的相关知识</li>
<li>组件UITextView的简单使用</li>
</ol>
<p>并通过Demo展示</p>
<a id="more"></a>

<h2 id="ViewController的声明周期"><a href="#ViewController的声明周期" class="headerlink" title="ViewController的声明周期"></a>ViewController的声明周期</h2><p>ViewController 的生命周期可以看作一系列函数，ViewController是UIViewController的子类。</p>
<p>生命周期的开始是创建，创建后会涉及到：</p>
<ol>
<li>viewDidLoad()</li>
<li>viewWillLayoutSubviews()</li>
<li>viewDidLayoutSubviews()</li>
<li>viewWillAppear()</li>
<li>viewDidAppear()</li>
<li>viewWillDisappear()</li>
<li>viewDidDisappear()</li>
<li>didReceiveMemoryWaring()</li>
</ol>
<p>接下来<strong>详细介绍</strong>这几个生命周期：</p>
<h2 id="viewDidLoad"><a href="#viewDidLoad" class="headerlink" title="viewDidLoad()"></a>viewDidLoad()</h2><p>在viewDidLoad()之前会执行创建的动作，但是我们一般不会在创建中执行操作。</p>
<p>创建完成之后，outlets被设置好。</p>
<p>viewDidLoad()只会被<strong>调用一次</strong>，<strong>是用来初始化controller非常好的位置</strong>。</p>
<p>需要注意的是此时view的几何结构（geometry）还没完成，<strong>还无法确定App是运行在6寸的iPhone上还是10寸的iPad上</strong>。所以不要在viewDidLoad()中初始化和尺寸、几何结构相关的操作。</p>
<h2 id="viewWillLayoutSubviews"><a href="#viewWillLayoutSubviews" class="headerlink" title="viewWillLayoutSubviews()"></a>viewWillLayoutSubviews()</h2><p>当view的几何结构发生改变时（比如屏幕从竖着变成横着），（ios7及以上）在展示之前会调用viewWillLayoutSubviews()</p>
<h2 id="viewDidLayoutSubviews"><a href="#viewDidLayoutSubviews" class="headerlink" title="viewDidLayoutSubviews()"></a>viewDidLayoutSubviews()</h2><h2 id="viewWillAppear"><a href="#viewWillAppear" class="headerlink" title="viewWillAppear()"></a>viewWillAppear()</h2><p>view展现在屏幕之前，会调用viewWillAppear()函数。</p>
<p>当使用多MVC模型时，会有多个view，此时某个view的viewWillAppear()可能会被调用多次，所以只执行一次的初始化代码不要放在这里，而应该放在viewDidLoad()。</p>
<p>基于这个理解，有些操作需要放入viewWillAppear()执行，比如Model中的数据在view不可见时被更改了，当view再次展现的时候，需要同步Model和UI。</p>
<p>另外，和viewDidLoad()相对的，这里已经完成了view几何结构的初始化，因此可以执行和几何结构相关的一些操作了。</p>
<p>在生命周期<code>viewWillAppear</code>中，必须调用<code>[super viewWillAppear:animated]</code>，调用位置无关紧要，你可以在开始调用也可以在结束时调用。</p>
<p><code>viewWillDisappear</code>也是一样。</p>
<h2 id="viewDidAppear"><a href="#viewDidAppear" class="headerlink" title="viewDidAppear()"></a>viewDidAppear()</h2><p>view展现在屏幕上之后，调用viewDidAppear()</p>
<h2 id="viewWillDisappear"><a href="#viewWillDisappear" class="headerlink" title="viewWillDisappear()"></a>viewWillDisappear()</h2><p>view即将消失时调用viewWillDisappear()，此时最好停止使用非必要的资源，比如动画等等。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">  [<span class="keyword">super</span> viewWillDisappear:animated]; <span class="comment">// 在所有viewWill/Did中都要调用super函数</span></span><br><span class="line">  <span class="comment">// 记住滑动的位置</span></span><br><span class="line">  [<span class="keyword">self</span> rememberScrollPosition];</span><br><span class="line">  <span class="comment">// 做一些清理工作</span></span><br><span class="line">  [<span class="keyword">self</span> saveDataToPermanentStore];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="viewDidDisappear"><a href="#viewDidDisappear" class="headerlink" title="viewDidDisappear()"></a>viewDidDisappear()</h2><p>view消失以后，调用viewDidDisappear()</p>
<h2 id="didReceiveMemoryWaring"><a href="#didReceiveMemoryWaring" class="headerlink" title="didReceiveMemoryWaring()"></a>didReceiveMemoryWaring()</h2><p>内存不够了，可能是因为你的App，<strong>也可能是手机上的其他App造成的</strong>。</p>
<p>这是你应该试图清理内存。</p>
<p>为什么是我要清理内存？因为操作系统有权限kill应用，如果内存不够了，而你的App又占用了很多内存，很有可能被iOS杀死。 </p>
<h2 id="awakeFromNib"><a href="#awakeFromNib" class="headerlink" title="awakeFromNib()"></a>awakeFromNib()</h2><p>（说实话，没完全听懂，先记下来，以后用到再详细研究一下吧。）</p>
<p>这个方法会发送给storyboard中绘制出来的所有对象，包括controller</p>
<p>如果进入到Controller的init方法，就一定也会进入到<code>awakeFromNib</code>。</p>
<p>尽可能不要将代码放在<code>awakeFromNib</code>中。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setup &#123;...&#125;;  <span class="comment">// do something which can't wait until viewDidLoad</span></span><br><span class="line">- (<span class="keyword">void</span>)awakeFromNib &#123; [<span class="keyword">self</span> setup]; &#125;</span><br><span class="line"><span class="comment">// uIViewController's designated initializer is initWithNibName:bundle:(ugh!)</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithNibName:(<span class="built_in">NSString</span> *)name bundle:(<span class="built_in">NSBundle</span> *)bundle</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 如果使用awakeFromNib，为了保证正确性，也要加上这三行代码</span></span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> initWithNibName:name bundle:bundle];</span><br><span class="line">  [<span class="keyword">self</span> setup];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<div id="flowchart-0" class="flow-chart"></div>

<img src="https://developer.apple.com/library/archive/referencelibrary/GettingStarted/DevelopiOSAppsSwift/Art/WWVC_vclife_2x.png" style="zoom:30%;" />






<h2 id="组件UITextView简介"><a href="#组件UITextView简介" class="headerlink" title="组件UITextView简介"></a>组件UITextView简介</h2><p>组件<a href="https://developer.apple.com/documentation/uikit/uitextview" target="_blank" rel="noopener">UITextView</a>类似于UILable，但是可以展示多行，具有可选可编辑可滚动等特点。</p>
<h2 id="NotificationCenter相关知识"><a href="#NotificationCenter相关知识" class="headerlink" title="NotificationCenter相关知识"></a>NotificationCenter相关知识</h2><p>接下来讲一讲NSNotification</p>
<ul>
<li><p>Notifications也就是之前在MVC中称为radio station的概念。</p>
</li>
<li><p>NSNotificationcenter</p>
<p>通过<code>[NSNotificationCenter defaultCenter]</code>获取默认Notification Center。</p>
<p>如果想监听这个radio station，那么发送如下消息：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="keyword">id</span>)observer  <span class="comment">// 需要接收通知的对象</span></span><br><span class="line">           selector:(SEL)methodToInvokeIfSomethingHappens</span><br><span class="line">               name:(<span class="built_in">NSString</span> *)name  <span class="comment">// station的名称</span></span><br><span class="line">             object:(<span class="keyword">id</span>)sender;  <span class="comment">// 你感兴趣的变更，如果填写nil，标识任何人发生变更，都会通知你。指定某个sender，可以只接收指定对象发来的通知。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当有广播的时候，observer会被通知：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)methodToInvokeIfSomethingHappens:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">  notification.name;  <span class="comment">// 传递的station的名称</span></span><br><span class="line">  notification.object;  <span class="comment">// 给你发送通知的对象</span></span><br><span class="line">  notification.userInfo;  <span class="comment">// 有关发生了什么的特定信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结束后记得关闭radio station</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[center removeObserver:<span class="keyword">self</span>]; <span class="comment">//关闭所有radio station</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">[center removeObserver:<span class="keyword">self</span> name:<span class="built_in">UIContentSizeCategoryDidChangeNotification</span> object:<span class="literal">nil</span>];  <span class="comment">//关闭指定radio station</span></span><br></pre></td></tr></table></figure>

<p>如果离开堆栈时，没有关闭radio station，notification center可能会继续发送notification，并<strong>导致App崩溃</strong>！</p>
<p>因为NSNotificationCenter有一个指向你的unsafe retained指针。</p>
<p>关闭radio station最好的位置是在MVC离开屏幕的时候，实在不行，可以在dealloc中关闭，dealloc会在离开堆栈之前调用：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">  <span class="comment">// be careful in this method! can't access properties! you are almost gone from heap!</span></span><br><span class="line">  [[<span class="built_in">NSNotificationCenter</span> defaultcenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>关于NotificationCenter，一个常用的例子是字体的变化。当用户在系统设置中改变字体大小时，可以利用NotificationCenter使App中的字体也跟着变化。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSNotificationCenter</span> *center = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</span><br><span class="line">[center addObserver:<span class="keyword">self</span></span><br><span class="line">           selector:<span class="keyword">@selector</span>(preferredFontsSizeChanged:)</span><br><span class="line">               name:<span class="built_in">UIContentsizeCategoryDidChangeNotification</span></span><br><span class="line">             object:<span class="literal">nil</span>]; <span class="comment">// this station's broadcasts aren't object-specific</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)preferredFontsSizeChanged:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">  <span class="comment">// reset fonts of objects using preferred fonts</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>目的：了解attributed text（富文本）、生命周期以及Notification。</p>
<ol>
<li><p>新建App，在storageBoard中加入：</p>
<ul>
<li>TextView</li>
<li>label</li>
<li>6 buttons</li>
</ul>
<p>如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gptqmdv9uwj30i40zs41r.jpg" alt="image-20210423160322521"></p>
</li>
<li><p>为TextView和Label添加property:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextView</span> *body;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UILabel</span> *headline;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为buttons添加三个函数</p>
<ul>
<li><p>四个色块的button共用一个函数，函数的作用是：在textView中选中一些文字，点击色块button后，选中的文字变成色块对应的颜色</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)changeBodySelectionColorToMatchBackgroundOfButton:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span>.body.textStorage addAttribute:<span class="built_in">NSForegroundColorAttributeName</span> value:sender.backgroundColor range:<span class="keyword">self</span>.body.selectedRange];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>outline按钮对应的函数，作用是给选中文字添加红色描边。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)outlineBodySelection:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span>.body.textStorage addAttributes:@&#123; <span class="built_in">NSStrokeWidthAttributeName</span> : @<span class="number">-3</span>, <span class="built_in">NSStrokeColorAttributeName</span>: [<span class="built_in">UIColor</span> redColor] &#125; range:<span class="keyword">self</span>.body.selectedRange];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加描边需要添加两个属性，一个用来设置描边的宽度，一个用来设置描边的颜色。</p>
<p><code>NSStrokeWidthAttributeName</code>用来设置描边的宽度，设置为整数会让字体变成中空，设置为负数会保持字体填充。</p>
<p><code>NSStrokeColorAttributeName</code>用来设置描边的颜色。</p>
</li>
<li><p>unOutline按钮对应的按钮，作用是删除字体的描边。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)unOutlineBodySelection:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span>.body.textStorage removeAttribute:<span class="built_in">NSStrokeWidthAttributeName</span> range:<span class="keyword">self</span>.body.selectedRange];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接利用<code>removeAttribute</code>删除<code>NSStrokeWidthAttributeName</code>属性，颜色就不用管了，没有宽度颜色也就无法显示了。</p>
</li>
</ul>
</li>
<li><p>设置outline按钮的字体描边</p>
<p>这样产不多就是这节课要介绍的关于富文本的知识点了。接下来加入一些生命周期的元素。</p>
<p>现在想要让outline按钮的文字变成描边的，我们可不想在设置一个按钮来让outline按钮outline，而是想一开始它就是描边的。</p>
<p>这个时候就用到生命周期了，可以在<code>viewDidLoad()</code>函数中实现：</p>
<p>先为button添加outlet，<code>@property (weak, nonatomic) IBOutlet UIButton *outline;</code>，然后在<code>viewDidLoad()</code>函数中编写代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    <span class="built_in">NSMutableAttributedString</span> *title = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:<span class="keyword">self</span>.outline.currentTitle];</span><br><span class="line">    [title setAttributes:@ &#123;</span><br><span class="line">        <span class="built_in">NSStrokeWidthAttributeName</span> : @<span class="number">3</span>,</span><br><span class="line">        <span class="built_in">NSStrokeColorAttributeName</span> : <span class="keyword">self</span>.outline.tintColor&#125;</span><br><span class="line">                   range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, [title length])];</span><br><span class="line">    [<span class="keyword">self</span>.outline setAttributedTitle:title forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用NSNotificationCenter让App中字体跟随系统字体，用户改变系统字体时，App中字体也随之变动。</p>
<ol>
<li><p>首先实现一个将字体设置为系统对应字体的方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)usePreferredFonts &#123;</span><br><span class="line">    <span class="keyword">self</span>.body.font = [<span class="built_in">UIFont</span> preferredFontForTextStyle:<span class="built_in">UIFontTextStyleBody</span>];</span><br><span class="line">    <span class="keyword">self</span>.headline.font = [<span class="built_in">UIFont</span> preferredFontForTextStyle:<span class="built_in">UIFontTextStyleHeadline</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并将其包装一层：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)preferredFontsChanged:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    [<span class="keyword">self</span> usePreferredFonts];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在生命周期<code>viewWillAppear()</code>中添加NotificationCenter</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">               selector:<span class="keyword">@selector</span>(preferredFontsChanged:)</span><br><span class="line">                   name:<span class="built_in">UIContentSizeCategoryDidChangeNotification</span></span><br><span class="line">                 object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后记得关闭radio station</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillDisappear:animated];</span><br><span class="line">    <span class="comment">// [[NSNotificationCenter defaultCenter] removeObserver:self]; // 这种方法也可以，删除所有的notification，但不够优雅，尽量使用下面的方法，指定具体的notificationCenter</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span></span><br><span class="line">                                                    name:<span class="built_in">UIContentSizeCategoryDidChangeNotification</span></span><br><span class="line">                                                  object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后要考虑一种情况，NotificationCenter在view消失时被关闭，如果在这之后用户修改了系统的字体，那么view再次appear时，App字体会和系统不一致。因此，需要在<code>viewWillAppear</code>中，调用<code>[self usePreferredFonts]</code>来同步外部世界的字体。</p>
</li>
</ol>
</li>
</ol>
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: instantiated(实例化)
op=>operation: 调用awakeFromNib()
op2=>operation: outlets设置完成
op3=>operation: 调用viewDidLoad()
op4=>operation: 几何结构确定下来以后,\
调用viewWillLayoutSubviews()和viewDidLayoutSubviews()
op5=>operation: (对着MVC再屏幕中出现和消失，下面几个生命周期可能会被多次调用)
op6=>operation: 调用viewWillAppear()和viewDidAppear()
op7=>operation: 每当几何结构改变（比如屏幕旋转）都会调用\
viewWillLayoutSubviews()和viewDidLayoutSubviews()
op8=>operation: 如果设置了屏幕自动旋转，还会调用will/didRotatedTo/From
op9=>operation: 调用viewWillDisappear()和viewDidDisappear()
op10=>operation: 如果手机内存吃紧，调用didReceiveMemoryWarning()
e=>end
st->op->op2->op3->op4->op5->op6->op7->op8->op9->op10->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发入门</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福大学IOS7开发课程4</title>
    <url>/chinese/2021/03/29/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B4/</url>
    <content><![CDATA[<p>这节课主要讲了<strong>Objecitive-C的几个细节</strong>和<strong>Foundation</strong>库中的一些类</p>
<p>本节课主要介绍iOS开发</p>
<ul>
<li>NSObject</li>
<li>NSArray</li>
<li>NSMutableArray</li>
<li>NSNumber</li>
<li>NSValue</li>
<li>NSData</li>
<li>NSDate</li>
<li>NSSet</li>
<li>NSMutableSet</li>
<li>NSOrderedSet</li>
<li>NSMutableOrderedSet</li>
<li>NSDictionary</li>
<li>NSMutableDictionary</li>
<li>NSUserDefaults</li>
<li>NSRange</li>
<li>UIColor</li>
<li>UIFont</li>
<li>UIFontDescriptor</li>
<li>NSAttributedString</li>
<li>NSMutableAttributedString</li>
</ul>
<a id="more"></a>

<h1 id="Objecitive-C的几个细节"><a href="#Objecitive-C的几个细节" class="headerlink" title="Objecitive-C的几个细节"></a>Objecitive-C的几个细节</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><ol>
<li>利用Alloc &amp; init创建对象</li>
<li>利用类的方法创建对象</li>
<li>或者上述两者同时使用</li>
<li>让其他对象帮忙创建类的对象<figure class="highlight"><table><tr><td class="code"><pre><span class="line">- NSString's -- (NSString *)stringByAppendingString:(NSString *)otherString</span><br><span class="line">- NSArray's -- (NSString *)componentsJoinedByString:(NSString *)separator;</span><br><span class="line">- NSString's &amp; NSArray's -- (id)mutableCopy</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h2><p>向nil发送消息是可以的，但是不会执行任何代码</p>
<h2 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h2><p>Objective-C有个<strong>非常重要</strong>的类型——<strong>id</strong>，id是一种类型，意味“指向未知类型对象的<strong>指针</strong>”。</p>
<p><strong>在运行过程中，所有对象的指针都是id类型的。</strong></p>
<p>用id来指定变量类型，<strong>就是动态绑定</strong>。</p>
<p>但是在编译过程中，如果你指定对象的类型，编译器可以帮助发现bug。</p>
<p><strong>那么动态绑定安全么？</strong></p>
<p>动态绑定导致可以向对象发送未定义的信息，比如该对象类型为定义的方法，当然这会导致程序崩溃。</p>
<p>如果在代码中指定对象的类型，这种错误就可以在编译过程中被发现，防止程序在执行过程中崩溃，比如，<code>NSString *s  = @&#39;x&#39;</code>，这种情况下，如果给s发送非NSString的方法，编译器可以发现错误。</p>
<p>当然也可以使用：<code>id obj = s</code>、<code>NSArray *a = obj</code>，但是这样<strong>编译器没办法帮忙检查错误</strong>，所以存在一定危险。</p>
<p>另外，永远不要使用<code>id *</code>，因为<strong>id本身就是个指针</strong>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Vehicle</span></span></span><br><span class="line">- (<span class="keyword">void</span>)move;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Ship</span> : <span class="title">Vehicle</span></span></span><br><span class="line">- (<span class="keyword">void</span>)shoot;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Ship *s = [[Ship alloc] init];</span><br><span class="line">[s shoot];</span><br><span class="line">[s move];</span><br><span class="line"></span><br><span class="line">Vehicle *v = s; <span class="comment">// 合法</span></span><br><span class="line">[v shoot]; <span class="comment">// 编译器会给出警告，因为它以为v是Vehicle</span></span><br><span class="line">          <span class="comment">//但是运行时不会崩溃，因为v实际上是一个Ship</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> obj = ...; <span class="comment">// 任意定义obj，比如NSString；</span></span><br><span class="line">[obj shoot;] <span class="comment">// 编译器不会给出警告，因为它知道shoot函数确实存在，同时它又不知道obj的类型，因此编译器无法给出警告。</span></span><br><span class="line"><span class="comment">// 但是，实际运行中，程序会崩溃。</span></span><br><span class="line">[obj someMethodNameThatNoObjectAnywhereRespondsTo];</span><br><span class="line"><span class="comment">// 这个时候编译器会给出警告，因为它知道没有任何函数叫someMethodNameThatNoObjectAnywhereRespondsTo</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *hello = <span class="string">@"hello"</span>;</span><br><span class="line">[hello shoot]; <span class="comment">// 编译器会给出警告，因为NSString没有shoot函数</span></span><br><span class="line">Ship *helloShip = (Ship *)hello; <span class="comment">// 编译器不会给出警告 </span></span><br><span class="line">[helloShip shoot];<span class="comment">// 导致运行时崩溃</span></span><br><span class="line">[(<span class="keyword">id</span>)hello shoot]; <span class="comment">//编译器不会给出警告，但是运行时会崩溃</span></span><br></pre></td></tr></table></figure>

<p><strong>什么时候会用到危险的动态绑定（id）</strong></p>
<ol>
<li>Objective-C允许在同一个collection（比如NSArray）中有不同类型的类，想这么做时，需要用到动态绑定。 </li>
<li>当希望使用MVC中的blind/structured通信（比如delegation）时。</li>
</ol>
<p><strong>为了把动态绑定变得安全</strong>，需要使用Introspection和Protocols</p>
<ul>
<li><p>Introspection</p>
<p>在运行时询问id是什么类型或询问可以向其发送的信息。</p>
<p>继承自NSObject的所有对象都有下面三个函数：</p>
<ol>
<li><p><code>isKindOfClass:</code></p>
<p>判断对象是不是某种类，包含继承的情况</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>([obj isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *s = [(<span class="built_in">NSString</span>*)obj stringByAppendingString:<span class="string">@"xyzzy"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如在纸牌匹配游戏中<code>PlayingCard.m</code>的<code>match</code>函数的源代码为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">int</span>)match:(<span class="built_in">NSArray</span> *)otherCards</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>([otherCards count] == <span class="number">1</span>) &#123;</span><br><span class="line">        PlayingCard *otherCard = [otherCards firstObject];</span><br><span class="line">      <span class="keyword">if</span>([<span class="keyword">self</span>.suit isEqualToString:otherCard.suit]) &#123;</span><br><span class="line">            score = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.rank == otherCard.rank) &#123;</span><br><span class="line">            score = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以改为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">int</span>)match:(<span class="built_in">NSArray</span> *)otherCards</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>([otherCards count] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">id</span> card = [otherCards firstObject];</span><br><span class="line">        <span class="keyword">if</span>([card isKindOfClass:[PlayingCard <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            PlayingCard *otherCard = (PlayingCard *)card;</span><br><span class="line">            <span class="keyword">if</span>([<span class="keyword">self</span>.suit isEqualToString:otherCard.suit]) &#123;</span><br><span class="line">                score = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.rank == otherCard.rank) &#123;</span><br><span class="line">                score = <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>isMemberOfClass:</code></p>
<p>判断对象是不是某种类，不包括继承的情况</p>
</li>
<li><p><code>respondsToSelector:</code></p>
<p>判断对象能否相应某个函数</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>([obj respondsToSelector:<span class="keyword">@selector</span>(shoot)]) &#123;</span><br><span class="line">    [obj shoot];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([obj respondsToSelector:<span class="keyword">@selector</span>(shootAt:)]) &#123;</span><br><span class="line">    [obj shootAt:target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>在objective-C中，SEL是selector的一种类型</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">SEL shootSelector = <span class="keyword">@selector</span>(shoot);</span><br><span class="line">SEL shootAtSelector = <span class="keyword">@selector</span>(shootAt:);</span><br><span class="line">SEL moveToSelelctor = <span class="keyword">@selector</span>(moveTo:withPenColor);</span><br></pre></td></tr></table></figure>
</li>
<li><p>给定SEL，可以要求对象执行selector</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[obj performSelector:shootSelector];</span><br><span class="line">[obj performSelector:shootAtSelector withObject:coordinate];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[array makeObjectsPerformSelector:shootSelector];</span><br><span class="line"><span class="comment">// cool, huh?</span></span><br><span class="line">[array makeObjectsPerformSelector:shootAtSelector withObject:target];</span><br><span class="line"><span class="comment">// target is an id</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Protocols</p>
<p>不指定指针指向的对象类型，但是指定其实现的函数。</p>
</li>
</ul>
<h1 id="Foundation库"><a href="#Foundation库" class="headerlink" title="Foundation库"></a>Foundation库</h1><h2 id="NSObject"><a href="#NSObject" class="headerlink" title="NSObject"></a>NSObject</h2><p>在iOS SDK中 ，NSObject几乎是所有类的基类。</p>
<p>NSObject包含一个非常有用的函数<code>- (NSString *)description</code>，会返回对类的描述，所以最好在自己实现的类中对其重写。该函数一般用在两个地方：</p>
<ul>
<li><p>用NSLog打印出来，<code>NSLog(@&quot;array contents are  %@&quot;, myArray);</code>，用于debug</p>
</li>
<li><p>并不是所有的对象都实现了<code>- (id)copy</code>和<code>- (id)mutableCopy</code>，在未实现它们的对象中调用，会抛出异常</p>
</li>
<li><p>你向可修改对象（比如MutableArray）发送copy，返回值并不是可修改对象，而是获得一个不可修改的对象。</p>
</li>
</ul>
<h2 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h2><p>NSArray是对象的有序集合，不可修改（immutable），一旦创建，不能添加或删除对象。</p>
<p>只要NSArray本身在内存的堆中，其中所有的对象都有strong指针指向它们。</p>
<p>一般通过<code>@[]</code>手动创建NSArray，NSArray中包括以下一些关键函数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)count;</span><br><span class="line">- (<span class="keyword">id</span>)objectAtIndex:(<span class="built_in">NSUInteger</span>)index; <span class="comment">//如果index超出边界，程序崩溃</span></span><br><span class="line">- (<span class="keyword">id</span>)lastObject; <span class="comment">//如果数组为空，返回nil，不会导致程序崩溃</span></span><br><span class="line">- (<span class="keyword">id</span>)firstObject; <span class="comment">//如果数组为空，返回nil，不会导致程序崩溃</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)sortedArrayUsingSelector:(SEL)aSelector;</span><br><span class="line">- (<span class="keyword">void</span>)makeObjectsPerformsSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)selectorArgument;</span><br><span class="line">- (<span class="built_in">NSString</span> *)componentsJoinedByString:(<span class="built_in">NSString</span> *)separator;</span><br></pre></td></tr></table></figure>

<h2 id="NSMutableArray"><a href="#NSMutableArray" class="headerlink" title="NSMutableArray"></a>NSMutableArray</h2><p>是NSArray的可变版本（mutable），继承了NSArray的所有函数</p>
<p>一般通过<code>alloc/init</code>创建，或者通过以下函数创建</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)arrayWithCapacity:(<span class="built_in">NSUInteger</span>)numItems;</span><br><span class="line">+ (<span class="keyword">id</span>)array;<span class="comment">//[NSMutableArray array] 等价于 [[NSMutableArray alloc] init]</span></span><br></pre></td></tr></table></figure>

<p>对于NSArray和NSMutableArray两种数组，可以用for-in的方式遍历：</p>
<p>Objective-C支持for-in形式的数组遍历。需要注意的是，for-in形式的数组遍历默认会进行强制类型转换，比如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *myArray = ...;<span class="comment">// 任意类型数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *string <span class="keyword">in</span> myArray) &#123; <span class="comment">//编译器不知道数组中的数据类型</span></span><br><span class="line">  <span class="keyword">double</span> = value = [string doubleValue];<span class="comment">// 如果string的类型并不是NSString，会导致程序崩溃</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么如果数组中的数据类型不同，如何进行遍历呢？可以使用id</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *myArray = ...;<span class="comment">// 同样，任意类型的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">  <span class="comment">// 通过某些方法确认obj是你想要的类型，防止程序崩溃</span></span><br><span class="line">  <span class="keyword">if</span>([obj isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">    <span class="comment">// 这是确认了obj的类型是NSString</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NSNumber"><a href="#NSNumber" class="headerlink" title="NSNumber"></a>NSNumber</h2><p>NSNumber是对元类型int、float、double、BOOL、enum等的封装。<strong>当你想把这些元类型的数据放入同一个数组时很有用。</strong></p>
<h2 id="NSValue"><a href="#NSValue" class="headerlink" title="NSValue"></a>NSValue</h2><p>类似于NSNumber，但是用来封装一些非对象、非元类型的数据，例如c structs。</p>
<h2 id="NSData"><a href="#NSData" class="headerlink" title="NSData"></a>NSData</h2><p>用于存储bits</p>
<h2 id="NSDate"><a href="#NSDate" class="headerlink" title="NSDate"></a>NSDate</h2><p>用于存储日期，相关的类型还有NSCalendar，NSDateFormatter，NSDateComponents。</p>
<h2 id="NSSet-NSMutableSet"><a href="#NSSet-NSMutableSet" class="headerlink" title="NSSet/NSMutableSet"></a>NSSet/NSMutableSet</h2><h2 id="NSOrderedSet-NSMutableOrderedSet"><a href="#NSOrderedSet-NSMutableOrderedSet" class="headerlink" title="NSOrderedSet/NSMutableOrderedSet"></a>NSOrderedSet/NSMutableOrderedSet</h2><h2 id="NSDictionary"><a href="#NSDictionary" class="headerlink" title="NSDictionary"></a>NSDictionary</h2><p>存储键值对，不可修改。</p>
<p>NSDictionary可以用<code>@{key1:value1, key2:value2}</code>创建，比如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *colors = @&#123; <span class="string">@"green"</span> : [<span class="built_in">UIColor</span> greenColor],</span><br><span class="line">                        <span class="string">@"blue"</span> : [<span class="built_in">UIColor</span> blueColor],</span><br><span class="line">                        <span class="string">@"red"</span> : [<span class="built_in">UIColor</span> redColor]&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *colorString = <span class="string">@"red"</span>;</span><br><span class="line"><span class="built_in">UIColor</span> *colorObject = colors[colorString];</span><br></pre></td></tr></table></figure>

<h2 id="NSMutableDictionary"><a href="#NSMutableDictionary" class="headerlink" title="NSMutableDictionary"></a>NSMutableDictionary</h2><p>NSDictionary的可修改版本，出了继承了NSDictionary所有的函数，还有下面几个重要函数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)anObject forKey:(<span class="keyword">id</span>)key;</span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key;</span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects;</span><br><span class="line">- (<span class="keyword">void</span>)addEntriesFromDictionary:(<span class="built_in">NSDictionary</span> *)otherDictionary;</span><br></pre></td></tr></table></figure>

<p>Dictionary和NSMutableDictionary可用如下方法遍历：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *myDictionary = ...;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span> key <span class="keyword">in</span> myDictionary) &#123;</span><br><span class="line">  <span class="comment">// do something with key here</span></span><br><span class="line">  <span class="keyword">id</span> value = [myDictionary objectForKey:key];</span><br><span class="line">  <span class="comment">// do something with value here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NSUserDefaults"><a href="#NSUserDefaults" class="headerlink" title="NSUserDefaults"></a>NSUserDefaults</h2><p>介绍NSUserDefaults之前，需要先介绍一个术语：<strong><em>Property List</em></strong></p>
<p>Property List是一个iOS开发中常用术语，在一些API中会用到，比如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)writeToFile:(<span class="built_in">NSString</span> *)path atomically:(<span class="built_in">BOOL</span>)atom;</span><br></pre></td></tr></table></figure>

<p>这个函数只能发送给NSArray或NSDictionary，并且其中只能包含Property List对象。</p>
<ul>
<li><p><strong>概念：</strong></p>
<p>Property List可以理解为只包含NSArray、NSDictionary、NSNumber、NSString、NSDate、NSDate的一个集合，并且Property List是一个递归的概念。</p>
<p>比如一个由NSString组成的NSArray，就是一个Property List</p>
<p>一个由NSArray组成的NSArray是不是一个Property List要看子NSArray是不是Property List，如果是，那组成的NSArray就是一个Property List，否则不是。</p>
<p>对于NSDictionary，只有当其所有key和value都是Property List的时候才是Property List</p>
<p>那么，假设有一个NSArray，其中包含了多个NSDictionary，这些NSDictionary的key都是NSString，value都是NSNumber，那么这个NSArray也是个Property List</p>
</li>
</ul>
<p>NSUserDefaults就是Property List的轻量级存储，可以看成一个持久存储的NSDictionary。算不上一个数据库，通常只用来存储小数据，比如用户设置。</p>
<p>利用standardUserDefaults读写：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setArray:rvArray forKey:<span class="string">@"RecentlyViewed"</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setDouble:(<span class="keyword">double</span>)aDouble forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="built_in">NSInteger</span>)integerForKey;(<span class="built_in">NSString</span> *)key; <span class="comment">// NSInteger is a typedef to 32 or 64 bit int</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)obj forKey:(<span class="built_in">NSString</span> *)key; <span class="comment">//obj must be a Property List</span></span><br><span class="line">-(<span class="built_in">NSArray</span> *)arrayForKey:(<span class="built_in">NSString</span> *)key; <span class="comment">// will return nil if value for key is not NSArray</span></span><br></pre></td></tr></table></figure>

<p>更改后一定要使用synchronize进行同步，才能写入永久内存。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSUser</span> Defaults standardUserDefaults] synchronize];</span><br></pre></td></tr></table></figure>

<h2 id="NSRange"><a href="#NSRange" class="headerlink" title="NSRange"></a>NSRange</h2><p>是一个类似C语言中struct的结构，用于指定string和数组的界限，其结构如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="built_in">NSUInteger</span> location;</span><br><span class="line">  <span class="built_in">NSUInteger</span> length;</span><br><span class="line">&#125; <span class="built_in">NSRange</span>;</span><br></pre></td></tr></table></figure>

<p>使用方法如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *greeting = <span class="string">@"hello world"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *hi = <span class="string">@"hi"</span>;</span><br><span class="line"><span class="built_in">NSRange</span> r = [greeting rangeOfString:hi];</span><br><span class="line"><span class="keyword">if</span>(r.location == <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">  <span class="comment">//没能在greeting中找到hi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UIColor"><a href="#UIColor" class="headerlink" title="UIColor"></a>UIColor</h2><p>一个非常简单的类，用于表示颜色。可以用RGB或者HSB等方法初始化。</p>
<h2 id="UIFont"><a href="#UIFont" class="headerlink" title="UIFont"></a>UIFont</h2><p>字体在UI设计中非常重要，iOS在不同截面显示的字体变化很大，所以要重视UIFont这个类。</p>
<p>对于展示内容而言，使用Font<strong>最好的方法</strong>是调用<code>preferredFontForTextStyle</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> preferredFontForTextStyle:<span class="built_in">UIFontTextStyleBody</span>];</span><br></pre></td></tr></table></figure>

<p>除了<code>UIFontTextStyleBody</code>，还有<code>UIFontTextStyleHeadline</code>、<code>UIFontTextStyleCaption1</code>、<code>UIFontTextStyleFootnote</code>等等。</p>
<p>对于按键内容等，可以使用系统字体：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">UIFont</span> *)systemFontOfSize:(<span class="built_in">CGFloat</span>)pointSize;</span><br><span class="line">+ (<span class="built_in">UIFont</span> *)boldSystemFontOfSize:(<span class="built_in">CGFloat</span>)pointSize;</span><br></pre></td></tr></table></figure>

<p><strong>不要将系统字体用于内容。</strong></p>
<h2 id="UIFontDescriptor"><a href="#UIFontDescriptor" class="headerlink" title="UIFontDescriptor"></a>UIFontDescriptor</h2><p>字体是由艺术家设计的，并没有特定的准则，有些字体甚至没有加黑。尽管如此，UIFontDescriptor尝试对所有字体进行分类。</p>
<h2 id="NSAttributedString"><a href="#NSAttributedString" class="headerlink" title="NSAttributedString"></a>NSAttributedString</h2><p>iOS开发中经常需要显示一些带有特殊样式的文本，比如说带有下划线、删除线、斜体、空心字体、背景色、阴影以及图文混排（一种文字中夹杂图片的显示效果）。</p>
<p>通常想要实现这些效果要使用到iOS的Foundation框架提供的NSAttributedString类，NSAttributedString类中有许多属性，不同属性对应不同的文本样式。本文主要对这些属性做一个解释说明，并会结合实际代码来应用它们。</p>
<p>可以将NSAttributedString想象成NSString，其每个字母有个叫做attributes的NSDictionary。 </p>
<p>NSAttributedString<strong>不是</strong>NSString的继承，所以不能使用NSString的函数。</p>
<h2 id="NSMutableAttributedString"><a href="#NSMutableAttributedString" class="headerlink" title="NSMutableAttributedString"></a>NSMutableAttributedString</h2><p>相对于NSAttributedString，NSMutableAttributedString更加常用。</p>
<p>添加或者设置字母对应attributes的方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addAttributes:(<span class="built_in">NSDictionary</span> *)attributes range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line">- (<span class="keyword">void</span>)setAttributeds:(<span class="built_in">NSDictionary</span> *)attributes range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line">-(<span class="keyword">void</span>)removeAttribute:(<span class="built_in">NSString</span> *)attributeName range:(<span class="built_in">NSRange</span>)range;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *yellow = [<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line"><span class="built_in">UIColor</span> *transparentYellow = [yellow colorWithAlphaComponent:<span class="number">0.3</span>];</span><br><span class="line">@&#123; <span class="built_in">NSFontAttributeName</span>:</span><br><span class="line">     [<span class="built_in">UIFont</span> preferredFontWithTextStyle:<span class="built_in">UIFontTextStyleHeadline</span>],</span><br><span class="line">   <span class="built_in">NSForegroundColorAttributeName</span> : [<span class="built_in">UIColor</span> greenColor], <span class="comment">// 字体颜色</span></span><br><span class="line">   <span class="built_in">NSStrokeWidthAttributeName</span> : @<span class="number">-5</span>,</span><br><span class="line">   <span class="built_in">NSStrokeColorAttributeName</span> : [<span class="built_in">UIColor</span> redColor],</span><br><span class="line">   <span class="built_in">NSUnderlineStyleAttributeName</span> : @(<span class="built_in">NSUnderlineStyleNone</span>), <span class="comment">// 设置字体描边</span></span><br><span class="line">   <span class="built_in">NSBackgroundColorAttributeName</span> : transparentYellow <span class="comment">// 设置字体背景颜色</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp14yomq5ij30ds0oggrt.jpg" alt="image-20210329221812138"></p>
<p>attributed strings用在哪里？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UIButton</span></span><br><span class="line">- (<span class="keyword">void</span>)setAttributedTitle:(<span class="built_in">NSAttributedString</span> *)title forState:...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UILable</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSAttributedString</span> *attributedText;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UITextView</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSTextStorage</span> *textStorage;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发入门</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福大学IOS7开发课程3</title>
    <url>/chinese/2021/03/22/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B3/</url>
    <content><![CDATA[<h1 id="斯坦福大学IOS7开发课程3"><a href="#斯坦福大学IOS7开发课程3" class="headerlink" title="斯坦福大学IOS7开发课程3"></a>斯坦福大学IOS7开发课程3</h1><p>课程3主要内容是继续之前的纸牌游戏。上节课实现的纸牌游戏App只是实现了简单的纸牌翻转，这节课使其变得真正可玩。</p>
<p>主要分为三个部分：</p>
<ol>
<li>先回顾上节课编写的App</li>
<li>对上节课的App改进</li>
<li>使游戏变得可玩</li>
</ol>
<a id="more"></a>

<h2 id="上节课实现的纸牌翻转App"><a href="#上节课实现的纸牌翻转App" class="headerlink" title="上节课实现的纸牌翻转App"></a>上节课实现的纸牌翻转App</h2><ol>
<li><p><strong>将背景颜色设置为绿色</strong></p>
<p>打开<code>Main.storyboard</code>，选中View后，在属性栏里将<code>Background</code>的颜色设置为绿色。</p>
</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo58d9362j30ee0oe773.jpg" class="setBackgroundColor" width="300" height="700" title="设置Background颜色" alt="加载失败">

<ol start="2">
<li><p><strong>添加纸牌正反面的图片</strong></p>
<p>在网上获取纸牌正反面图片，比如：</p>
</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo59iuj4rj30dw0jgqdw.jpg" class="CardBack" width="100" height="250" title="纸牌背面" alt="加载失败">

<img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo59sknnzj30dw0jg74b.jpg" class="CardFront" width="100" height="250" title="纸牌正面" alt="加载失败">


<p>   选中<code>Assets.xcassets</code>，将两张图片拖至其中。</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo5bh0htpj31e00d4adb.jpg" class="addImage" width="600" height="200" title="添加图片到Assets.xcassets" alt="加载失败">

<ol start="3">
<li><strong>添加按钮，并将按钮的背景图片改为纸牌正面图片（CardFront）， 文字改为“♠️A”</strong></li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo5fk47bsj31sg0r4wpk.jpg" class="setButtonBackground" width="600" height="300" title="设置按钮背景图片" alt="加载失败">

<ol start="4">
<li><p><strong>添加一个<code>Label</code>，显示纸牌翻转的次数</strong></p>
</li>
<li><p><strong>为按钮添加“Touch Up Inside”事件，命名为<code>touchCardButton</code></strong></p>
</li>
<li><p><strong>为<code>Label</code>在<code>ViewController.m</code>的<code>@interface ViewController() @end</code>之间添加“Referencing Outlets“，命名为<code>flipsLabel</code>。</strong></p>
</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gooawynczug30v00ienpd.gif" class="addOutlets" width="600" height="300" title="为Label添加Outlet" alt="加载失败">

<ol start="7">
<li><p><strong>另外，在<code>ViewController.m</code>的<code>@interface ViewController() @end</code>之间添加int属性<code>flipCount</code></strong></p>
</li>
<li><p><strong>在<code>ViewController.m</code>中实现touchCardButton事件函数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (IBAction)touchCardButton:(UIButton *)sender &#123;</span><br><span class="line">    if ([sender.currentTitle length]) &#123;</span><br><span class="line">        [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardBack&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [sender setTitle:@&quot;&quot; forState:UIControlStateNormal];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Card *card &#x3D; [self.deck drawRandomCard];</span><br><span class="line">        if(card) &#123;</span><br><span class="line">        [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardFront&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [sender setTitle:@&quot;A♣️&quot; forState:UIControlStateNormal];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    self.flipCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重构属性<code>flipCount</code>的<code>setter</code>函数。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setFlipCount:(int)flipCount</span><br><span class="line">&#123;</span><br><span class="line">    _flipCount &#x3D; flipCount;</span><br><span class="line">    self.flipsLabel.text &#x3D; [NSString stringWithFormat:@&quot;Flips: %d&quot;,self.flipCount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>此时App完成，代码如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ViewController.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController : UIViewController</span><br><span class="line">- (IBAction)touchCardButton:(UIButton *)sender;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ViewController.m</span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (weak, nonatomic) IBOutlet UILabel *flipsLabel;</span><br><span class="line">@property (nonatomic) int flipCount;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)touchCardButton:(UIButton *)sender &#123;</span><br><span class="line">    if ([sender.currentTitle length]) &#123;</span><br><span class="line">        [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardBack&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [sender setTitle:@&quot;&quot; forState:UIControlStateNormal];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardFront&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [sender setTitle:@&quot;A♣️&quot; forState:UIControlStateNormal];</span><br><span class="line">    &#125;</span><br><span class="line">    self.flipCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFlipCount:(int)flipCount</span><br><span class="line">&#123;</span><br><span class="line">    _flipCount &#x3D; flipCount;</span><br><span class="line">    self.flipsLabel.text &#x3D; [NSString stringWithFormat:@&quot;Flips: %d&quot;,self.flipCount];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>最终效果如下：</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1goob73x6nkg30j816ykjm.gif" class="result1" width="300" height="700" title="最终效果1" alt="加载失败">



<h2 id="对该App改进"><a href="#对该App改进" class="headerlink" title="对该App改进"></a>对该App改进</h2><p>上节课完成的App只能实现纸牌的翻转，每次翻转显示的纸牌都是同一张。那么如何让每次翻转，随机显示牌堆中的一张纸牌呢？其实也很简单，方法如下：</p>
<ol>
<li><p><strong>在<code>ViewController.m</code>中引入<code>Deck.h</code></strong></p>
</li>
<li><p><strong>在<code>ViewController.m</code>的<code>@interface ViewController() @end</code>之间添加<code>Deck*</code>属性<code>deck</code></strong></p>
</li>
<li><p><strong>在<code>ViewController.m</code>中引入<code>PlayingCardDeck.h</code></strong></p>
</li>
<li><p><strong>修改属性<code>deck</code>的<code>getter</code>，当<code>_deck</code>为空时，通过<code>[[PlayingCardDeck alloc]init]</code>创建牌堆，然后再返回Deck。</strong></p>
<p>此时<code>ViewController.m</code>的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  ViewController.m</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">#import &quot;PlayingCardDeck.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (weak, nonatomic) IBOutlet UILabel *flipsLabel;</span><br><span class="line">@property (nonatomic) int flipCount;</span><br><span class="line">@property (strong, nonatomic) Deck *deck;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Deck *)deck</span><br><span class="line">&#123;</span><br><span class="line">    if(!_deck)</span><br><span class="line">        _deck &#x3D; [self createDeck];</span><br><span class="line">    return _deck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Deck *)createDeck</span><br><span class="line">&#123;</span><br><span class="line">    return [[PlayingCardDeck alloc]init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (IBAction)touchCardButton:(UIButton *)sender &#123;</span><br><span class="line">    if ([sender.currentTitle length]) &#123;</span><br><span class="line">        [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardBack&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [sender setTitle:@&quot;&quot; forState:UIControlStateNormal];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardFront&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [sender setTitle:@&quot;A♣️&quot; forState:UIControlStateNormal];</span><br><span class="line">    &#125;</span><br><span class="line">    self.flipCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFlipCount:(int)flipCount</span><br><span class="line">&#123;</span><br><span class="line">    _flipCount &#x3D; flipCount;</span><br><span class="line">    self.flipsLabel.text &#x3D; [NSString stringWithFormat:@&quot;Flips: %d&quot;,self.flipCount];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在<code>touchCardButton</code>函数中，利用<code>deck</code>的<code>drawRandomCard</code>函数随机抽取一张纸牌。</strong></p>
</li>
<li><p><strong>将随机抽取出的Card的内容显示出来。需要注意的是，牌堆里的牌抽完以后要停止抽牌。</strong></p>
</li>
</ol>
<p>完成后<code>ViewController.m</code>的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ViewController.m</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">#import &quot;PlayingCardDeck.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (weak, nonatomic) IBOutlet UILabel *flipsLabel;</span><br><span class="line">@property (nonatomic) int flipCount;</span><br><span class="line">@property (strong, nonatomic) Deck *deck;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Deck *)deck</span><br><span class="line">&#123;</span><br><span class="line">    if(!_deck)</span><br><span class="line">        _deck &#x3D; [self createDeck];</span><br><span class="line">    return _deck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Deck *)createDeck</span><br><span class="line">&#123;</span><br><span class="line">    return [[PlayingCardDeck alloc]init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)touchCardButton:(UIButton *)sender &#123;</span><br><span class="line">    if ([sender.currentTitle length]) &#123;</span><br><span class="line">        [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardBack&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [sender setTitle:@&quot;&quot; forState:UIControlStateNormal];</span><br><span class="line">        self.flipCount++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Card *card &#x3D; [self.deck drawRandomCard]; &#x2F;&#x2F; 从牌堆抽随机取一张Card</span><br><span class="line">        if(card) &#123; &#x2F;&#x2F; 牌堆里的牌抽完以后停止抽牌</span><br><span class="line">            [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardFront&quot;] forState:UIControlStateNormal];</span><br><span class="line">            [sender setTitle:card.contents forState:UIControlStateNormal]; &#x2F;&#x2F; 将Card的内容展示出来</span><br><span class="line">            self.flipCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFlipCount:(int)flipCount</span><br><span class="line">&#123;</span><br><span class="line">    _flipCount &#x3D; flipCount;</span><br><span class="line">    self.flipsLabel.text &#x3D; [NSString stringWithFormat:@&quot;Flips: %d&quot;,self.flipCount];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1goobso7hl7g30j816yx6r.gif" class="result2" width="300" height="700" title="最终效果2" alt="加载失败">



<h2 id="使该游戏变得真正可玩"><a href="#使该游戏变得真正可玩" class="headerlink" title="使该游戏变得真正可玩"></a>使该游戏变得真正可玩</h2><p>接下来我们让游戏变得真正可玩儿。在MVC开发模型中，游戏的逻辑属于Model，Model和UI是完全独立的，所以在编写过程中不需要考虑UI。</p>
<h3 id="Model开发"><a href="#Model开发" class="headerlink" title="Model开发"></a>Model开发</h3><p>首先添加一个新的类<code>CardMatchingGame</code>，这个类就是MVC模型中的Model，在编码<code>CardMathingGame</code>的过程中，需要思考需要哪些公开的API。</p>
<ol>
<li>首先是构造函数，因为需要传进一些参数，比如牌的张数，所以新建构造函数<code>initWithCardCount</code>，指定构造函数（designated initializer）</li>
<li>公开的属性 score，但同时我们不希望别人能够随意修改socre属性，因此需要在公开API中将其设置为readonly，同时在.m文件中的私密API中声明为readwrite。其实readwrite用的不多，因为默认情况下就是readwrite，只有在公开API只读的时候才会用到。</li>
<li>允许用户通过index选中纸牌<code>chooseCardAtIndex</code></li>
<li>通过index从牌堆中获取Card，<code>CardAtIndex</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; CardMatchingGame.h</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface CardMatchingGame : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; designated initializer</span><br><span class="line">- (instancetype)initWithCardCount:(NSUInteger)count usingDeck:(Deck *)deck;</span><br><span class="line">- (void)chooseCardAtIndex:(NSUInteger)index;</span><br><span class="line">- (Card *)cardAtIndex:(NSUInteger)index;</span><br><span class="line">@property (nonatomic, readonly) NSInteger score;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure>

<p>接下来开始在<code>CardMatchingGame.m</code>中开始实现:</p>
<ol>
<li><p>利用关键字<code>readwrite</code>使得属性score在<code>CardMatchingGame.m</code>中可写。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CardMatchingGame</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSInteger</span> score;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>新建属<code>cards</code>，用于存储游戏中的纸牌。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CardMatchingGame</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSInteger</span> score;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *cards; <span class="comment">// of Card</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改属性<code>cards</code>的<code>getter</code>函数</p>
<p>属性的默认初始值为nil，当属性<code>cards</code>的指针为nil时，创建一个<code>NSMutableArray</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-(NSMutableArray *)cards</span><br><span class="line">&#123;</span><br><span class="line">    if(!_cards) &#123;</span><br><span class="line">        _cards &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    return _cards;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现构造函数<code>initWithCardCount</code></p>
<p>这个构造函数是designated initializer，也就是说使用这个类的用户必须调用这个构造函数，否则类无法被正确的初始化。使用构造函数init会返回nil。这个信息要传递给用户，所以以注释的形式写在公开API中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-(instancetype) initWithCardCount:(NSUInteger)count usingDeck:(Deck *)deck</span><br><span class="line">&#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if(self) &#123;</span><br><span class="line">        for(int i &#x3D; 0;i &lt; count;i++) &#123;</span><br><span class="line">            Card *card &#x3D; [deck drawRandomCard];</span><br><span class="line">            if(card) &#123;</span><br><span class="line">                [self.cards addObject:card];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                self &#x3D; nil;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现函数<code>cardAtIndex</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (Card *)cardAtIndex:(NSUInteger)index</span><br><span class="line">&#123;</span><br><span class="line">    return index &lt; [self.cards count] ? self.cards[index] : nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现函数<code>chooseCardAtIndex</code></p>
<p>这个函数是游戏的关键。表示某个card被选中后的处理方式，包括匹配过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static const int PENALTY_SCORE &#x3D; 1;</span><br><span class="line">static const int COST_OF_CHOOSE &#x3D; 1;</span><br><span class="line"></span><br><span class="line">-(void)chooseCardAtIndex:(NSUInteger)index</span><br><span class="line">&#123;</span><br><span class="line">    Card *card &#x3D; [self cardAtIndex:index];</span><br><span class="line">    if(!card.isMatched) &#123;</span><br><span class="line">        &#x2F;&#x2F; if choosen card is not matched</span><br><span class="line">        if(card.isChosen) &#123; &#x2F;&#x2F; if the card is already chosen</span><br><span class="line">            card.chosen &#x3D; NO; &#x2F;&#x2F; filp the card back</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; match it against another card</span><br><span class="line">            &#x2F;&#x2F; here, only match two cards, but may make it match multiple cards in later</span><br><span class="line">            for(Card *otherCard in self.cards) &#123;</span><br><span class="line">                if(otherCard.isChosen &amp;&amp; !otherCard.isMatched) &#123; &#x2F;&#x2F; Bingo, find the card we want to match</span><br><span class="line">                    int matchScore &#x3D; [card match:@[otherCard]]; &#x2F;&#x2F; try to match it</span><br><span class="line">                    if(matchScore &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; not match</span><br><span class="line">                        self.score -&#x3D; PENALTY_SCORE; &#x2F;&#x2F; penalty of un match</span><br><span class="line">                        otherCard.chosen &#x3D; NO; &#x2F;&#x2F; flip the other card back</span><br><span class="line">                    &#125; else &#123; &#x2F;&#x2F; match</span><br><span class="line">                        self.score +&#x3D; matchScore;</span><br><span class="line">                        card.matched &#x3D; YES;</span><br><span class="line">                        otherCard.matched &#x3D; YES;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            card.chosen &#x3D; YES;</span><br><span class="line">            self.score -&#x3D; COST_OF_CHOOSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; if choosen card is already matched</span><br><span class="line">        &#x2F;&#x2F; do nothing</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="UI开发"><a href="#UI开发" class="headerlink" title="UI开发"></a>UI开发</h3><p>到目前，完成了App中Model的实现，接下来是实现App的UI。</p>
<ol>
<li><p>在UI中创建多张纸牌，可以通过复制粘贴的方式完成</p>
</li>
<li><p>创建OutletCollections，添加所有纸牌。</p>
<p>创建方法，右键点击某个button，按住“New Referencing Outlet Collections“，拖到<code>ViewController.m</code>中。</p>
<p>添加其他button的方法，按住Ctrl键，点击button并拖到<code>ViewController.m</code>中</p>
</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gopcewkpqrg30n80v41l3.gif" class="addOutletCollections" width="300" height="700" title="添加OutletCollections" alt="加载失败">

<ol start="3">
<li><p>在<code>ViewController.m</code>中引入<code>CardMatchingGame.h</code></p>
</li>
<li><p>新增<code>CardMatchingGame</code>的属性<code>game</code></p>
<p><code>@property (strong, nonatomic) CardMatchingGame *game;</code></p>
</li>
<li><p>重写属性<code>game</code>的<code>getter</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (CardMatchingGame *)game&#123;</span><br><span class="line">    <span class="keyword">if</span>(!_game) &#123;</span><br><span class="line">        _game = [[CardMatchingGame alloc] initWithCardCount:[<span class="keyword">self</span>.cardButtons count] usingDeck:[<span class="keyword">self</span> createDeck]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _game;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>ViewController.m</code>中创建函数<code>titleForCard</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSString *)titleForCard:(Card *)card</span><br><span class="line">&#123;</span><br><span class="line">    return card.isChosen ? card.contents : @&quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>ViewController.m</code>中创建函数<code>backgroundImageForCard</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)backgroundImageForCard:(Card *)card</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageNamed:card.isChosen ? <span class="string">@"CardFront"</span> : <span class="string">@"CardBack"</span>]; <span class="comment">// CardFront &amp; CardBack are name of card image</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>ViewController.m</code>中创建函数<code>updateUI</code>用于同步Model和UI。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateUI</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIButton</span> *cardButton <span class="keyword">in</span> <span class="keyword">self</span>.cardButtons) &#123;</span><br><span class="line">        <span class="keyword">int</span> cardIndex = [<span class="keyword">self</span>.cardButtons indexOfObject:cardButton];</span><br><span class="line">        Card *card = [<span class="keyword">self</span>.game cardAtIndex:cardIndex];</span><br><span class="line">        [cardButton setTitle:[<span class="keyword">self</span> titleForCard:card] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        [cardButton setBackgroundImage:[<span class="keyword">self</span> backgroundImageForCard:card] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        cardButton.enabled = !card.isMatched;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Touch Up Inside事件，命名为touchCardButton，并将所有button加入其中，方法类似于步骤2.</p>
</li>
<li><p><code>.m</code>文件中实现<code>touchCardButton</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)touchCardButton:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">    <span class="keyword">int</span> cardIndex = [<span class="keyword">self</span>.cardButtons indexOfObject:sender];</span><br><span class="line">    [<span class="keyword">self</span>.game chooseCardAtIndex:cardIndex];</span><br><span class="line">    [<span class="keyword">self</span> updateUI];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>到这个时候App已经可以运行了，运行效果如下：</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosmu8s2gmg30j01261kx.gif" class="result3" width="300" height="700" title="最终效果3" alt="加载失败">

<p>可以正常运行，但是两张黑桃却没有正常匹配，问题出在哪里？</p>
<p>问题在我们在<a href="https://zhang-tianxu.github.io/chinese/2021/03/15/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B2/">课程2</a>中实现的<code>Card</code>类中的匹配函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Card.m</span><br><span class="line">- (int)match:(NSArray *)otherCards</span><br><span class="line">&#123;</span><br><span class="line">  int score &#x3D; 0;</span><br><span class="line">  for(Card *card in otherCards) &#123;</span><br><span class="line">    if([card.contents isEqualToString:self.contents])</span><br><span class="line">      score &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">    return score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这显然不是一个完整的匹配逻辑。</p>
<p>所以需要在<code>PlayingCard</code>类的<code>.m</code>文件中重构<code>match</code>函数。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">int</span>)match:(<span class="built_in">NSArray</span> *)otherCards</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>([otherCards count] == <span class="number">1</span>) &#123;</span><br><span class="line">        PlayingCard *otherCard = [otherCards firstObject];</span><br><span class="line">        <span class="keyword">if</span>([<span class="keyword">self</span>.suit isEqualToString:otherCard.suit]) &#123; <span class="comment">// 如果花色匹配</span></span><br><span class="line">            score = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span>.rank == otherCard.rank]) &#123; <span class="comment">// 如果数字匹配</span></span><br><span class="line">            score = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在完成了匹配规则，最后一个任务是添加一个<code>Label</code>用于展示分数。</p>
<ol>
<li><p>在UI中增加一个Label</p>
</li>
<li><p>为Label增加一个Outlet</p>
</li>
<li><p>在<code>updateUI</code>中更新score Label。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)updateUI</span><br><span class="line">&#123;</span><br><span class="line">    for (UIButton *cardButton in self.cardButtons) &#123;</span><br><span class="line">        int cardIndex &#x3D; [self.cardButtons indexOfObject:cardButton];</span><br><span class="line">        Card *card &#x3D; [self.game cardAtIndex:cardIndex];</span><br><span class="line">        [cardButton setTitle:[self titleForCard:card] forState:UIControlStateNormal];</span><br><span class="line">        [cardButton setBackgroundImage:[self backgroundImageForCard:card] forState:UIControlStateNormal];</span><br><span class="line">        cardButton.enabled &#x3D; !card.isMatched;</span><br><span class="line">    &#125;</span><br><span class="line">    self.scoreLabel.text &#x3D; [NSString stringWithFormat:@&quot;Score: %d&quot;, self.game.score];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosov9rkvfg30j0126kjl.gif" class="result4" width="300" height="700" title="最终效果4" alt="加载失败">

<p>至此，一个可玩的纸牌匹配游戏App已经完成，大家可以试着让App可以同时匹配三张及以上的纸牌。</p>
]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发入门</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福大学IOS7开发课程2</title>
    <url>/chinese/2021/03/15/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B2/</url>
    <content><![CDATA[<h1 id="斯坦福大学IOS7开发课程2"><a href="#斯坦福大学IOS7开发课程2" class="headerlink" title="斯坦福大学IOS7开发课程2"></a>斯坦福大学IOS7开发课程2</h1><p>这节课就着手开始实现”Card Matching Game”，纸牌匹配游戏。</p>
<p>具体来说就是实现涉及的各种类，以及XCode的简单使用。</p>
<a id="more"></a>

<h2 id="Card类"><a href="#Card类" class="headerlink" title="Card类"></a>Card类</h2><p>下面代码是<a href="https://zhang-tianxu.github.io/chinese/2021/03/15/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B1/">课程1</a>结束时的Card类，包括<code>Card.h</code>和<code>Card.m</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Card.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation&gt;</span><br><span class="line">@interface Card : NSObject</span><br><span class="line">@property (strong nonatomic) NSString *contents;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, getter&#x3D;isChosen) BOOL chosen;</span><br><span class="line">@property (nonatomic, getter&#x3D;isMatched) BOOL matched;</span><br><span class="line">- (int)match:(NSArray *)otherCards;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Card.m</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line">@interface Card()</span><br><span class="line">@end</span><br><span class="line">@implementation Card</span><br><span class="line"></span><br><span class="line">- (int)match:(NSArray *)otherCards</span><br><span class="line">&#123;</span><br><span class="line">  int score &#x3D; 0;</span><br><span class="line">  for(Card *card in otherCards) &#123;</span><br><span class="line">    if([card.contents isEqualToString:self.contents])</span><br><span class="line">      score &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="Deck类"><a href="#Deck类" class="headerlink" title="Deck类"></a>Deck类</h2><p>这节课首先添加另外一个类：整幅牌Deck，下面是上节课学的类的基本结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Deck : NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.m</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">@interface Deck()</span><br><span class="line">@end</span><br><span class="line">@implementation Deck</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>接下来为Deck类添加两个基础的方法:</p>
<ul>
<li>向Deck中添加牌的<code>addCard</code>，其中atTop表示是否将新的牌放在牌堆的顶部。</li>
<li>另一个是从Deck中随机抽取牌的<code>drawRandomCard</code>：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line"></span><br><span class="line">@interface Deck : NSObject</span><br><span class="line">- (void)addCard:(Card *)card atTop:(BOOL)atTop;</span><br><span class="line"></span><br><span class="line">- (Card *)drawRandomCard;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>如果希望<code>addCard</code>的参数<code>atTop</code>是<strong>可选参数</strong>，在Objective-C中唯一的方法就是声明一个新的函数，这个函数也叫<code>addCard</code>，但是没有参数<code>atTop</code>。这两个<code>addCard</code>是两个不同的函数，相互之间并没有关联。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line"></span><br><span class="line">@interface Deck : NSObject</span><br><span class="line">- (void)addCard:(Card *)card atTop:(BOOL)atTop;</span><br><span class="line">- (void)addCard:(Card *)card;</span><br><span class="line"></span><br><span class="line">- (Card *)drawRandomCard;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>为了存储牌堆中的牌，需要在私密API中添加一个属性，类型是可变数组<code>NSMutableArray</code>。mutable意味着可以向数组中添加或删除数据，而普通的<code>NSArray</code>是不能修改的，一旦被建立，不能添加数据也不能删除。</p>
<p><strong>在Objective-C中声明数组没办法指定数据类型。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.m</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">@interface Deck()</span><br><span class="line">@property (strong, nonatomic) NSMutableArray *cards; &#x2F;&#x2F; of Card</span><br><span class="line">@end</span><br><span class="line">@implementation Deck</span><br><span class="line">  </span><br><span class="line">- (void)addCard:(Card *)card atTop:(BOOL)atTop</span><br><span class="line">&#123;</span><br><span class="line">  if (atTop) &#123;</span><br><span class="line">    [self.cards insertObject:card atIndex:0];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    [self.cards addObject:card];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addCard:(Card *)card</span><br><span class="line">&#123;</span><br><span class="line">  [self addCard:card atTop:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Card *)drawRandomCard</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>根据上节课说到构建属性时自动生成的getter和setter，新建一个Deck类后，其所有的变量和属性都<strong><em>会被自动初始化为0/nil</em></strong>，属性<code>cards</code>是一个空指针，因此调用<code>addCard</code>时虽然不会导致程序的崩溃，但是也不能正常工作。</p>
<p>那么怎么解决这个问题呢？方法是重写属性的getter函数，在getter中添加一个判断结构，属性cards自动生成的getter是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSMutableArray *)cards</span><br><span class="line">&#123;</span><br><span class="line">  return _cards;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了在其中添加一个判断逻辑，需要手动重写这个getter：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.m</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">@interface Deck()</span><br><span class="line">@property (strong, nonatomic) NSMutableArray *cards; &#x2F;&#x2F; of Card</span><br><span class="line">@end</span><br><span class="line">@implementation Deck</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 为了处理cards为空指针的情况，手动重写getter</span><br><span class="line">- (NSMutableArray *)cards</span><br><span class="line">&#123;</span><br><span class="line">  if(!_cards) _cards &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">  return _cards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addCard:(Card *)card atTop:(BOOL)atTop</span><br><span class="line">&#123;</span><br><span class="line">  if (atTop) &#123;</span><br><span class="line">    [self.cards insertObject:card atIndex:0];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    [self.cards addObject:card];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addCard:(Card *)card</span><br><span class="line">&#123;</span><br><span class="line">  [self addCard:card atTop:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Card *)drawRandomCard</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>接下来实现<code>drawRandomCard</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.m</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">@interface Deck()</span><br><span class="line">@property (strong, nonatomic) NSMutableArray *cards; &#x2F;&#x2F; of Card</span><br><span class="line">@end</span><br><span class="line">@implementation Deck</span><br><span class="line"></span><br><span class="line">- (  NSMutableArray *)cards</span><br><span class="line">&#123;</span><br><span class="line">  if(!_cards) _cards &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">  return _cards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addCard:(Card *)card atTop:(BOOL)atTop</span><br><span class="line">&#123;</span><br><span class="line">  if (atTop) &#123;</span><br><span class="line">    [self.cards insertObject:card atIndex:0];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    [self.cards addObject:card];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addCard:(Card *)card</span><br><span class="line">&#123;</span><br><span class="line">  [self addCard:card atTop:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Card *)drawRandomCard</span><br><span class="line">&#123;</span><br><span class="line">  Card *randomCard &#x3D; nil;</span><br><span class="line">  </span><br><span class="line">  if([self.cards count]) &#123;</span><br><span class="line">    unsigned index &#x3D; arc4random() % [self.cards count];</span><br><span class="line">    randomCard &#x3D; self.cards[index];</span><br><span class="line">    [self.cards removeObjectAtIndex:index];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return randomCard;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>至此，Deck类已经完成。</p>
<h2 id="PlayingCard类"><a href="#PlayingCard类" class="headerlink" title="PlayingCard类"></a>PlayingCard类</h2><p>接下来再添加一个类：<code>PlayingCard</code>，同样的，基本结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.h</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line">@interface PlayingCard : Card &#x2F;&#x2F; 终于有个类的父类不是NSObject了</span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>给类添加两个属性<code>suit</code>和<code>rank</code>，前者表示牌的花色“桃（hearts）”、“（方片）diamons”、“（梅花）clubs”，后者表示1到13。另外在<code>.m</code>文件中，重写父类属性content的getter。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.h</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line">@interface PlayingCard : Card</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) NSString *suit;</span><br><span class="line">@property (nonatomic) NSUInteger rank;</span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  return [NSString stringWithFormat:@&quot;%d%@&quot;,self.rank, self.suit];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>注意到，字符串前面有个<code>@</code>，这<strong><em>表示把字符串变成一个字符串类</em></strong>。其中<code>%@</code>表示一个对象，当然可以是字符串。</p>
<p>重写父类属性contents的getter之后，获取contents内容会返回“数字 + 花色”，比如“3红桃”、“1梅花”、“13方片”等。但是在纸牌中，我们一般会把1说成A，11说成J等……，为了符合这个习惯，上面的contents重写可以改成下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  NSArray *rankStrings &#x3D; @[@&quot;?&quot;,@&quot;A&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;10&quot;,@&quot;J&quot;,@&quot;Q&quot;,@&quot;K&quot;];</span><br><span class="line">  &#x2F;&#x2F; 将0-13表示为?,1,2,...,J,Q,K</span><br><span class="line">  return [rankStrings[self.rank] stringByAppendingString:self.suit];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>将rank的0设置为”？“是因为objective-C默认将rank初始化为0，”？“表示这是未知的，没有经过设置的。那如果花色没经过设置也会显示”？“就更好了，解决方法也是重写suit属性的getter函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  NSArray *rankStrings &#x3D; @[@&quot;?&quot;,@&quot;A&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;10&quot;,@&quot;J&quot;,@&quot;Q&quot;,@&quot;K&quot;];</span><br><span class="line">  &#x2F;&#x2F; 将0-13表示为?,1,2,...,J,Q,K</span><br><span class="line">  return [rankStrings[self.rank] stringByAppendingString:self.suit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  return _suit?_suit:@&quot;?&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>suit的选择应该只有四种，为了防止suit被设置为其他值，还要重写suit属性的setter：<code>setSuit</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  NSArray *rankStrings &#x3D; @[@&quot;?&quot;,@&quot;A&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;10&quot;,@&quot;J&quot;,@&quot;Q&quot;,@&quot;K&quot;];</span><br><span class="line">  &#x2F;&#x2F; 将0-13表示为?,1,2,...,J,Q,K</span><br><span class="line">  return [rankStrings[self.rank] stringByAppendingString:self.suit];</span><br><span class="line">&#125;</span><br><span class="line">@synthesize suit &#x3D; _suit;</span><br><span class="line">&#x2F;&#x2F; 因为重构了suit的getter和setter，所以要手写@synthesize</span><br><span class="line">- (void)setSuit:(NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  if([@[@&quot;♥️&quot;,@&quot;♦️&quot;,@&quot;♠️&quot;,@&quot;♣️&quot;] containsObject:suit]) &#123;</span><br><span class="line">    _suit &#x3D; suit;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  return _suit?_suit:@&quot;?&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>值得注意的是，<code>setSuit</code>中的第一个<code>@</code>表示创建新的数组，在这里，每次判断都会新建这个数组。为了性能和代码简介，可以新建函数来判断setter收到的suit是否有效。实际上，这种改变对性能的提升是极其有限的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  NSArray *rankStrings &#x3D; @[@&quot;?&quot;,@&quot;A&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;10&quot;,@&quot;J&quot;,@&quot;Q&quot;,@&quot;K&quot;];</span><br><span class="line">  &#x2F;&#x2F; 将0-13表示为?,1,2,...,J,Q,K</span><br><span class="line">  return [rankStrings[self.rank] stringByAppendingString:self.suit];</span><br><span class="line">&#125;</span><br><span class="line">@synthesize suit &#x3D; _suit;</span><br><span class="line">&#x2F;&#x2F; 因为重构了suit的getter和setter，所以要手写@synthesize</span><br><span class="line"></span><br><span class="line">+ (NSArray *)validSuits</span><br><span class="line">&#123;</span><br><span class="line">  return @[@&quot;♥️&quot;,@&quot;♦️&quot;,@&quot;♠️&quot;,@&quot;♣️&quot;];</span><br><span class="line">&#125;</span><br><span class="line">- (void)setSuit:(NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  if([[PlayingCard validSuits] containsObject:suit]) &#123;</span><br><span class="line">    &#x2F;&#x2F; 类的函数的调用方法。</span><br><span class="line">    _suit &#x3D; suit;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  return _suit?_suit:@&quot;?&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>这里在函数实现前面第一次出现了<code>+</code>符号，这个符号表示这个函数是<strong>类的函数</strong>（而不是对象的函数）。</p>
<p><strong><em>一般只在两种情况下使用类的函数：</em></strong></p>
<ol>
<li><p>工具函数（utility method），比如这里的<code>validSuits</code>。</p>
</li>
<li><p>创建类的函数，比如<code>stringWithFormat</code>。</p>
<p>对rank属性做同样的检查和优化，并添加一个公开API<code>maxRank</code>返回rank的最大值，比如现在是13。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.h</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line">@interface PlayingCard : Card</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) NSString *suit;</span><br><span class="line">@property (nonatomic) NSUInteger rank;</span><br><span class="line"></span><br><span class="line">+ (NSArray *)validSuits;</span><br><span class="line">+ (NSUInteger)maxRank;</span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  NSArray *rankStrings &#x3D; [PlayingCard rankStrings];</span><br><span class="line">  &#x2F;&#x2F; 将0-13表示为?,1,2,...,J,Q,K</span><br><span class="line">  return [rankStrings[self.rank] stringByAppendingString:self.suit];</span><br><span class="line">&#125;</span><br><span class="line">@synthesize suit &#x3D; _suit;</span><br><span class="line">&#x2F;&#x2F; 因为重构了suit的getter和setter，所以要手写@synthesize</span><br><span class="line"></span><br><span class="line">+ (NSArray *)validSuits</span><br><span class="line">&#123;</span><br><span class="line">  return @[@&quot;♥️&quot;,@&quot;♦️&quot;,@&quot;♠️&quot;,@&quot;♣️&quot;];</span><br><span class="line">&#125;</span><br><span class="line">- (void)setSuit:(NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  if([[PlayingCard validSuits] containsObject:suit]) &#123;</span><br><span class="line">    &#x2F;&#x2F; 类的函数的调用方法。</span><br><span class="line">    _suit &#x3D; suit;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  return _suit?_suit:@&quot;?&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSArray *)rankStrings</span><br><span class="line">&#123;</span><br><span class="line">  return @[@&quot;?&quot;,@&quot;A&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;10&quot;,@&quot;J&quot;,@&quot;Q&quot;,@&quot;K&quot;];</span><br><span class="line">&#125;</span><br><span class="line">+ (NSUInteger)maxRank</span><br><span class="line">&#123;</span><br><span class="line">  return [[self rankStrings] count]-1;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setRank:(NSUInteger)rank</span><br><span class="line">&#123;</span><br><span class="line">  if(rank &lt;&#x3D; [PlayingCard maxRank]) &#123;</span><br><span class="line">    _rank &#x3D; rank;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="PlayingCardDeck类"><a href="#PlayingCardDeck类" class="headerlink" title="PlayingCardDeck类"></a>PlayingCardDeck类</h2><p>接下来可以开始玩牌了，创建一个新的类<code>PlayingCardDeck</code>，继承自<code>Deck</code>类，但是需要<strong>重写构造函数</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCardDeck.h</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line"></span><br><span class="line">@interface PlayingCardDeck : Deck</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCardDeck.m</span><br><span class="line">#import &quot;PlayingCardDeck.h&quot;</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation PlayingCardDeck</span><br><span class="line">- (instancetype)init &#x2F;&#x2F; instancetype类只在init中使用</span><br><span class="line">&#123;</span><br><span class="line">  self &#x3D; [super init];</span><br><span class="line">  &#x2F;&#x2F; 调用父类的构造函数</span><br><span class="line">  if(self) &#123; </span><br><span class="line">    &#x2F;&#x2F; 父类正常完成构造，继续子类的构造函数</span><br><span class="line">    &#x2F;&#x2F; 如果父类无法完成构造，将不执行子类的构造代码</span><br><span class="line">    for (NSString *suit in [PlayingCard validSuits]) &#123;</span><br><span class="line">      for (NSUInteger rank &#x3D; 1; rank &lt;&#x3D; [PlayingCard maxRank]; rank++) &#123;</span><br><span class="line">        PlayingCard *card &#x3D; [[PlayingCard allo] init];</span><br><span class="line">        card.rank &#x3D; rank;</span><br><span class="line">        card.suit &#x3D; suit;</span><br><span class="line">        [self addCard:card];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="XCode的简单使用"><a href="#XCode的简单使用" class="headerlink" title="XCode的简单使用"></a>XCode的简单使用</h2><p>课程剩余的部分就是以纸牌游戏为例，简单介绍XCode的使用，开发一个简单的App，App内容是显示纸牌，点击纸牌将其翻转。</p>
<p>由于课程介绍的是XCode 5，笔者记笔记的时候已经是XCode 12.4了，有了不小的变化，参考笔者另一篇笔记（<a href="https://zhang-tianxu.github.io/chinese/2021/03/09/Objective-C-IOS%E5%BC%80%E5%8F%91%E4%B9%8BHelloWorld/">Objective-C IOS开发之HelloWorld</a>），应该也不难完成，就不再具体介绍实现了。</p>
<p>相较于HelloWorld这个App，课程中实现的App另外涉及了以下知识点：</p>
<ul>
<li><p>图像添加</p>
<p>直接将图片拖到<code>Assets.xcassets</code>文件夹中</p>
</li>
<li><p>button背景图片的设置</p>
<p>点击button，在属性中点击<code>Background</code>下拉菜单，就会显示上一步添加的图片选项，以及一些原始icon。</p>
</li>
<li><p>Action中的sender其实就是触发事件的View对象</p>
</li>
<li><p>类的添加</p>
<p>添加类的方法，XCode 12中其实就是新建<code>Cocoa Touch Class</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发入门</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福大学IOS7开发课程1</title>
    <url>/chinese/2021/03/15/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B1/</url>
    <content><![CDATA[<h1 id="斯坦福大学IOS7开发课程1"><a href="#斯坦福大学IOS7开发课程1" class="headerlink" title="斯坦福大学IOS7开发课程1"></a>斯坦福大学IOS7开发课程1</h1><p>IOS7开发课程讲了如何利用Objective-C语言开发IOS App，而且涉及到很多必须的基础知识，非常值得学习。</p>
<p>课程1讲了一些关于课程安排和作业的事情，自学就不需要了，只选取下面三个<strong>知识点：</strong></p>
<ul>
<li>IOS里有什么</li>
<li>MVC开发模型</li>
<li>Objective-C</li>
</ul>
<a id="more"></a>

<h2 id="IOS里有什么"><a href="#IOS里有什么" class="headerlink" title="IOS里有什么"></a>IOS里有什么</h2><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gok87jp5hnj20lq15ctky.jpg" class="inIOS" width="300" height="700" title="IOS里有什么" alt="加载失败">

<p>总的来说，可以将IOS涉及的组件分为4组或者说4层：</p>
<ul>
<li><p>Core OS</p>
<p>最接近硬件的一层，其实就是Unix操作系统，Unix内核中有的功能，Core OS都有，比如：</p>
<ul>
<li>OSX Kernel</li>
<li>Power Management</li>
<li>Sockets</li>
<li>File System</li>
</ul>
<p>等等……</p>
</li>
<li><p>Core Services</p>
<p>基于Core OS的面向对象层。</p>
<p>Core OS层的API几乎都是用C写的，为了以<em>面向对象</em>的方式编程，加入了Core Services层。这一层包括：</p>
<ul>
<li>Collections</li>
<li>File Access</li>
<li>Networking</li>
<li>Threading</li>
<li>SQLite</li>
<li>Core Location</li>
</ul>
<p>等等</p>
</li>
<li><p>Media</p>
<p>用于展现多媒体，包括视频、图片、声音、文件等等，是非常重要的一层。</p>
</li>
<li><p>Cocoa Touch</p>
<p>Cocoa的API起源于Mac OS X，已经有三十年左右的历史了，是UI层。对IOS开发者来说是需要花比较多时间来学习的一层。这一层可以用来构建按键、滑块、开关、文字输入、动画等等。包括：</p>
<ul>
<li>Multi-Touch</li>
<li>Alerts</li>
<li>Web View</li>
<li>Camera</li>
<li>Controls</li>
</ul>
<p>等等。</p>
</li>
</ul>
<h2 id="MVC开发模型"><a href="#MVC开发模型" class="headerlink" title="MVC开发模型"></a>MVC开发模型</h2><p>Model View Controller是一种用于组织应用程序中所有类的策略，将每个类分成Model 阵营、Controller 阵营或者View 阵营中的额一个。</p>
<p>Model用来描述你的程序是什么，以纸牌游戏为例，纸牌、牌桌甚至玩牌的规则都是独立于UI的，应该放在Model阵营中。至于纸牌是如何展示在屏幕上的，是由Controller负责的，Controller负责如何展现Model，以及展现Model的动画等。View是Controller的下属，是Controller用于构建UI的组件。</p>
<p>View是通用的，比如按键、开关等，是所有程序通用的，而Contrller是针对程序设计的，Model则是完全独立于UI的。</p>
<h3 id="MVC模型中三个阵营之间的通信"><a href="#MVC模型中三个阵营之间的通信" class="headerlink" title="MVC模型中三个阵营之间的通信"></a>MVC模型中三个阵营之间的通信</h3><h4 id="Controller-gt-Model"><a href="#Controller-gt-Model" class="headerlink" title="Controller -&gt; Model"></a>Controller -&gt; Model</h4><p>  Controller了解Model的一切，并且可以任意给Model发消息。</p>
<h4 id="Controller-gt-View"><a href="#Controller-gt-View" class="headerlink" title="Controller -&gt; View"></a>Controller -&gt; View</h4><p>  Controller也可以任意给View发送消息，如果Controller有个property指向View，把这个property成为<strong><em>outlet</em></strong>。</p>
<h4 id="Model-lt-gt-View"><a href="#Model-lt-gt-View" class="headerlink" title="Model &lt;-&gt; View"></a>Model &lt;-&gt; View</h4><p>  永远<strong>不要</strong>让Model和View之间直接通信。因为Model应该是完全独立于UI的，所以不应该给View发消息，而View是通用的，所以也不应该发消息给Model。</p>
<h4 id="View-gt-Controller"><a href="#View-gt-Controller" class="headerlink" title="View -&gt; Controller"></a>View -&gt; Controller</h4><p>View能向Controller发消息么？可以是可以，但是因为View是通用的，它对Controller并不了解，所以他们只能通过约定好的形式向Controller发送消息，有两种方式：</p>
<ul>
<li><p>target action</p>
<p>Controller在内部建立一个target，并给View一个action。当View执行一些操作，比如按键被按下的时候，view会向Controller内的target发射action，这种方式下，View可以不了解Controller，只需要知道某些操作被执行时向Controller发送action。</p>
</li>
<li><p>delegate</p>
<p>target action方式没办法处理非常复杂的通信。比如在一个滚动框中，用户按下手指准备滚动，需要让Controller知道用户要滚动了。因为是否允许用户的滚动请求，View是不知道的，所以需要让Controller代理其执行。有一种特殊的delegate，称为data source。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gok7sf8e9mj20xm0jadhu.jpg" alt="image-20210314123540992"></p>
</li>
</ul>
<p>View并不拥有它们展示的数据</p>
<h4 id="Model-gt-Controller"><a href="#Model-gt-Controller" class="headerlink" title="Model -&gt; Controller"></a>Model -&gt; Controller</h4><p>那么model能向Controller发送消息么？</p>
<p>model应该是完全独立于UI的，所以不能直接向Controller发送消息。但有的时候确实有这样的需求，比如Model中数据变化了，需要告诉Controller，这时可以通过广播的方式，向所有感兴趣的人发送消息，其中当然可以包括Controller</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gok7tedpf9j20wc0jstw6.jpg" alt="image-20210314123951433"></p>
<h3 id="MVCs模型"><a href="#MVCs模型" class="headerlink" title="MVCs模型"></a>MVCs模型</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gok7tphhwkj211q0mg4qp.jpg" alt="image-20210314124445333"></p>
<h2 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C"></a>Objective-C</h2><p>Objective-C的一些基础语法可以到<a href="https://www.yiibai.com/objective_c/" target="_blank" rel="noopener">易百Objective-C教程</a>学习，本课程中只是讲了一些和C/C++等语言不通的地方。和常见的编程语言C++或java相比，Objective-C有个重要的概念“Properties”，在Objective-C中一般不直接读写实例的变量，properties是Objective-C中读写实例的变量的方法，一般由getter函数和setter函数组成。</p>
<p>在Objective-C中，每个类由一个<code>.h</code>头文件的头文件和一个<code>.m</code>的实现文件。其中，<code>.h</code>中是公开的API，<code>.m</code>中是私密API和具体的实现。</p>
<p>在<code>.h</code>中声明类时，必须给定类的父类，其中<code>NSObject</code>是几乎所有类的父类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.h</span><br><span class="line">@interface Test: NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>由于使用了<code>NSObject</code>作为父类，所以需要引入这个类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.h</span><br><span class="line">#import &lt;Foundation&#x2F;NSObject.h&gt;</span><br><span class="line">@interface Test: NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在IOS中一般不会只引进这个类，而是将整个<code>Foundation</code>框架引进来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">@interface Test: NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在<code>.m</code>实现文件中当然要引入头文件，<code>@implementation</code>表示类的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.m</span><br><span class="line">#import &quot;Test.h&quot;</span><br><span class="line">@implementation Test</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>同时<code>.m</code>中可以添加一些私密API</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.m</span><br><span class="line">#import &quot;Test.h&quot;</span><br><span class="line">@interface Test()&#x2F;&#x2F;添加私密API</span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">@implementation Test</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>下面介绍Objective-C的Properties概念，通过<code>@property</code>在<code>.h</code>中添加一个属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">@interface Test: NSObject</span><br><span class="line">  @property (strong nonatomic) NSString *name;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>下面详细说一下<code>property</code>这行代码的构成：</p>
<p><strong>首先</strong>是关键字<code>(strong)</code>。在Objective-C中，所有的对象都被放在堆中，通过指针使用它们。通过这种方式，Objective-C不需要编程人员手动分配和释放内存地址，那么Objective-C如何知道何时释放内存呢？这就是属性声明中<code>(stong)</code>的作用，相应的还有<code>(weak)</code>。在内存管理时，只要有任意一个<code>strong</code>指针指向内存，内存就会被保留，最有一个<code>strong</code>指针被删除时，该地址会<strong>立即</strong>被回收，此时如果还有<code>weak</code>指针指向改地址，<code>weak</code>指针会被置为空。</p>
<p>对于元类型（int、bool等）的属性，不需要声明<code>strong</code>或<code>weak</code>，因为这种类型的属性并不存储在堆中，不需要内存管理。</p>
<p>与其他语言不通，在Objective-C中，引用空指针并不会导致程序崩溃，在Objective-C中你甚至可以给空指针发送数据，也不会导致程序崩溃，当然你给空指针发数据，虽然不会导致程序崩溃，也不会执行任何代码，如果发送的消息需要返回，返回值会被设为0。</p>
<p><strong>然后</strong>是关键字<code>nonatomic</code>，非原子操作。这个关键字的意思是属性的getter和setter<strong>不是线程安全的</strong>，在IOS中一般并不需要属性是线程安全的。在声明属性的同时，Objective-C会自动创建getter和setter方法。如果添加了<code>nonatomic</code>关键字，自动生成的代码是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@synthesize name &#x3D; _name;</span><br><span class="line">- (NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">  return _name;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">  _name &#x3D; name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>@synthesize</code>表示<code>_name</code>是<code>name</code>的别名。这些代码并不会显示出来，但可以直接使用。使用setter和getter的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myTest.name &#x3D; @&quot;Hello World&quot;;</span><br><span class="line">NSLog(@&quot;%@&quot;,myTest.name);</span><br></pre></td></tr></table></figure>

<p>当然也可以用中括号的方式调用，但建议使用上面的方式调用setter和getter。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[myTest setName:@&quot;Hello World&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[myTest name]);</span><br></pre></td></tr></table></figure>

<p>如果不添加<code>nonatomic</code>关键字，自动生成的代码会复杂很多，因为需要添加锁。为了简单，一般都会加上<code>nonatomic</code>关键字。</p>
<p><strong>另外</strong>，如果想要重命名属性的getter和setter，可以通过一下方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, getter &#x3D; getName, setter &#x3D; setName) NSString name;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发入门</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C IOS开发之SQLite数据库</title>
    <url>/chinese/2021/03/10/Objective-C-IOS%E5%BC%80%E5%8F%91%E4%B9%8BSQLite%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>IDE: XCode Version 12.4 (12D4e)</p>
<p>参考<a href="https://www.tutorialspoint.com/ios/ios_sqlite_database.htm" target="_blank" rel="noopener">IOS开发教程</a></p>
<h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><a id="more"></a>

<ol>
<li><p>Xcode创建一个APP</p>
</li>
<li><p>选中项目文件，选中TARGETS，然后在框架（frameworks, Libraries, and Embedded Content）中添加<strong>libsqlite3.tbd</strong>（libsqlite3.0.tbd也一样）</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof54maa10j314p0u0af4.jpg" class="addSQLiteLibImg" width="500" height="600" title="添加SQLite库" alt="加载失败">
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof54tkttyj30ng0qon0f.jpg" class="addSQLiteLibImg2" width="500" height="300" title="添加SQLite库2" alt="加载失败">
</li>
<li><p>新建Objective-C类（File-&gt;New-&gt;File）选择Cocoa Touch Class，点击Next，Subclass of选择NSObject，language选Objective-C。</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof56z2pxuj30u00xm4ee.jpg" class="addObjcClassImg" width="800" height="300" title="添加Objective-C类" alt="加载失败">
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof57eshyqj315i0te0y6.jpg" class="addObjcClassImg2" width="400" height="300" title="添加Objective-C类2" alt="加载失败">
</li>
<li><p>将类的名字命名为DBManager，点击Next创建</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof57v7yg2j31600u0gpo.jpg" class="addDBManager" width="400" height="300" title="创建DBManager" alt="加载失败">
</li>
<li><p>项目中会增加<code>DBManager.h</code>和<code>DBManager.m</code>两个文件，其代码是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;DBManager.h</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#import &lt;sqlite3.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface DBManager : NSObject &#123;</span><br><span class="line">    NSString *databasePath;</span><br><span class="line">&#125;</span><br><span class="line">+(DBManager*)getSharedInstance;</span><br><span class="line">-(BOOL)createDB;</span><br><span class="line">-(BOOL) saveData:(NSString*)registerNumber name:(NSString*)name department:(NSString*)department year:(NSString*)year;</span><br><span class="line">-(NSArray*) findByRegisterNumber:(NSString*)registerNumber;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;DBManager.m</span><br><span class="line"></span><br><span class="line">#import &quot;DBManager.h&quot;</span><br><span class="line"></span><br><span class="line">static DBManager *sharedInstance &#x3D; nil;</span><br><span class="line">static sqlite3 *database &#x3D; nil;</span><br><span class="line">static sqlite3_stmt *statement&#x3D; nil;</span><br><span class="line"></span><br><span class="line">@implementation DBManager</span><br><span class="line"></span><br><span class="line">+(DBManager*)getSharedInstance&#123;</span><br><span class="line">    if(!sharedInstance) &#123;</span><br><span class="line">        sharedInstance &#x3D; [[super allocWithZone:NULL]init];</span><br><span class="line">        [sharedInstance createDB];</span><br><span class="line">    &#125;</span><br><span class="line">    return sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(BOOL)createDB &#123;</span><br><span class="line">    NSString *docsDir;</span><br><span class="line">    NSArray *dirPaths;</span><br><span class="line">    &#x2F;&#x2F; get the documents directory</span><br><span class="line">    dirPaths &#x3D; NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">    docsDir &#x3D; dirPaths[0];</span><br><span class="line">    &#x2F;&#x2F; build the path to the database file</span><br><span class="line">    databasePath &#x3D; [[NSString alloc] initWithString:[docsDir stringByAppendingPathComponent:@&quot;student.db&quot;]];</span><br><span class="line">    BOOL isSuccess &#x3D; YES;</span><br><span class="line">    NSFileManager* filemgr &#x3D; [NSFileManager defaultManager];</span><br><span class="line">    </span><br><span class="line">    if([filemgr fileExistsAtPath:databasePath] !&#x3D; NO) &#123;</span><br><span class="line">        const char *dbpath &#x3D; [databasePath UTF8String];</span><br><span class="line">        if(sqlite3_open(dbpath, &amp;database) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">            char *errMsg;</span><br><span class="line">            const char *sql_stmt &#x3D;</span><br><span class="line">            &quot;create table if not exists studentsDetail (regno integer primary key, name text, department text, year text)&quot;;</span><br><span class="line">            if(sqlite3_exec(database, sql_stmt, NULL, NULL, &amp;errMsg) !&#x3D; SQLITE_OK) &#123;</span><br><span class="line">                isSuccess &#x3D; NO;</span><br><span class="line">                NSLog(@&quot;Fail to create table&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sqlite3_close(database);</span><br><span class="line">            return isSuccess;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            isSuccess &#x3D; NO;</span><br><span class="line">            NSLog(@&quot;Fail to open&#x2F;create database&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return isSuccess;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(BOOL)saveData:(NSString *)registerNumber name:(NSString *)name department:(NSString *)department year:(NSString *)year; &#123;</span><br><span class="line">    const char *dbpath &#x3D; [databasePath UTF8String];</span><br><span class="line">    </span><br><span class="line">    if(sqlite3_open(dbpath, &amp;database) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">        NSString *insertSQL &#x3D; [NSString stringWithFormat:@&quot;insert into studentsDetail (regno, name, department, year) values (\&quot;%ld\&quot;,\&quot;%@\&quot;,\&quot;%@\&quot;,\&quot;%@\&quot;)&quot;,(long)[registerNumber integerValue], name, department, year];</span><br><span class="line">        const char *insert_stmt &#x3D; [insertSQL UTF8String];</span><br><span class="line">        if(sqlite3_prepare_v2(database, insert_stmt, -1, &amp;statement, NULL) !&#x3D; SQLITE_OK) &#123;</span><br><span class="line">            NSLog(@&quot;Prepare failure:%s&quot;,sqlite3_errmsg(database));</span><br><span class="line">        &#125;</span><br><span class="line">        if(sqlite3_step(statement) &#x3D;&#x3D; SQLITE_DONE) &#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    sqlite3_reset(statement);</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSArray*)findByRegisterNumber:(NSString *)registerNumber&#123;</span><br><span class="line">    const char *dbpath &#x3D; [databasePath UTF8String];</span><br><span class="line">    if(sqlite3_open(dbpath, &amp;database) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">        NSString *querySQL &#x3D; [NSString stringWithFormat:@&quot;select name, department, year from studentsDetail where regno &#x3D; \&quot;%@\&quot;&quot;,registerNumber];</span><br><span class="line">        const char *query_stmt &#x3D; [querySQL UTF8String];</span><br><span class="line">        NSMutableArray *resultArray &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">        if(sqlite3_prepare_v2(database, query_stmt, -1, &amp;statement, NULL) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">            if(sqlite3_step(statement) &#x3D;&#x3D; SQLITE_ROW) &#123;</span><br><span class="line">                NSString *name &#x3D; [[NSString alloc] initWithUTF8String:(const char *)sqlite3_column_text(statement, 0)];</span><br><span class="line">                [resultArray addObject:name];</span><br><span class="line">                </span><br><span class="line">                NSString *department &#x3D; [[NSString alloc] initWithUTF8String:(const char*)sqlite3_column_text(statement, 1)];</span><br><span class="line">                [resultArray addObject:department];</span><br><span class="line">                </span><br><span class="line">                NSString *year &#x3D; [[NSString alloc] initWithUTF8String:(const char*)sqlite3_column_text(statement, 2)];</span><br><span class="line">                [resultArray addObject:year];</span><br><span class="line">                return resultArray;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                NSLog(@&quot;Not found&quot;);</span><br><span class="line">                return nil;</span><br><span class="line">            &#125;</span><br><span class="line">            sqlite3_reset(statement);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>Main.storyboard</code>中添加如下组件：</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof3hvfqacj30ga0gsgma.jpg" class="result" width="800" height="300" title="效果" alt="加载失败">
</li>
<li><p>为所有的输入框新建<code>Referencing Outlet</code></p>
</li>
<li><p>为两个button创建<code>Touch Up Inside</code>事件</p>
</li>
<li><p>创建完之后，<code>ViewController.h</code>自动被填写为:</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line">#import &quot;DBManager.h&quot;&#x2F;&#x2F;这个是手动添加的</span><br><span class="line"></span><br><span class="line">@interface ViewController : UIViewController</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *findByRegisterNumberTextField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *regNoTextField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *nameTextField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *departmentTextField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *yearTextField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UIScrollView *myScrollView;</span><br><span class="line"></span><br><span class="line">- (IBAction)findData:(id)sender;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UIButton *saveData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>ViewController.m</code>中实现<code>findData</code>和<code>saveData</code></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  ViewController.m</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)saveData:(id)sender &#123;</span><br><span class="line">    BOOL success &#x3D; NO;</span><br><span class="line">    NSString *alertString &#x3D; @&quot;Data Insertion failed&quot;;</span><br><span class="line">    if(_regNoTextField.text.length &gt; 0 &amp;&amp; _nameTextField.text.length &gt; 0 &amp;&amp; _departmentTextField.text.length &gt; 0 &amp;&amp; _yearTextField.text.length &gt; 0) &#123;</span><br><span class="line">        success &#x3D; [[DBManager getSharedInstance] saveData:_regNoTextField.text name:_nameTextField.text department:_departmentTextField.text year:_yearTextField.text];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        alertString &#x3D; @&quot;Enter all fields&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if(success &#x3D;&#x3D; NO) &#123;</span><br><span class="line">        UIAlertController *alert &#x3D; [UIAlertController alertControllerWithTitle:alertString message:nil preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">        UIAlertAction *okAction &#x3D; [UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">            NSLog(@&quot;点击了OK&quot;);</span><br><span class="line">        &#125;];</span><br><span class="line">        [alert addAction:okAction];</span><br><span class="line">        [self presentViewController:alert animated:YES completion:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)findData:(id)sender &#123;</span><br><span class="line">    NSArray *data &#x3D; [[DBManager getSharedInstance] findByRegisterNumber:_findByRegisterNumberTextField.text];</span><br><span class="line">    if(data &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        UIAlertController *alert &#x3D; [UIAlertController alertControllerWithTitle:@&quot;Data not found&quot; message:nil preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">        UIAlertAction *okAction &#x3D; [UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        &#125;];</span><br><span class="line">        [alert addAction:okAction];</span><br><span class="line">        [self presentViewController:alert animated:YES completion:nil];</span><br><span class="line">        _regNoTextField.text &#x3D; @&quot;&quot;;</span><br><span class="line">        _nameTextField.text &#x3D;@&quot;&quot;;</span><br><span class="line">        _departmentTextField.text &#x3D; @&quot;&quot;;</span><br><span class="line">        _yearTextField.text &#x3D;@&quot;&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        _regNoTextField.text &#x3D; _findByRegisterNumberTextField.text;</span><br><span class="line">        _nameTextField.text &#x3D;[data objectAtIndex:0];</span><br><span class="line">        _departmentTextField.text &#x3D;[data objectAtIndex:1];;</span><br><span class="line">        _yearTextField.text &#x3D;[data objectAtIndex:2];;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mart - Text field delegate</span><br><span class="line">-(void)textFieldDidBeginEditing:(UITextField *)textField &#123;</span><br><span class="line">    [_myScrollView setFrame:CGRectMake(10,50,300,200)];</span><br><span class="line">    [_myScrollView setContentSize:CGSizeMake(300, 350)];</span><br><span class="line">&#125;</span><br><span class="line">-(void)textFieldDidEndEditing:(UITextField *)textField &#123;</span><br><span class="line">    [_myScrollView setFrame:CGRectMake(10, 50, 300, 350)];</span><br><span class="line">&#125;</span><br><span class="line">-(BOOL) textFieldShouldReturn:(UITextField *)textField &#123;</span><br><span class="line">    [textField resignFirstResponder];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>至此，可以通过save按钮保存数据，find按钮可以查找数据，并显示在各自输入框中</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li><p><code>libsqlite3.dylib</code>vs<code>libsqlite3.tbd</code>vs<code>libsqlite3.0.tbd</code></p>
<p><code>.tbd</code> 在Xcode7后替代了<code>.dylib</code> 。而<code>libsqlite3.tbd</code>只是<code>libsqlite3.0.tbd</code>的链接，也就是两者是一摸一样的，引入任意一个的效果都是一样的。</p>
</li>
<li><p>sqlite3的使用</p>
<ol>
<li><p>创建数据库</p>
<p>SQLite的数据库就是一个文件，创建数据库也就是创建一个文件。</p>
</li>
<li><p>打开数据库</p>
<p>打开数据库其实就是用<code>sqlite3_open</code>函数打开一个文件。</p>
</li>
<li><p>执行SQL命令</p>
<p>SQLite中执行SQL命令有两种方式：</p>
<ul>
<li><code>sqlite3_exec()</code></li>
<li><code>sqlite3_prepare_v2()</code>+<code>sqlite3_step()</code></li>
</ul>
<p>两者的区别可以看<a href="https://stackoverflow.com/questions/27383724/sqlite3-prepare-v2-sqlite3-exec" target="_blank" rel="noopener">stackoverflow</a>。</p>
</li>
</ol>
</li>
<li><p>弹出框的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIAlertController *alert &#x3D; [UIAlertController alertControllerWithTitle:@&quot;警告的Title&quot; message:@&quot;警告的消息&quot;</span><br><span class="line">                           preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line"></span><br><span class="line">UIAlertAction *okAction &#x3D; [UIAlertAction actionWithTitle:@&quot;OK&quot;</span><br><span class="line">                           style:UIAlertActionStyleDefault</span><br><span class="line">                           handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">                             NSLog(@&quot;点击了OK&quot;);</span><br><span class="line">                           &#125;];</span><br><span class="line">UIAlertAction *cancelAction &#x3D; [UIAlertAction actionWithTitle:@&quot;Cancel&quot;</span><br><span class="line">                               style:UIAlertActionStyleCancel</span><br><span class="line">                               handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">                                 NSLog(@&quot;点击了Cancel&quot;);</span><br><span class="line">                               &#125;];</span><br><span class="line">[alert addAction:okAction];</span><br><span class="line">[alertController addAction:cancelAction];</span><br><span class="line"></span><br><span class="line">[self presentViewController:alert animated:YES completion:nil];</span><br></pre></td></tr></table></figure>


</li>
</ol>
]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发入门</tag>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C IOS开发之HelloWorld</title>
    <url>/chinese/2021/03/09/Objective-C-IOS%E5%BC%80%E5%8F%91%E4%B9%8BHelloWorld/</url>
    <content><![CDATA[<p>IDE: XCode Version 12.4 (12D4e)</p>
<a id="more"></a>
<ol>
<li>新建App</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofu3u9dcoj314y0ten0w.jpg" alt="image-20210311120542111"></p>
<ol start="2">
<li>给项目命名为<code>HelloWorld</code>，Interface选择<code>Storyboard</code>，Language选择<code>Objective-C</code>。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofu4wmsj2j314u0t6424.jpg" alt="image-20210311120644241"></p>
<ol start="3">
<li>打开文件<code>Main.storyboard</code>，添加一个<code>Label</code>和<code>Button</code>组件。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofubs0rgnj31iw0u0e02.jpg" alt=""></li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofudvnpftj312u0u0tcs.jpg" alt="image-20210311121521358"></p>
<ol start="4">
<li>打开两个面板，一个显示<code>Main.storyboard</code>，另一个显示<code>ViewController.h</code><br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofugj8ui9j31iq0fsdk5.jpg" alt=""></li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofuiw4hgvj31hx0u07i1.jpg" alt=""></p>
<ol start="5">
<li><p>为Label新建<code>New Referencing Outlet</code>（右键点击Label，点击<code>New Referencing Outlet</code>后的点不松开，拖到<code>ViewController.h</code>中。将新的<code>Referencing Outlet</code>命名为<code>helloLabel</code>。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofukdlay3j31gt0u0h9a.jpg" alt=""></p>
</li>
<li><p>为Button添加<code>Touch Up Inside</code>事件，将事件命名为<code>showHelloWorld</code>。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gog2epczyxj30wg0u0h1n.jpg" alt=""><br>这时，<code>ViewController.h</code>的代码变为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  ViewController.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController : UIViewController</span><br><span class="line"></span><br><span class="line">@property (weak, nonatomic) IBOutlet UILabel *helloLabel;</span><br><span class="line">- (IBAction)showHelloWorld:(id)sender;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>同时，<code>ViewController.m</code>中也自动添加了<code>- (IBAction)showHelloWorld(id)sender {}</code>函数，在其中添加<code>_helloLabel.text = @&quot;Hello World&quot;;</code></p>
</li>
</ol>
<p>至此，最简单的IOS App开发完成。</p>
]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发入门</tag>
      </tags>
  </entry>
  <entry>
    <title>github pages + hexo + next + Travis CI实现免费个人博客</title>
    <url>/chinese/2021/03/08/github-pages-hexo-next-Travis-CI%E5%AE%9E%E7%8E%B0%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>是GitHub提供的静态网页托管工具，可以用来建立个人网页，也可以建立网页介绍某个项目。</p>
<p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>是一个博客框架，而<a href="https://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT</a>是Hexo的一个主题。</p>
<p>最后Travis CI是针对GitHub的一款持续集成工具，这里用来完成网站的自动化部署。</p>
<a id="more"></a>
<h1 id="GitHub-Pages设置"><a href="#GitHub-Pages设置" class="headerlink" title="GitHub Pages设置"></a>GitHub Pages设置</h1><p>GitHub Pages主页中有建站的简单教程，为了支持MarkDown撰写博客，选择使用博客框架Hexo，并选择一个比较流行的框架NexT。</p>
<p>在此基础上可以添加许多功能：</p>
<ol>
<li><p>置顶</p>
<ol>
<li>移除默认安装的插件<code>npm uninstall hexo-generator-index --save</code></li>
<li>安装新插件<code>npm install hexo-generator-index-pin-top --save</code></li>
<li>在需要置顶的文章头部<code>top: true</code>或<code>top:整数</code>，其中整数越大的文章越靠前</li>
<li>为置顶的文章添加置顶标签,在<code>/themes/next/layout/_macro/post.swig</code>文件的<code>&lt;div class=&quot;post-meta&quot;&gt;</code>下方，插入如下代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">&lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">&lt;font color&#x3D;7D26CD&gt;置顶&lt;&#x2F;font&gt;</span><br><span class="line">&lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>数学公式</p>
<ol>
<li>编辑<code>theme/next/_config.yml</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">enable:  true</span><br><span class="line">per_page: false</span><br><span class="line">cdn: &#x2F;&#x2F;cdn.bootcss.com&#x2F;mathjax&#x2F;2.7.1&#x2F;latest.js?config&#x3D;TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure></li>
<li>为了更好的性能，不选择在所有页面下支持数学公式。在需要支持matchjax的文章头部，添加<code>mathjax: true</code></li>
</ol>
</li>
<li><p>评论功能</p>
<ol>
<li>评论功能和阅读统计都可以使用LeanCloud</li>
<li>编辑<code>theme/next/_config.yml</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">    enable: true</span><br><span class="line">    appid:  xxxxxxxx</span><br><span class="line">    appkey:  yyyyyyyyyyy</span><br><span class="line">    notify: false # mail notifier , https:&#x2F;&#x2F;github.com&#x2F;xCss&#x2F;Valine&#x2F;wiki</span><br><span class="line">    verify: false # Verification code</span><br><span class="line">    placeholder: 评论 # comment box placeholder</span><br><span class="line">    avatar: mm # gravatar style</span><br><span class="line">    guest_info: nick,mail,link # custom comment header</span><br><span class="line">    pageSize: 10 # pagination size</span><br></pre></td></tr></table></figure>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocmlo8c9sj317k0o8myh.jpg" class="commentsImg" width="400" height="600" title="评论功能" alt="加载失败"></li>
</ol>
</li>
<li><p>阅读统计<br> <a href="https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">为NexT主题添加文章阅读量统计功能</a></p>
</li>
<li><p>字数统计</p>
<ol>
<li>编辑<code>theme/next/_config.yml</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_wordcount:</span><br><span class="line">item_text: true</span><br><span class="line">wordcount: true</span><br><span class="line">min2read: true</span><br><span class="line">totalcount: true</span><br><span class="line">separated_meta: true</span><br></pre></td></tr></table></figure></li>
<li>执行<code>npm install hexo-wordcount@2 --save</code>，安装需要的库<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocmhvhwsnj30cw01iwei.jpg" class="wordCountImg" width="200" height="30" title="字数统计" alt="加载失败"></li>
</ol>
</li>
<li><p>添加网易云播放器</p>
<ol>
<li>去网易云音乐找一首喜欢的歌。</li>
<li>点击“生成外链播放器”，复制HTML代码。</li>
<li>将HTML代码添加到<code>/themes/hexo-theme-next/layout/_macro/sidebar.swig</code>中<code>&lt;aside id=&quot;sidebar&quot; class=&quot;sidebar”&gt;</code>后面，并用<code>&lt;div&gt;</code>包裹。<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocm3k2n6uj30ia0lujua.jpg" class="musicImg" width="400" height="200" title="网易云音乐" alt="加载失败"></li>
</ol>
</li>
<li><p>将标签云改为彩色</p>
<ol>
<li>在<code>themes/next/layout/</code>中新建<code>tag-color.swig</code>文件，代码为： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">     var alltags &#x3D; document.getElementsByClassName(&#39;tag-cloud-tags&#39;);</span><br><span class="line">     var tags &#x3D; alltags[0].getElementsByTagName(&#39;a&#39;);</span><br><span class="line">     for (var i &#x3D; tags.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">       var r&#x3D;Math.floor(Math.random()*75+130);</span><br><span class="line">       var g&#x3D;Math.floor(Math.random()*75+100);</span><br><span class="line">       var b&#x3D;Math.floor(Math.random()*75+80);</span><br><span class="line">       tags[i].style.background &#x3D; &quot;rgb(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .tag-cloud-tags&#123;</span><br><span class="line">    &#x2F;*font-family: Helvetica, Tahoma, Arial;*&#x2F;</span><br><span class="line">    &#x2F;*font-weight: 100;*&#x2F;</span><br><span class="line">    text-align: center;</span><br><span class="line">    counter-reset: tags;</span><br><span class="line">  &#125;</span><br><span class="line">  .tag-cloud-tags a&#123;</span><br><span class="line">    border-radius: 6px;</span><br><span class="line">    padding-right: 5px;</span><br><span class="line">    padding-left: 5px;</span><br><span class="line">    margin: 8px 5px 0px 0px;</span><br><span class="line">  &#125;</span><br><span class="line">  .tag-cloud-tags a:before&#123;</span><br><span class="line">    content: &quot;?&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .tag-cloud-tags a:hover&#123;</span><br><span class="line">     box-shadow: 0px 5px 15px 0px rgba(0,0,0,.4);</span><br><span class="line">     transform: scale(1.1);</span><br><span class="line">     &#x2F;*box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);*&#x2F;</span><br><span class="line">     transition-duration: 0.15s;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></li>
<li>在<code>/themes/next/layout/page.swig</code>中引入<code>tag-color.swig</code>，即在<code>&lt;div class=&quot;tag-cloud&quot;&gt;</code>代码段下方添加<code>{ % include &#39;tag-color.swig&#39; % }</code></li>
<li>也可以将标签云直接加入主页，在<code>/themes/next/layout/index.swig</code>中的block content代码块中加入以下代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;tag-cloud&quot;&gt;</span><br><span class="line">	  &lt;div class&#x3D;&quot;tag-cloud-tags&quot; id&#x3D;&quot;tags&quot;&gt;</span><br><span class="line">		&#123;&#123; tagcloud(&#123;min_font: 16, max_font: 16, amount: 300, color: true, start_color: &#39;#fff&#39;, end_color: &#39;#fff&#39;&#125;) &#125;&#125;</span><br><span class="line">	  &lt;&#x2F;div&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;br&gt;</span><br><span class="line">	</span><br><span class="line">	&#123;% include &#39;tag-color.swig&#39; %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>展示近期文章</p>
<ol>
<li><p>修改<code>themes/next/layout/_macro/sidebar.swig</code> 。找到<code>theme.social</code>，在该板块后隔一行添加如下代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;# recent posts #&#125;</span><br><span class="line">&#123;% if theme.recent_posts %&#125;</span><br><span class="line">&lt;div class&#x3D;&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme.recent_posts_layout  &#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;links-of-blogroll-title&quot;&gt;</span><br><span class="line">        &lt;!-- modify icon to fire by szw --&gt;</span><br><span class="line">        &lt;i class&#x3D;&quot;fa fa-history fa-&#123;&#123; theme.recent_posts_icon | lower &#125;&#125;&quot; aria-hidden&#x3D;&quot;true&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">        &#123;&#123; theme.recent_posts_title &#125;&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;ul class&#x3D;&quot;links-of-blogroll-list&quot;&gt;</span><br><span class="line">        &#123;% set posts &#x3D; site.posts.sort(&#39;-date&#39;) %&#125;</span><br><span class="line">        &#123;% for post in posts.slice(&#39;0&#39;, &#39;5&#39;) %&#125;</span><br><span class="line">        &lt;li class&#x3D;&quot;recent_posts_li&quot;&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title&#x3D;&quot;&#123;&#123; post.title &#125;&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">         &lt;&#x2F;li&gt;</span><br><span class="line">         &#123;% endfor %&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编辑<code>themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">li.recent_posts_li &#123;</span><br><span class="line">    text-align: cengter;</span><br><span class="line">    display: block;</span><br><span class="line">    word-break: keep-all;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>themes/next/_config.yml</code>中添加下方代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 近期文章设置</span><br><span class="line">recent_posts_title: 近期文章</span><br><span class="line">recent_posts_layout: block</span><br><span class="line">recent_posts: true</span><br></pre></td></tr></table></figure>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocmksvxlvj30da0460su.jpg" class="rencentPostImg" width="200" height="100" title="近期文章" alt="加载失败">

</li>
</ol>
</li>
</ol>
<h1 id="Travis-CI自动部署GitHub-Pages"><a href="#Travis-CI自动部署GitHub-Pages" class="headerlink" title="Travis CI自动部署GitHub Pages"></a>Travis CI自动部署GitHub Pages</h1><p><a href="https://docs.travis-ci.com/user/deployment/pages/" target="_blank" rel="noopener">Travis官方教程</a><br>有了Travis CI，更换电脑时，不需要在本地配置完整的环境，可以直接修改md文件，push到github后，Travis CI会自动生成和部署，非常的方便。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo: false</span><br><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - 10 # use nodejs v10 LTS</span><br><span class="line">before_script: # 配置环境</span><br><span class="line">    - npm install hexo-generator-searchdb --save # 用于支持本地搜索功能</span><br><span class="line">    - npm uninstall hexo-generator-index --save </span><br><span class="line">    - npm install hexo-generator-index-pin-top --save # 这两行用于支持置顶功能</span><br><span class="line">    - npm install --save hexo-filter-flowchart # 用于支持markdown中的流程图功能</span><br><span class="line">    - npm install hexo-wordcount@2 --save #用于支持字数统计功能</span><br><span class="line">cache: npm</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - master # build master branch only</span><br><span class="line">script:</span><br><span class="line">  - hexo generate # generate static files</span><br><span class="line">deploy:</span><br><span class="line">  provider: pages</span><br><span class="line">  skip-cleanup: true</span><br><span class="line">  github-token: $GH_TOKEN</span><br><span class="line">  keep-history: true</span><br><span class="line">  on:</span><br><span class="line">    branch: master</span><br><span class="line">  local-dir: public</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">notifications:</span><br><span class="line">   email:</span><br><span class="line">     recipients:</span><br><span class="line">       - xxx@xxx.com</span><br><span class="line">         #-</span><br><span class="line">     on_success: never # default: change</span><br><span class="line">     #on_success: change # default: change</span><br><span class="line">     on_failure: always # default: always</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>自媒体</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>GitHub Pages</tag>
        <tag>Travis</tag>
      </tags>
  </entry>
</search>
