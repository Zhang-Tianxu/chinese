<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言：多重指针和多重数组</title>
    <url>/chinese/2022/04/25/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E5%A4%9A%E9%87%8D%E6%8C%87%E9%92%88%E5%92%8C%E5%A4%9A%E9%87%8D%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="一维数组和指针"><a href="#一维数组和指针" class="headerlink" title="一维数组和指针"></a>一维数组和指针</h2><p>我们直接看下面代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *b = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> *c = a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d "</span>, b[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d "</span>, c[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure>

<p>由于“维数组的名字等价于数组首元素的地址”，所以上面代码中a、b、c都是指向数组a[10]的首元素（a[0]）的地址，三者在用法上完全相同：</p>
<p><code>a[i] == b[i] == c[i] == *(a + i) == *(b + i) == *(c + i)；</code></p>
<p>可以看出<code>b + i == &amp;b[i]</code>。</p>
<h2 id="多维数组和多重指针"><a href="#多维数组和多重指针" class="headerlink" title="多维数组和多重指针"></a>多维数组和多重指针</h2><p>一维数组的这个特点让我误以为，下面代码中a和b在用法上也是等价的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> **b = a;</span><br></pre></td></tr></table></figure>

<p>但其实不是的，他们的类型都不相同，a是int指针，而b是int指针的指针。<br>如果想让b和a的类型相同，应该是：<code>int *b = a;</code>，那么这种情况下可以认为a、b等价了吗？还是不行：<code>a[i][j] != b[i][j]</code></p>
<p>两个值不想等的原因：</p>
<p>对a来说： 二维数组本质上也是一维数组，只不过这个“一维数组”的每个元素，是一个一维数组。a[i]表示二维数组的第i个元素（一维数组），<code>a[i][j]</code>表示a[i]这个一维数组的第j个元素。</p>
<p>对b来说：b本质是int指针。 <code>&amp;b[i] = b + i</code>，其中<code>b + i</code>表示指向b后第i个元素的地址，元素就是指针指向的类型，对b来说是int。<code>b[i]</code>表示b后第i个int的值，等价于<code>a[0][i]</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">b[i] = a[<span class="number">0</span>][i];</span><br><span class="line">a[i][j] = b[i * <span class="number">2</span> + j];</span><br><span class="line">a[i][j] = *(b + i * <span class="number">2</span> + j);</span><br><span class="line"><span class="keyword">int</span> (*b)[<span class="number">3</span>] = a; <span class="comment">// pointer to array[13] of int</span></span><br></pre></td></tr></table></figure>

<h2 id="多维数组作为函数参数"><a href="#多维数组作为函数参数" class="headerlink" title="多维数组作为函数参数"></a>多维数组作为函数参数</h2><p>多维数组作为函数参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">f(<span class="keyword">int</span> daytab[<span class="number">2</span>][<span class="number">13</span>]) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">f(<span class="keyword">int</span> daytab[][<span class="number">13</span>]) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">f(<span class="keyword">int</span> (*daytab)[<span class="number">13</span>]) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>上面3中声明方式，在函数内都可以使用<code>a[i][j]</code>的方式访问数组元素。</p>
<blockquote>
<p>注意：<br><code>f(int *daytab[13]) { ... }</code>这种声明方式，无法使用<code>a[i][j]</code>的方式访问数组元素</p>
</blockquote>
<p> 那么f(int <em>a) { … }可以吗？严格说是可以的，只不过不能使用a[i][j]的方式访问元素，而应该使用</em>(a + 13 * i + j)的方式访问元素。</p>
<p> 多重指针作为函数参数：</p>
<p> 用数组做函数参数的方式，数组列数是固定的，如果想要实现动态分配内存，需要使用多重数组作为函数参数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">f(<span class="keyword">int</span> **a) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>** <span class="built_in">array</span>, <span class="keyword">int</span> row_len, <span class="keyword">int</span> col_len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; row_len;i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; col_len;j++) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d "</span>, <span class="built_in">array</span>[i][j]);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> **<span class="title">make2DArray</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> **arr = (<span class="keyword">int</span> **)<span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="keyword">int</span> *));</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++) &#123;</span><br><span class="line"></span><br><span class="line">  arr[r] = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++) &#123;</span><br><span class="line"></span><br><span class="line">   arr[i][j] = i * <span class="number">2</span> + j;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> **arr1 = make2DArray(<span class="number">5</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> arr2[<span class="number">5</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">10</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> foo(arr1, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"> foo(arr2, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh免密登录</title>
    <url>/chinese/2022/02/10/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h1 id="ssh-免密码登陆"><a href="#ssh-免密码登陆" class="headerlink" title="ssh 免密码登陆"></a>ssh 免密码登陆</h1><p>在配置分布式系统时经常要实现系统内机器之间的ssh免密登陆，在按照网上某些教程实现时发现并非完全正确（尤其是你不是管理员时），现在把我能成功实现的方法列出：</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><ol>
<li><p>在用户机上生成密钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
</li>
<li><p>将生成的密钥的公钥复制到目标机的<code>.ssh/authorized_keys</code>内</p>
<pre><code class="shell">cat .ssh</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福大学IOS7开发课程5</title>
    <url>/chinese/2021/04/25/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B5/</url>
    <content><![CDATA[<p>这节课主要讲解：</p>
<ol>
<li>View Controller的<strong>生命周期</strong></li>
<li><strong>NotificationCenter</strong>的相关知识</li>
<li>组件UITextView的简单使用</li>
</ol>
<p>并通过Demo展示</p>
<a id="more"></a>

<h2 id="ViewController的声明周期"><a href="#ViewController的声明周期" class="headerlink" title="ViewController的声明周期"></a>ViewController的声明周期</h2><p>ViewController 的生命周期可以看作一系列函数，ViewController是UIViewController的子类。</p>
<p>生命周期的开始是创建，创建后会涉及到：</p>
<ol>
<li>viewDidLoad()</li>
<li>viewWillLayoutSubviews()</li>
<li>viewDidLayoutSubviews()</li>
<li>viewWillAppear()</li>
<li>viewDidAppear()</li>
<li>viewWillDisappear()</li>
<li>viewDidDisappear()</li>
<li>didReceiveMemoryWaring()</li>
</ol>
<p>接下来<strong>详细介绍</strong>这几个生命周期：</p>
<h2 id="viewDidLoad"><a href="#viewDidLoad" class="headerlink" title="viewDidLoad()"></a>viewDidLoad()</h2><p>在viewDidLoad()之前会执行创建的动作，但是我们一般不会在创建中执行操作。</p>
<p>创建完成之后，outlets被设置好。</p>
<p>viewDidLoad()只会被<strong>调用一次</strong>，<strong>是用来初始化controller非常好的位置</strong>。</p>
<p>需要注意的是此时view的几何结构（geometry）还没完成，<strong>还无法确定App是运行在6寸的iPhone上还是10寸的iPad上</strong>。所以不要在viewDidLoad()中初始化和尺寸、几何结构相关的操作。</p>
<h2 id="viewWillLayoutSubviews"><a href="#viewWillLayoutSubviews" class="headerlink" title="viewWillLayoutSubviews()"></a>viewWillLayoutSubviews()</h2><p>当view的几何结构发生改变时（比如屏幕从竖着变成横着），（ios7及以上）在展示之前会调用viewWillLayoutSubviews()</p>
<h2 id="viewDidLayoutSubviews"><a href="#viewDidLayoutSubviews" class="headerlink" title="viewDidLayoutSubviews()"></a>viewDidLayoutSubviews()</h2><h2 id="viewWillAppear"><a href="#viewWillAppear" class="headerlink" title="viewWillAppear()"></a>viewWillAppear()</h2><p>view展现在屏幕之前，会调用viewWillAppear()函数。</p>
<p>当使用多MVC模型时，会有多个view，此时某个view的viewWillAppear()可能会被调用多次，所以只执行一次的初始化代码不要放在这里，而应该放在viewDidLoad()。</p>
<p>基于这个理解，有些操作需要放入viewWillAppear()执行，比如Model中的数据在view不可见时被更改了，当view再次展现的时候，需要同步Model和UI。</p>
<p>另外，和viewDidLoad()相对的，这里已经完成了view几何结构的初始化，因此可以执行和几何结构相关的一些操作了。</p>
<p>在生命周期<code>viewWillAppear</code>中，必须调用<code>[super viewWillAppear:animated]</code>，调用位置无关紧要，你可以在开始调用也可以在结束时调用。</p>
<p><code>viewWillDisappear</code>也是一样。</p>
<h2 id="viewDidAppear"><a href="#viewDidAppear" class="headerlink" title="viewDidAppear()"></a>viewDidAppear()</h2><p>view展现在屏幕上之后，调用viewDidAppear()</p>
<h2 id="viewWillDisappear"><a href="#viewWillDisappear" class="headerlink" title="viewWillDisappear()"></a>viewWillDisappear()</h2><p>view即将消失时调用viewWillDisappear()，此时最好停止使用非必要的资源，比如动画等等。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">  [<span class="keyword">super</span> viewWillDisappear:animated]; <span class="comment">// 在所有viewWill/Did中都要调用super函数</span></span><br><span class="line">  <span class="comment">// 记住滑动的位置</span></span><br><span class="line">  [<span class="keyword">self</span> rememberScrollPosition];</span><br><span class="line">  <span class="comment">// 做一些清理工作</span></span><br><span class="line">  [<span class="keyword">self</span> saveDataToPermanentStore];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="viewDidDisappear"><a href="#viewDidDisappear" class="headerlink" title="viewDidDisappear()"></a>viewDidDisappear()</h2><p>view消失以后，调用viewDidDisappear()</p>
<h2 id="didReceiveMemoryWaring"><a href="#didReceiveMemoryWaring" class="headerlink" title="didReceiveMemoryWaring()"></a>didReceiveMemoryWaring()</h2><p>内存不够了，可能是因为你的App，<strong>也可能是手机上的其他App造成的</strong>。</p>
<p>这是你应该试图清理内存。</p>
<p>为什么是我要清理内存？因为操作系统有权限kill应用，如果内存不够了，而你的App又占用了很多内存，很有可能被iOS杀死。 </p>
<h2 id="awakeFromNib"><a href="#awakeFromNib" class="headerlink" title="awakeFromNib()"></a>awakeFromNib()</h2><p>（说实话，没完全听懂，先记下来，以后用到再详细研究一下吧。）</p>
<p>这个方法会发送给storyboard中绘制出来的所有对象，包括controller</p>
<p>如果进入到Controller的init方法，就一定也会进入到<code>awakeFromNib</code>。</p>
<p>尽可能不要将代码放在<code>awakeFromNib</code>中。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setup &#123;...&#125;;  <span class="comment">// do something which can't wait until viewDidLoad</span></span><br><span class="line">- (<span class="keyword">void</span>)awakeFromNib &#123; [<span class="keyword">self</span> setup]; &#125;</span><br><span class="line"><span class="comment">// uIViewController's designated initializer is initWithNibName:bundle:(ugh!)</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithNibName:(<span class="built_in">NSString</span> *)name bundle:(<span class="built_in">NSBundle</span> *)bundle</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 如果使用awakeFromNib，为了保证正确性，也要加上这三行代码</span></span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> initWithNibName:name bundle:bundle];</span><br><span class="line">  [<span class="keyword">self</span> setup];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<div id="flowchart-0" class="flow-chart"></div>

<img src="https://developer.apple.com/library/archive/referencelibrary/GettingStarted/DevelopiOSAppsSwift/Art/WWVC_vclife_2x.png" style="zoom:30%;" />






<h2 id="组件UITextView简介"><a href="#组件UITextView简介" class="headerlink" title="组件UITextView简介"></a>组件UITextView简介</h2><p>组件<a href="https://developer.apple.com/documentation/uikit/uitextview" target="_blank" rel="noopener">UITextView</a>类似于UILable，但是可以展示多行，具有可选可编辑可滚动等特点。</p>
<h2 id="NotificationCenter相关知识"><a href="#NotificationCenter相关知识" class="headerlink" title="NotificationCenter相关知识"></a>NotificationCenter相关知识</h2><p>接下来讲一讲NSNotification</p>
<ul>
<li><p>Notifications也就是之前在MVC中称为radio station的概念。</p>
</li>
<li><p>NSNotificationcenter</p>
<p>通过<code>[NSNotificationCenter defaultCenter]</code>获取默认Notification Center。</p>
<p>如果想监听这个radio station，那么发送如下消息：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="keyword">id</span>)observer  <span class="comment">// 需要接收通知的对象</span></span><br><span class="line">           selector:(SEL)methodToInvokeIfSomethingHappens</span><br><span class="line">               name:(<span class="built_in">NSString</span> *)name  <span class="comment">// station的名称</span></span><br><span class="line">             object:(<span class="keyword">id</span>)sender;  <span class="comment">// 你感兴趣的变更，如果填写nil，标识任何人发生变更，都会通知你。指定某个sender，可以只接收指定对象发来的通知。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当有广播的时候，observer会被通知：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)methodToInvokeIfSomethingHappens:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">  notification.name;  <span class="comment">// 传递的station的名称</span></span><br><span class="line">  notification.object;  <span class="comment">// 给你发送通知的对象</span></span><br><span class="line">  notification.userInfo;  <span class="comment">// 有关发生了什么的特定信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结束后记得关闭radio station</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[center removeObserver:<span class="keyword">self</span>]; <span class="comment">//关闭所有radio station</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">[center removeObserver:<span class="keyword">self</span> name:<span class="built_in">UIContentSizeCategoryDidChangeNotification</span> object:<span class="literal">nil</span>];  <span class="comment">//关闭指定radio station</span></span><br></pre></td></tr></table></figure>

<p>如果离开堆栈时，没有关闭radio station，notification center可能会继续发送notification，并<strong>导致App崩溃</strong>！</p>
<p>因为NSNotificationCenter有一个指向你的unsafe retained指针。</p>
<p>关闭radio station最好的位置是在MVC离开屏幕的时候，实在不行，可以在dealloc中关闭，dealloc会在离开堆栈之前调用：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">  <span class="comment">// be careful in this method! can't access properties! you are almost gone from heap!</span></span><br><span class="line">  [[<span class="built_in">NSNotificationCenter</span> defaultcenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>关于NotificationCenter，一个常用的例子是字体的变化。当用户在系统设置中改变字体大小时，可以利用NotificationCenter使App中的字体也跟着变化。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSNotificationCenter</span> *center = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</span><br><span class="line">[center addObserver:<span class="keyword">self</span></span><br><span class="line">           selector:<span class="keyword">@selector</span>(preferredFontsSizeChanged:)</span><br><span class="line">               name:<span class="built_in">UIContentsizeCategoryDidChangeNotification</span></span><br><span class="line">             object:<span class="literal">nil</span>]; <span class="comment">// this station's broadcasts aren't object-specific</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)preferredFontsSizeChanged:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">  <span class="comment">// reset fonts of objects using preferred fonts</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>目的：了解attributed text（富文本）、生命周期以及Notification。</p>
<ol>
<li><p>新建App，在storageBoard中加入：</p>
<ul>
<li>TextView</li>
<li>label</li>
<li>6 buttons</li>
</ul>
<p>如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gptqmdv9uwj30i40zs41r.jpg" alt="image-20210423160322521"></p>
</li>
<li><p>为TextView和Label添加property:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextView</span> *body;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UILabel</span> *headline;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为buttons添加三个函数</p>
<ul>
<li><p>四个色块的button共用一个函数，函数的作用是：在textView中选中一些文字，点击色块button后，选中的文字变成色块对应的颜色</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)changeBodySelectionColorToMatchBackgroundOfButton:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span>.body.textStorage addAttribute:<span class="built_in">NSForegroundColorAttributeName</span> value:sender.backgroundColor range:<span class="keyword">self</span>.body.selectedRange];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>outline按钮对应的函数，作用是给选中文字添加红色描边。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)outlineBodySelection:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span>.body.textStorage addAttributes:@&#123; <span class="built_in">NSStrokeWidthAttributeName</span> : @<span class="number">-3</span>, <span class="built_in">NSStrokeColorAttributeName</span>: [<span class="built_in">UIColor</span> redColor] &#125; range:<span class="keyword">self</span>.body.selectedRange];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加描边需要添加两个属性，一个用来设置描边的宽度，一个用来设置描边的颜色。</p>
<p><code>NSStrokeWidthAttributeName</code>用来设置描边的宽度，设置为整数会让字体变成中空，设置为负数会保持字体填充。</p>
<p><code>NSStrokeColorAttributeName</code>用来设置描边的颜色。</p>
</li>
<li><p>unOutline按钮对应的按钮，作用是删除字体的描边。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)unOutlineBodySelection:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span>.body.textStorage removeAttribute:<span class="built_in">NSStrokeWidthAttributeName</span> range:<span class="keyword">self</span>.body.selectedRange];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接利用<code>removeAttribute</code>删除<code>NSStrokeWidthAttributeName</code>属性，颜色就不用管了，没有宽度颜色也就无法显示了。</p>
</li>
</ul>
</li>
<li><p>设置outline按钮的字体描边</p>
<p>这样产不多就是这节课要介绍的关于富文本的知识点了。接下来加入一些生命周期的元素。</p>
<p>现在想要让outline按钮的文字变成描边的，我们可不想在设置一个按钮来让outline按钮outline，而是想一开始它就是描边的。</p>
<p>这个时候就用到生命周期了，可以在<code>viewDidLoad()</code>函数中实现：</p>
<p>先为button添加outlet，<code>@property (weak, nonatomic) IBOutlet UIButton *outline;</code>，然后在<code>viewDidLoad()</code>函数中编写代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    <span class="built_in">NSMutableAttributedString</span> *title = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:<span class="keyword">self</span>.outline.currentTitle];</span><br><span class="line">    [title setAttributes:@ &#123;</span><br><span class="line">        <span class="built_in">NSStrokeWidthAttributeName</span> : @<span class="number">3</span>,</span><br><span class="line">        <span class="built_in">NSStrokeColorAttributeName</span> : <span class="keyword">self</span>.outline.tintColor&#125;</span><br><span class="line">                   range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, [title length])];</span><br><span class="line">    [<span class="keyword">self</span>.outline setAttributedTitle:title forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用NSNotificationCenter让App中字体跟随系统字体，用户改变系统字体时，App中字体也随之变动。</p>
<ol>
<li><p>首先实现一个将字体设置为系统对应字体的方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)usePreferredFonts &#123;</span><br><span class="line">    <span class="keyword">self</span>.body.font = [<span class="built_in">UIFont</span> preferredFontForTextStyle:<span class="built_in">UIFontTextStyleBody</span>];</span><br><span class="line">    <span class="keyword">self</span>.headline.font = [<span class="built_in">UIFont</span> preferredFontForTextStyle:<span class="built_in">UIFontTextStyleHeadline</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并将其包装一层：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)preferredFontsChanged:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    [<span class="keyword">self</span> usePreferredFonts];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在生命周期<code>viewWillAppear()</code>中添加NotificationCenter</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">               selector:<span class="keyword">@selector</span>(preferredFontsChanged:)</span><br><span class="line">                   name:<span class="built_in">UIContentSizeCategoryDidChangeNotification</span></span><br><span class="line">                 object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后记得关闭radio station</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillDisappear:animated];</span><br><span class="line">    <span class="comment">// [[NSNotificationCenter defaultCenter] removeObserver:self]; // 这种方法也可以，删除所有的notification，但不够优雅，尽量使用下面的方法，指定具体的notificationCenter</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span></span><br><span class="line">                                                    name:<span class="built_in">UIContentSizeCategoryDidChangeNotification</span></span><br><span class="line">                                                  object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后要考虑一种情况，NotificationCenter在view消失时被关闭，如果在这之后用户修改了系统的字体，那么view再次appear时，App字体会和系统不一致。因此，需要在<code>viewWillAppear</code>中，调用<code>[self usePreferredFonts]</code>来同步外部世界的字体。</p>
</li>
</ol>
</li>
</ol>
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: instantiated(实例化)
op=>operation: 调用awakeFromNib()
op2=>operation: outlets设置完成
op3=>operation: 调用viewDidLoad()
op4=>operation: 几何结构确定下来以后,\
调用viewWillLayoutSubviews()和viewDidLayoutSubviews()
op5=>operation: (对着MVC再屏幕中出现和消失，下面几个生命周期可能会被多次调用)
op6=>operation: 调用viewWillAppear()和viewDidAppear()
op7=>operation: 每当几何结构改变（比如屏幕旋转）都会调用\
viewWillLayoutSubviews()和viewDidLayoutSubviews()
op8=>operation: 如果设置了屏幕自动旋转，还会调用will/didRotatedTo/From
op9=>operation: 调用viewWillDisappear()和viewDidDisappear()
op10=>operation: 如果手机内存吃紧，调用didReceiveMemoryWarning()
e=>end
st->op->op2->op3->op4->op5->op6->op7->op8->op9->op10->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福大学IOS7开发课程4</title>
    <url>/chinese/2021/03/29/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B4/</url>
    <content><![CDATA[<p>这节课主要讲了<strong>Objecitive-C的几个细节</strong>和<strong>Foundation</strong>库中的一些类</p>
<p>本节课主要介绍iOS开发</p>
<ul>
<li>NSObject</li>
<li>NSArray</li>
<li>NSMutableArray</li>
<li>NSNumber</li>
<li>NSValue</li>
<li>NSData</li>
<li>NSDate</li>
<li>NSSet</li>
<li>NSMutableSet</li>
<li>NSOrderedSet</li>
<li>NSMutableOrderedSet</li>
<li>NSDictionary</li>
<li>NSMutableDictionary</li>
<li>NSUserDefaults</li>
<li>NSRange</li>
<li>UIColor</li>
<li>UIFont</li>
<li>UIFontDescriptor</li>
<li>NSAttributedString</li>
<li>NSMutableAttributedString</li>
</ul>
<a id="more"></a>

<h1 id="Objecitive-C的几个细节"><a href="#Objecitive-C的几个细节" class="headerlink" title="Objecitive-C的几个细节"></a>Objecitive-C的几个细节</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><ol>
<li>利用Alloc &amp; init创建对象</li>
<li>利用类的方法创建对象</li>
<li>或者上述两者同时使用</li>
<li>让其他对象帮忙创建类的对象<figure class="highlight"><table><tr><td class="code"><pre><span class="line">- NSString's -- (NSString *)stringByAppendingString:(NSString *)otherString</span><br><span class="line">- NSArray's -- (NSString *)componentsJoinedByString:(NSString *)separator;</span><br><span class="line">- NSString's &amp; NSArray's -- (id)mutableCopy</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h2><p>向nil发送消息是可以的，但是不会执行任何代码</p>
<h2 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h2><p>Objective-C有个<strong>非常重要</strong>的类型——<strong>id</strong>，id是一种类型，意味“指向未知类型对象的<strong>指针</strong>”。</p>
<p><strong>在运行过程中，所有对象的指针都是id类型的。</strong></p>
<p>用id来指定变量类型，<strong>就是动态绑定</strong>。</p>
<p>但是在编译过程中，如果你指定对象的类型，编译器可以帮助发现bug。</p>
<p><strong>那么动态绑定安全么？</strong></p>
<p>动态绑定导致可以向对象发送未定义的信息，比如该对象类型为定义的方法，当然这会导致程序崩溃。</p>
<p>如果在代码中指定对象的类型，这种错误就可以在编译过程中被发现，防止程序在执行过程中崩溃，比如，<code>NSString *s  = @&#39;x&#39;</code>，这种情况下，如果给s发送非NSString的方法，编译器可以发现错误。</p>
<p>当然也可以使用：<code>id obj = s</code>、<code>NSArray *a = obj</code>，但是这样<strong>编译器没办法帮忙检查错误</strong>，所以存在一定危险。</p>
<p>另外，永远不要使用<code>id *</code>，因为<strong>id本身就是个指针</strong>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Vehicle</span></span></span><br><span class="line">- (<span class="keyword">void</span>)move;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Ship</span> : <span class="title">Vehicle</span></span></span><br><span class="line">- (<span class="keyword">void</span>)shoot;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Ship *s = [[Ship alloc] init];</span><br><span class="line">[s shoot];</span><br><span class="line">[s move];</span><br><span class="line"></span><br><span class="line">Vehicle *v = s; <span class="comment">// 合法</span></span><br><span class="line">[v shoot]; <span class="comment">// 编译器会给出警告，因为它以为v是Vehicle</span></span><br><span class="line">          <span class="comment">//但是运行时不会崩溃，因为v实际上是一个Ship</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> obj = ...; <span class="comment">// 任意定义obj，比如NSString；</span></span><br><span class="line">[obj shoot;] <span class="comment">// 编译器不会给出警告，因为它知道shoot函数确实存在，同时它又不知道obj的类型，因此编译器无法给出警告。</span></span><br><span class="line"><span class="comment">// 但是，实际运行中，程序会崩溃。</span></span><br><span class="line">[obj someMethodNameThatNoObjectAnywhereRespondsTo];</span><br><span class="line"><span class="comment">// 这个时候编译器会给出警告，因为它知道没有任何函数叫someMethodNameThatNoObjectAnywhereRespondsTo</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *hello = <span class="string">@"hello"</span>;</span><br><span class="line">[hello shoot]; <span class="comment">// 编译器会给出警告，因为NSString没有shoot函数</span></span><br><span class="line">Ship *helloShip = (Ship *)hello; <span class="comment">// 编译器不会给出警告 </span></span><br><span class="line">[helloShip shoot];<span class="comment">// 导致运行时崩溃</span></span><br><span class="line">[(<span class="keyword">id</span>)hello shoot]; <span class="comment">//编译器不会给出警告，但是运行时会崩溃</span></span><br></pre></td></tr></table></figure>

<p><strong>什么时候会用到危险的动态绑定（id）</strong></p>
<ol>
<li>Objective-C允许在同一个collection（比如NSArray）中有不同类型的类，想这么做时，需要用到动态绑定。 </li>
<li>当希望使用MVC中的blind/structured通信（比如delegation）时。</li>
</ol>
<p><strong>为了把动态绑定变得安全</strong>，需要使用Introspection和Protocols</p>
<ul>
<li><p>Introspection</p>
<p>在运行时询问id是什么类型或询问可以向其发送的信息。</p>
<p>继承自NSObject的所有对象都有下面三个函数：</p>
<ol>
<li><p><code>isKindOfClass:</code></p>
<p>判断对象是不是某种类，包含继承的情况</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>([obj isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *s = [(<span class="built_in">NSString</span>*)obj stringByAppendingString:<span class="string">@"xyzzy"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如在纸牌匹配游戏中<code>PlayingCard.m</code>的<code>match</code>函数的源代码为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">int</span>)match:(<span class="built_in">NSArray</span> *)otherCards</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>([otherCards count] == <span class="number">1</span>) &#123;</span><br><span class="line">        PlayingCard *otherCard = [otherCards firstObject];</span><br><span class="line">      <span class="keyword">if</span>([<span class="keyword">self</span>.suit isEqualToString:otherCard.suit]) &#123;</span><br><span class="line">            score = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.rank == otherCard.rank) &#123;</span><br><span class="line">            score = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以改为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">int</span>)match:(<span class="built_in">NSArray</span> *)otherCards</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>([otherCards count] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">id</span> card = [otherCards firstObject];</span><br><span class="line">        <span class="keyword">if</span>([card isKindOfClass:[PlayingCard <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            PlayingCard *otherCard = (PlayingCard *)card;</span><br><span class="line">            <span class="keyword">if</span>([<span class="keyword">self</span>.suit isEqualToString:otherCard.suit]) &#123;</span><br><span class="line">                score = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.rank == otherCard.rank) &#123;</span><br><span class="line">                score = <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>isMemberOfClass:</code></p>
<p>判断对象是不是某种类，不包括继承的情况</p>
</li>
<li><p><code>respondsToSelector:</code></p>
<p>判断对象能否相应某个函数</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>([obj respondsToSelector:<span class="keyword">@selector</span>(shoot)]) &#123;</span><br><span class="line">    [obj shoot];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([obj respondsToSelector:<span class="keyword">@selector</span>(shootAt:)]) &#123;</span><br><span class="line">    [obj shootAt:target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>在objective-C中，SEL是selector的一种类型</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">SEL shootSelector = <span class="keyword">@selector</span>(shoot);</span><br><span class="line">SEL shootAtSelector = <span class="keyword">@selector</span>(shootAt:);</span><br><span class="line">SEL moveToSelelctor = <span class="keyword">@selector</span>(moveTo:withPenColor);</span><br></pre></td></tr></table></figure>
</li>
<li><p>给定SEL，可以要求对象执行selector</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[obj performSelector:shootSelector];</span><br><span class="line">[obj performSelector:shootAtSelector withObject:coordinate];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[array makeObjectsPerformSelector:shootSelector];</span><br><span class="line"><span class="comment">// cool, huh?</span></span><br><span class="line">[array makeObjectsPerformSelector:shootAtSelector withObject:target];</span><br><span class="line"><span class="comment">// target is an id</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Protocols</p>
<p>不指定指针指向的对象类型，但是指定其实现的函数。</p>
</li>
</ul>
<h1 id="Foundation库"><a href="#Foundation库" class="headerlink" title="Foundation库"></a>Foundation库</h1><h2 id="NSObject"><a href="#NSObject" class="headerlink" title="NSObject"></a>NSObject</h2><p>在iOS SDK中 ，NSObject几乎是所有类的基类。</p>
<p>NSObject包含一个非常有用的函数<code>- (NSString *)description</code>，会返回对类的描述，所以最好在自己实现的类中对其重写。该函数一般用在两个地方：</p>
<ul>
<li><p>用NSLog打印出来，<code>NSLog(@&quot;array contents are  %@&quot;, myArray);</code>，用于debug</p>
</li>
<li><p>并不是所有的对象都实现了<code>- (id)copy</code>和<code>- (id)mutableCopy</code>，在未实现它们的对象中调用，会抛出异常</p>
</li>
<li><p>你向可修改对象（比如MutableArray）发送copy，返回值并不是可修改对象，而是获得一个不可修改的对象。</p>
</li>
</ul>
<h2 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h2><p>NSArray是对象的有序集合，不可修改（immutable），一旦创建，不能添加或删除对象。</p>
<p>只要NSArray本身在内存的堆中，其中所有的对象都有strong指针指向它们。</p>
<p>一般通过<code>@[]</code>手动创建NSArray，NSArray中包括以下一些关键函数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)count;</span><br><span class="line">- (<span class="keyword">id</span>)objectAtIndex:(<span class="built_in">NSUInteger</span>)index; <span class="comment">//如果index超出边界，程序崩溃</span></span><br><span class="line">- (<span class="keyword">id</span>)lastObject; <span class="comment">//如果数组为空，返回nil，不会导致程序崩溃</span></span><br><span class="line">- (<span class="keyword">id</span>)firstObject; <span class="comment">//如果数组为空，返回nil，不会导致程序崩溃</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)sortedArrayUsingSelector:(SEL)aSelector;</span><br><span class="line">- (<span class="keyword">void</span>)makeObjectsPerformsSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)selectorArgument;</span><br><span class="line">- (<span class="built_in">NSString</span> *)componentsJoinedByString:(<span class="built_in">NSString</span> *)separator;</span><br></pre></td></tr></table></figure>

<h2 id="NSMutableArray"><a href="#NSMutableArray" class="headerlink" title="NSMutableArray"></a>NSMutableArray</h2><p>是NSArray的可变版本（mutable），继承了NSArray的所有函数</p>
<p>一般通过<code>alloc/init</code>创建，或者通过以下函数创建</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)arrayWithCapacity:(<span class="built_in">NSUInteger</span>)numItems;</span><br><span class="line">+ (<span class="keyword">id</span>)array;<span class="comment">//[NSMutableArray array] 等价于 [[NSMutableArray alloc] init]</span></span><br></pre></td></tr></table></figure>

<p>对于NSArray和NSMutableArray两种数组，可以用for-in的方式遍历：</p>
<p>Objective-C支持for-in形式的数组遍历。需要注意的是，for-in形式的数组遍历默认会进行强制类型转换，比如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *myArray = ...;<span class="comment">// 任意类型数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *string <span class="keyword">in</span> myArray) &#123; <span class="comment">//编译器不知道数组中的数据类型</span></span><br><span class="line">  <span class="keyword">double</span> = value = [string doubleValue];<span class="comment">// 如果string的类型并不是NSString，会导致程序崩溃</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么如果数组中的数据类型不同，如何进行遍历呢？可以使用id</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *myArray = ...;<span class="comment">// 同样，任意类型的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">  <span class="comment">// 通过某些方法确认obj是你想要的类型，防止程序崩溃</span></span><br><span class="line">  <span class="keyword">if</span>([obj isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">    <span class="comment">// 这是确认了obj的类型是NSString</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NSNumber"><a href="#NSNumber" class="headerlink" title="NSNumber"></a>NSNumber</h2><p>NSNumber是对元类型int、float、double、BOOL、enum等的封装。<strong>当你想把这些元类型的数据放入同一个数组时很有用。</strong></p>
<h2 id="NSValue"><a href="#NSValue" class="headerlink" title="NSValue"></a>NSValue</h2><p>类似于NSNumber，但是用来封装一些非对象、非元类型的数据，例如c structs。</p>
<h2 id="NSData"><a href="#NSData" class="headerlink" title="NSData"></a>NSData</h2><p>用于存储bits</p>
<h2 id="NSDate"><a href="#NSDate" class="headerlink" title="NSDate"></a>NSDate</h2><p>用于存储日期，相关的类型还有NSCalendar，NSDateFormatter，NSDateComponents。</p>
<h2 id="NSSet-NSMutableSet"><a href="#NSSet-NSMutableSet" class="headerlink" title="NSSet/NSMutableSet"></a>NSSet/NSMutableSet</h2><h2 id="NSOrderedSet-NSMutableOrderedSet"><a href="#NSOrderedSet-NSMutableOrderedSet" class="headerlink" title="NSOrderedSet/NSMutableOrderedSet"></a>NSOrderedSet/NSMutableOrderedSet</h2><h2 id="NSDictionary"><a href="#NSDictionary" class="headerlink" title="NSDictionary"></a>NSDictionary</h2><p>存储键值对，不可修改。</p>
<p>NSDictionary可以用<code>@{key1:value1, key2:value2}</code>创建，比如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *colors = @&#123; <span class="string">@"green"</span> : [<span class="built_in">UIColor</span> greenColor],</span><br><span class="line">                        <span class="string">@"blue"</span> : [<span class="built_in">UIColor</span> blueColor],</span><br><span class="line">                        <span class="string">@"red"</span> : [<span class="built_in">UIColor</span> redColor]&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *colorString = <span class="string">@"red"</span>;</span><br><span class="line"><span class="built_in">UIColor</span> *colorObject = colors[colorString];</span><br></pre></td></tr></table></figure>

<h2 id="NSMutableDictionary"><a href="#NSMutableDictionary" class="headerlink" title="NSMutableDictionary"></a>NSMutableDictionary</h2><p>NSDictionary的可修改版本，出了继承了NSDictionary所有的函数，还有下面几个重要函数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)anObject forKey:(<span class="keyword">id</span>)key;</span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key;</span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects;</span><br><span class="line">- (<span class="keyword">void</span>)addEntriesFromDictionary:(<span class="built_in">NSDictionary</span> *)otherDictionary;</span><br></pre></td></tr></table></figure>

<p>Dictionary和NSMutableDictionary可用如下方法遍历：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *myDictionary = ...;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span> key <span class="keyword">in</span> myDictionary) &#123;</span><br><span class="line">  <span class="comment">// do something with key here</span></span><br><span class="line">  <span class="keyword">id</span> value = [myDictionary objectForKey:key];</span><br><span class="line">  <span class="comment">// do something with value here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NSUserDefaults"><a href="#NSUserDefaults" class="headerlink" title="NSUserDefaults"></a>NSUserDefaults</h2><p>介绍NSUserDefaults之前，需要先介绍一个术语：<strong><em>Property List</em></strong></p>
<p>Property List是一个iOS开发中常用术语，在一些API中会用到，比如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)writeToFile:(<span class="built_in">NSString</span> *)path atomically:(<span class="built_in">BOOL</span>)atom;</span><br></pre></td></tr></table></figure>

<p>这个函数只能发送给NSArray或NSDictionary，并且其中只能包含Property List对象。</p>
<ul>
<li><p><strong>概念：</strong></p>
<p>Property List可以理解为只包含NSArray、NSDictionary、NSNumber、NSString、NSDate、NSDate的一个集合，并且Property List是一个递归的概念。</p>
<p>比如一个由NSString组成的NSArray，就是一个Property List</p>
<p>一个由NSArray组成的NSArray是不是一个Property List要看子NSArray是不是Property List，如果是，那组成的NSArray就是一个Property List，否则不是。</p>
<p>对于NSDictionary，只有当其所有key和value都是Property List的时候才是Property List</p>
<p>那么，假设有一个NSArray，其中包含了多个NSDictionary，这些NSDictionary的key都是NSString，value都是NSNumber，那么这个NSArray也是个Property List</p>
</li>
</ul>
<p>NSUserDefaults就是Property List的轻量级存储，可以看成一个持久存储的NSDictionary。算不上一个数据库，通常只用来存储小数据，比如用户设置。</p>
<p>利用standardUserDefaults读写：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setArray:rvArray forKey:<span class="string">@"RecentlyViewed"</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setDouble:(<span class="keyword">double</span>)aDouble forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="built_in">NSInteger</span>)integerForKey;(<span class="built_in">NSString</span> *)key; <span class="comment">// NSInteger is a typedef to 32 or 64 bit int</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)obj forKey:(<span class="built_in">NSString</span> *)key; <span class="comment">//obj must be a Property List</span></span><br><span class="line">-(<span class="built_in">NSArray</span> *)arrayForKey:(<span class="built_in">NSString</span> *)key; <span class="comment">// will return nil if value for key is not NSArray</span></span><br></pre></td></tr></table></figure>

<p>更改后一定要使用synchronize进行同步，才能写入永久内存。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSUser</span> Defaults standardUserDefaults] synchronize];</span><br></pre></td></tr></table></figure>

<h2 id="NSRange"><a href="#NSRange" class="headerlink" title="NSRange"></a>NSRange</h2><p>是一个类似C语言中struct的结构，用于指定string和数组的界限，其结构如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="built_in">NSUInteger</span> location;</span><br><span class="line">  <span class="built_in">NSUInteger</span> length;</span><br><span class="line">&#125; <span class="built_in">NSRange</span>;</span><br></pre></td></tr></table></figure>

<p>使用方法如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *greeting = <span class="string">@"hello world"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *hi = <span class="string">@"hi"</span>;</span><br><span class="line"><span class="built_in">NSRange</span> r = [greeting rangeOfString:hi];</span><br><span class="line"><span class="keyword">if</span>(r.location == <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">  <span class="comment">//没能在greeting中找到hi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UIColor"><a href="#UIColor" class="headerlink" title="UIColor"></a>UIColor</h2><p>一个非常简单的类，用于表示颜色。可以用RGB或者HSB等方法初始化。</p>
<h2 id="UIFont"><a href="#UIFont" class="headerlink" title="UIFont"></a>UIFont</h2><p>字体在UI设计中非常重要，iOS在不同截面显示的字体变化很大，所以要重视UIFont这个类。</p>
<p>对于展示内容而言，使用Font<strong>最好的方法</strong>是调用<code>preferredFontForTextStyle</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> preferredFontForTextStyle:<span class="built_in">UIFontTextStyleBody</span>];</span><br></pre></td></tr></table></figure>

<p>除了<code>UIFontTextStyleBody</code>，还有<code>UIFontTextStyleHeadline</code>、<code>UIFontTextStyleCaption1</code>、<code>UIFontTextStyleFootnote</code>等等。</p>
<p>对于按键内容等，可以使用系统字体：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">UIFont</span> *)systemFontOfSize:(<span class="built_in">CGFloat</span>)pointSize;</span><br><span class="line">+ (<span class="built_in">UIFont</span> *)boldSystemFontOfSize:(<span class="built_in">CGFloat</span>)pointSize;</span><br></pre></td></tr></table></figure>

<p><strong>不要将系统字体用于内容。</strong></p>
<h2 id="UIFontDescriptor"><a href="#UIFontDescriptor" class="headerlink" title="UIFontDescriptor"></a>UIFontDescriptor</h2><p>字体是由艺术家设计的，并没有特定的准则，有些字体甚至没有加黑。尽管如此，UIFontDescriptor尝试对所有字体进行分类。</p>
<h2 id="NSAttributedString"><a href="#NSAttributedString" class="headerlink" title="NSAttributedString"></a>NSAttributedString</h2><p>iOS开发中经常需要显示一些带有特殊样式的文本，比如说带有下划线、删除线、斜体、空心字体、背景色、阴影以及图文混排（一种文字中夹杂图片的显示效果）。</p>
<p>通常想要实现这些效果要使用到iOS的Foundation框架提供的NSAttributedString类，NSAttributedString类中有许多属性，不同属性对应不同的文本样式。本文主要对这些属性做一个解释说明，并会结合实际代码来应用它们。</p>
<p>可以将NSAttributedString想象成NSString，其每个字母有个叫做attributes的NSDictionary。 </p>
<p>NSAttributedString<strong>不是</strong>NSString的继承，所以不能使用NSString的函数。</p>
<h2 id="NSMutableAttributedString"><a href="#NSMutableAttributedString" class="headerlink" title="NSMutableAttributedString"></a>NSMutableAttributedString</h2><p>相对于NSAttributedString，NSMutableAttributedString更加常用。</p>
<p>添加或者设置字母对应attributes的方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addAttributes:(<span class="built_in">NSDictionary</span> *)attributes range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line">- (<span class="keyword">void</span>)setAttributeds:(<span class="built_in">NSDictionary</span> *)attributes range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line">-(<span class="keyword">void</span>)removeAttribute:(<span class="built_in">NSString</span> *)attributeName range:(<span class="built_in">NSRange</span>)range;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *yellow = [<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line"><span class="built_in">UIColor</span> *transparentYellow = [yellow colorWithAlphaComponent:<span class="number">0.3</span>];</span><br><span class="line">@&#123; <span class="built_in">NSFontAttributeName</span>:</span><br><span class="line">     [<span class="built_in">UIFont</span> preferredFontWithTextStyle:<span class="built_in">UIFontTextStyleHeadline</span>],</span><br><span class="line">   <span class="built_in">NSForegroundColorAttributeName</span> : [<span class="built_in">UIColor</span> greenColor], <span class="comment">// 字体颜色</span></span><br><span class="line">   <span class="built_in">NSStrokeWidthAttributeName</span> : @<span class="number">-5</span>,</span><br><span class="line">   <span class="built_in">NSStrokeColorAttributeName</span> : [<span class="built_in">UIColor</span> redColor],</span><br><span class="line">   <span class="built_in">NSUnderlineStyleAttributeName</span> : @(<span class="built_in">NSUnderlineStyleNone</span>), <span class="comment">// 设置字体描边</span></span><br><span class="line">   <span class="built_in">NSBackgroundColorAttributeName</span> : transparentYellow <span class="comment">// 设置字体背景颜色</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp14yomq5ij30ds0oggrt.jpg" alt="image-20210329221812138"></p>
<p>attributed strings用在哪里？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UIButton</span></span><br><span class="line">- (<span class="keyword">void</span>)setAttributedTitle:(<span class="built_in">NSAttributedString</span> *)title forState:...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UILable</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSAttributedString</span> *attributedText;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UITextView</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSTextStorage</span> *textStorage;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福大学IOS7开发课程3</title>
    <url>/chinese/2021/03/22/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B3/</url>
    <content><![CDATA[<h1 id="斯坦福大学IOS7开发课程3"><a href="#斯坦福大学IOS7开发课程3" class="headerlink" title="斯坦福大学IOS7开发课程3"></a>斯坦福大学IOS7开发课程3</h1><p>课程3主要内容是继续之前的纸牌游戏。上节课实现的纸牌游戏App只是实现了简单的纸牌翻转，这节课使其变得真正可玩。</p>
<p>主要分为三个部分：</p>
<ol>
<li>先回顾上节课编写的App</li>
<li>对上节课的App改进</li>
<li>使游戏变得可玩</li>
</ol>
<a id="more"></a>

<h2 id="上节课实现的纸牌翻转App"><a href="#上节课实现的纸牌翻转App" class="headerlink" title="上节课实现的纸牌翻转App"></a>上节课实现的纸牌翻转App</h2><ol>
<li><p><strong>将背景颜色设置为绿色</strong></p>
<p>打开<code>Main.storyboard</code>，选中View后，在属性栏里将<code>Background</code>的颜色设置为绿色。</p>
</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo58d9362j30ee0oe773.jpg" class="setBackgroundColor" width="300" height="700" title="设置Background颜色" alt="加载失败">

<ol start="2">
<li><p><strong>添加纸牌正反面的图片</strong></p>
<p>在网上获取纸牌正反面图片，比如：</p>
</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo59iuj4rj30dw0jgqdw.jpg" class="CardBack" width="100" height="250" title="纸牌背面" alt="加载失败">

<img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo59sknnzj30dw0jg74b.jpg" class="CardFront" width="100" height="250" title="纸牌正面" alt="加载失败">


<p>   选中<code>Assets.xcassets</code>，将两张图片拖至其中。</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo5bh0htpj31e00d4adb.jpg" class="addImage" width="600" height="200" title="添加图片到Assets.xcassets" alt="加载失败">

<ol start="3">
<li><strong>添加按钮，并将按钮的背景图片改为纸牌正面图片（CardFront）， 文字改为“♠️A”</strong></li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo5fk47bsj31sg0r4wpk.jpg" class="setButtonBackground" width="600" height="300" title="设置按钮背景图片" alt="加载失败">

<ol start="4">
<li><p><strong>添加一个<code>Label</code>，显示纸牌翻转的次数</strong></p>
</li>
<li><p><strong>为按钮添加“Touch Up Inside”事件，命名为<code>touchCardButton</code></strong></p>
</li>
<li><p><strong>为<code>Label</code>在<code>ViewController.m</code>的<code>@interface ViewController() @end</code>之间添加“Referencing Outlets“，命名为<code>flipsLabel</code>。</strong></p>
</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gooawynczug30v00ienpd.gif" class="addOutlets" width="600" height="300" title="为Label添加Outlet" alt="加载失败">

<ol start="7">
<li><p><strong>另外，在<code>ViewController.m</code>的<code>@interface ViewController() @end</code>之间添加int属性<code>flipCount</code></strong></p>
</li>
<li><p><strong>在<code>ViewController.m</code>中实现touchCardButton事件函数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (IBAction)touchCardButton:(UIButton *)sender &#123;</span><br><span class="line">    if ([sender.currentTitle length]) &#123;</span><br><span class="line">        [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardBack&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [sender setTitle:@&quot;&quot; forState:UIControlStateNormal];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Card *card &#x3D; [self.deck drawRandomCard];</span><br><span class="line">        if(card) &#123;</span><br><span class="line">        [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardFront&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [sender setTitle:@&quot;A♣️&quot; forState:UIControlStateNormal];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    self.flipCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重构属性<code>flipCount</code>的<code>setter</code>函数。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setFlipCount:(int)flipCount</span><br><span class="line">&#123;</span><br><span class="line">    _flipCount &#x3D; flipCount;</span><br><span class="line">    self.flipsLabel.text &#x3D; [NSString stringWithFormat:@&quot;Flips: %d&quot;,self.flipCount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>此时App完成，代码如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ViewController.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController : UIViewController</span><br><span class="line">- (IBAction)touchCardButton:(UIButton *)sender;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ViewController.m</span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (weak, nonatomic) IBOutlet UILabel *flipsLabel;</span><br><span class="line">@property (nonatomic) int flipCount;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)touchCardButton:(UIButton *)sender &#123;</span><br><span class="line">    if ([sender.currentTitle length]) &#123;</span><br><span class="line">        [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardBack&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [sender setTitle:@&quot;&quot; forState:UIControlStateNormal];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardFront&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [sender setTitle:@&quot;A♣️&quot; forState:UIControlStateNormal];</span><br><span class="line">    &#125;</span><br><span class="line">    self.flipCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFlipCount:(int)flipCount</span><br><span class="line">&#123;</span><br><span class="line">    _flipCount &#x3D; flipCount;</span><br><span class="line">    self.flipsLabel.text &#x3D; [NSString stringWithFormat:@&quot;Flips: %d&quot;,self.flipCount];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>最终效果如下：</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1goob73x6nkg30j816ykjm.gif" class="result1" width="300" height="700" title="最终效果1" alt="加载失败">



<h2 id="对该App改进"><a href="#对该App改进" class="headerlink" title="对该App改进"></a>对该App改进</h2><p>上节课完成的App只能实现纸牌的翻转，每次翻转显示的纸牌都是同一张。那么如何让每次翻转，随机显示牌堆中的一张纸牌呢？其实也很简单，方法如下：</p>
<ol>
<li><p><strong>在<code>ViewController.m</code>中引入<code>Deck.h</code></strong></p>
</li>
<li><p><strong>在<code>ViewController.m</code>的<code>@interface ViewController() @end</code>之间添加<code>Deck*</code>属性<code>deck</code></strong></p>
</li>
<li><p><strong>在<code>ViewController.m</code>中引入<code>PlayingCardDeck.h</code></strong></p>
</li>
<li><p><strong>修改属性<code>deck</code>的<code>getter</code>，当<code>_deck</code>为空时，通过<code>[[PlayingCardDeck alloc]init]</code>创建牌堆，然后再返回Deck。</strong></p>
<p>此时<code>ViewController.m</code>的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  ViewController.m</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">#import &quot;PlayingCardDeck.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (weak, nonatomic) IBOutlet UILabel *flipsLabel;</span><br><span class="line">@property (nonatomic) int flipCount;</span><br><span class="line">@property (strong, nonatomic) Deck *deck;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Deck *)deck</span><br><span class="line">&#123;</span><br><span class="line">    if(!_deck)</span><br><span class="line">        _deck &#x3D; [self createDeck];</span><br><span class="line">    return _deck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Deck *)createDeck</span><br><span class="line">&#123;</span><br><span class="line">    return [[PlayingCardDeck alloc]init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (IBAction)touchCardButton:(UIButton *)sender &#123;</span><br><span class="line">    if ([sender.currentTitle length]) &#123;</span><br><span class="line">        [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardBack&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [sender setTitle:@&quot;&quot; forState:UIControlStateNormal];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardFront&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [sender setTitle:@&quot;A♣️&quot; forState:UIControlStateNormal];</span><br><span class="line">    &#125;</span><br><span class="line">    self.flipCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFlipCount:(int)flipCount</span><br><span class="line">&#123;</span><br><span class="line">    _flipCount &#x3D; flipCount;</span><br><span class="line">    self.flipsLabel.text &#x3D; [NSString stringWithFormat:@&quot;Flips: %d&quot;,self.flipCount];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在<code>touchCardButton</code>函数中，利用<code>deck</code>的<code>drawRandomCard</code>函数随机抽取一张纸牌。</strong></p>
</li>
<li><p><strong>将随机抽取出的Card的内容显示出来。需要注意的是，牌堆里的牌抽完以后要停止抽牌。</strong></p>
</li>
</ol>
<p>完成后<code>ViewController.m</code>的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ViewController.m</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">#import &quot;PlayingCardDeck.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (weak, nonatomic) IBOutlet UILabel *flipsLabel;</span><br><span class="line">@property (nonatomic) int flipCount;</span><br><span class="line">@property (strong, nonatomic) Deck *deck;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Deck *)deck</span><br><span class="line">&#123;</span><br><span class="line">    if(!_deck)</span><br><span class="line">        _deck &#x3D; [self createDeck];</span><br><span class="line">    return _deck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Deck *)createDeck</span><br><span class="line">&#123;</span><br><span class="line">    return [[PlayingCardDeck alloc]init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)touchCardButton:(UIButton *)sender &#123;</span><br><span class="line">    if ([sender.currentTitle length]) &#123;</span><br><span class="line">        [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardBack&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [sender setTitle:@&quot;&quot; forState:UIControlStateNormal];</span><br><span class="line">        self.flipCount++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Card *card &#x3D; [self.deck drawRandomCard]; &#x2F;&#x2F; 从牌堆抽随机取一张Card</span><br><span class="line">        if(card) &#123; &#x2F;&#x2F; 牌堆里的牌抽完以后停止抽牌</span><br><span class="line">            [sender setBackgroundImage:[UIImage imageNamed:@&quot;CardFront&quot;] forState:UIControlStateNormal];</span><br><span class="line">            [sender setTitle:card.contents forState:UIControlStateNormal]; &#x2F;&#x2F; 将Card的内容展示出来</span><br><span class="line">            self.flipCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFlipCount:(int)flipCount</span><br><span class="line">&#123;</span><br><span class="line">    _flipCount &#x3D; flipCount;</span><br><span class="line">    self.flipsLabel.text &#x3D; [NSString stringWithFormat:@&quot;Flips: %d&quot;,self.flipCount];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1goobso7hl7g30j816yx6r.gif" class="result2" width="300" height="700" title="最终效果2" alt="加载失败">



<h2 id="使该游戏变得真正可玩"><a href="#使该游戏变得真正可玩" class="headerlink" title="使该游戏变得真正可玩"></a>使该游戏变得真正可玩</h2><p>接下来我们让游戏变得真正可玩儿。在MVC开发模型中，游戏的逻辑属于Model，Model和UI是完全独立的，所以在编写过程中不需要考虑UI。</p>
<h3 id="Model开发"><a href="#Model开发" class="headerlink" title="Model开发"></a>Model开发</h3><p>首先添加一个新的类<code>CardMatchingGame</code>，这个类就是MVC模型中的Model，在编码<code>CardMathingGame</code>的过程中，需要思考需要哪些公开的API。</p>
<ol>
<li>首先是构造函数，因为需要传进一些参数，比如牌的张数，所以新建构造函数<code>initWithCardCount</code>，指定构造函数（designated initializer）</li>
<li>公开的属性 score，但同时我们不希望别人能够随意修改socre属性，因此需要在公开API中将其设置为readonly，同时在.m文件中的私密API中声明为readwrite。其实readwrite用的不多，因为默认情况下就是readwrite，只有在公开API只读的时候才会用到。</li>
<li>允许用户通过index选中纸牌<code>chooseCardAtIndex</code></li>
<li>通过index从牌堆中获取Card，<code>CardAtIndex</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; CardMatchingGame.h</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface CardMatchingGame : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; designated initializer</span><br><span class="line">- (instancetype)initWithCardCount:(NSUInteger)count usingDeck:(Deck *)deck;</span><br><span class="line">- (void)chooseCardAtIndex:(NSUInteger)index;</span><br><span class="line">- (Card *)cardAtIndex:(NSUInteger)index;</span><br><span class="line">@property (nonatomic, readonly) NSInteger score;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure>

<p>接下来开始在<code>CardMatchingGame.m</code>中开始实现:</p>
<ol>
<li><p>利用关键字<code>readwrite</code>使得属性score在<code>CardMatchingGame.m</code>中可写。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CardMatchingGame</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSInteger</span> score;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>新建属<code>cards</code>，用于存储游戏中的纸牌。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CardMatchingGame</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSInteger</span> score;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *cards; <span class="comment">// of Card</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改属性<code>cards</code>的<code>getter</code>函数</p>
<p>属性的默认初始值为nil，当属性<code>cards</code>的指针为nil时，创建一个<code>NSMutableArray</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-(NSMutableArray *)cards</span><br><span class="line">&#123;</span><br><span class="line">    if(!_cards) &#123;</span><br><span class="line">        _cards &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    return _cards;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现构造函数<code>initWithCardCount</code></p>
<p>这个构造函数是designated initializer，也就是说使用这个类的用户必须调用这个构造函数，否则类无法被正确的初始化。使用构造函数init会返回nil。这个信息要传递给用户，所以以注释的形式写在公开API中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-(instancetype) initWithCardCount:(NSUInteger)count usingDeck:(Deck *)deck</span><br><span class="line">&#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if(self) &#123;</span><br><span class="line">        for(int i &#x3D; 0;i &lt; count;i++) &#123;</span><br><span class="line">            Card *card &#x3D; [deck drawRandomCard];</span><br><span class="line">            if(card) &#123;</span><br><span class="line">                [self.cards addObject:card];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                self &#x3D; nil;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现函数<code>cardAtIndex</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (Card *)cardAtIndex:(NSUInteger)index</span><br><span class="line">&#123;</span><br><span class="line">    return index &lt; [self.cards count] ? self.cards[index] : nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现函数<code>chooseCardAtIndex</code></p>
<p>这个函数是游戏的关键。表示某个card被选中后的处理方式，包括匹配过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static const int PENALTY_SCORE &#x3D; 1;</span><br><span class="line">static const int COST_OF_CHOOSE &#x3D; 1;</span><br><span class="line"></span><br><span class="line">-(void)chooseCardAtIndex:(NSUInteger)index</span><br><span class="line">&#123;</span><br><span class="line">    Card *card &#x3D; [self cardAtIndex:index];</span><br><span class="line">    if(!card.isMatched) &#123;</span><br><span class="line">        &#x2F;&#x2F; if choosen card is not matched</span><br><span class="line">        if(card.isChosen) &#123; &#x2F;&#x2F; if the card is already chosen</span><br><span class="line">            card.chosen &#x3D; NO; &#x2F;&#x2F; filp the card back</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; match it against another card</span><br><span class="line">            &#x2F;&#x2F; here, only match two cards, but may make it match multiple cards in later</span><br><span class="line">            for(Card *otherCard in self.cards) &#123;</span><br><span class="line">                if(otherCard.isChosen &amp;&amp; !otherCard.isMatched) &#123; &#x2F;&#x2F; Bingo, find the card we want to match</span><br><span class="line">                    int matchScore &#x3D; [card match:@[otherCard]]; &#x2F;&#x2F; try to match it</span><br><span class="line">                    if(matchScore &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; not match</span><br><span class="line">                        self.score -&#x3D; PENALTY_SCORE; &#x2F;&#x2F; penalty of un match</span><br><span class="line">                        otherCard.chosen &#x3D; NO; &#x2F;&#x2F; flip the other card back</span><br><span class="line">                    &#125; else &#123; &#x2F;&#x2F; match</span><br><span class="line">                        self.score +&#x3D; matchScore;</span><br><span class="line">                        card.matched &#x3D; YES;</span><br><span class="line">                        otherCard.matched &#x3D; YES;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            card.chosen &#x3D; YES;</span><br><span class="line">            self.score -&#x3D; COST_OF_CHOOSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; if choosen card is already matched</span><br><span class="line">        &#x2F;&#x2F; do nothing</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="UI开发"><a href="#UI开发" class="headerlink" title="UI开发"></a>UI开发</h3><p>到目前，完成了App中Model的实现，接下来是实现App的UI。</p>
<ol>
<li><p>在UI中创建多张纸牌，可以通过复制粘贴的方式完成</p>
</li>
<li><p>创建OutletCollections，添加所有纸牌。</p>
<p>创建方法，右键点击某个button，按住“New Referencing Outlet Collections“，拖到<code>ViewController.m</code>中。</p>
<p>添加其他button的方法，按住Ctrl键，点击button并拖到<code>ViewController.m</code>中</p>
</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gopcewkpqrg30n80v41l3.gif" class="addOutletCollections" width="300" height="700" title="添加OutletCollections" alt="加载失败">

<ol start="3">
<li><p>在<code>ViewController.m</code>中引入<code>CardMatchingGame.h</code></p>
</li>
<li><p>新增<code>CardMatchingGame</code>的属性<code>game</code></p>
<p><code>@property (strong, nonatomic) CardMatchingGame *game;</code></p>
</li>
<li><p>重写属性<code>game</code>的<code>getter</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (CardMatchingGame *)game&#123;</span><br><span class="line">    <span class="keyword">if</span>(!_game) &#123;</span><br><span class="line">        _game = [[CardMatchingGame alloc] initWithCardCount:[<span class="keyword">self</span>.cardButtons count] usingDeck:[<span class="keyword">self</span> createDeck]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _game;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>ViewController.m</code>中创建函数<code>titleForCard</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSString *)titleForCard:(Card *)card</span><br><span class="line">&#123;</span><br><span class="line">    return card.isChosen ? card.contents : @&quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>ViewController.m</code>中创建函数<code>backgroundImageForCard</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)backgroundImageForCard:(Card *)card</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageNamed:card.isChosen ? <span class="string">@"CardFront"</span> : <span class="string">@"CardBack"</span>]; <span class="comment">// CardFront &amp; CardBack are name of card image</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>ViewController.m</code>中创建函数<code>updateUI</code>用于同步Model和UI。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateUI</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIButton</span> *cardButton <span class="keyword">in</span> <span class="keyword">self</span>.cardButtons) &#123;</span><br><span class="line">        <span class="keyword">int</span> cardIndex = [<span class="keyword">self</span>.cardButtons indexOfObject:cardButton];</span><br><span class="line">        Card *card = [<span class="keyword">self</span>.game cardAtIndex:cardIndex];</span><br><span class="line">        [cardButton setTitle:[<span class="keyword">self</span> titleForCard:card] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        [cardButton setBackgroundImage:[<span class="keyword">self</span> backgroundImageForCard:card] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        cardButton.enabled = !card.isMatched;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Touch Up Inside事件，命名为touchCardButton，并将所有button加入其中，方法类似于步骤2.</p>
</li>
<li><p><code>.m</code>文件中实现<code>touchCardButton</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)touchCardButton:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">    <span class="keyword">int</span> cardIndex = [<span class="keyword">self</span>.cardButtons indexOfObject:sender];</span><br><span class="line">    [<span class="keyword">self</span>.game chooseCardAtIndex:cardIndex];</span><br><span class="line">    [<span class="keyword">self</span> updateUI];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>到这个时候App已经可以运行了，运行效果如下：</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosmu8s2gmg30j01261kx.gif" class="result3" width="300" height="700" title="最终效果3" alt="加载失败">

<p>可以正常运行，但是两张黑桃却没有正常匹配，问题出在哪里？</p>
<p>问题在我们在<a href="https://zhang-tianxu.github.io/chinese/2021/03/15/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B2/">课程2</a>中实现的<code>Card</code>类中的匹配函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Card.m</span><br><span class="line">- (int)match:(NSArray *)otherCards</span><br><span class="line">&#123;</span><br><span class="line">  int score &#x3D; 0;</span><br><span class="line">  for(Card *card in otherCards) &#123;</span><br><span class="line">    if([card.contents isEqualToString:self.contents])</span><br><span class="line">      score &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">    return score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这显然不是一个完整的匹配逻辑。</p>
<p>所以需要在<code>PlayingCard</code>类的<code>.m</code>文件中重构<code>match</code>函数。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">int</span>)match:(<span class="built_in">NSArray</span> *)otherCards</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>([otherCards count] == <span class="number">1</span>) &#123;</span><br><span class="line">        PlayingCard *otherCard = [otherCards firstObject];</span><br><span class="line">        <span class="keyword">if</span>([<span class="keyword">self</span>.suit isEqualToString:otherCard.suit]) &#123; <span class="comment">// 如果花色匹配</span></span><br><span class="line">            score = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span>.rank == otherCard.rank]) &#123; <span class="comment">// 如果数字匹配</span></span><br><span class="line">            score = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在完成了匹配规则，最后一个任务是添加一个<code>Label</code>用于展示分数。</p>
<ol>
<li><p>在UI中增加一个Label</p>
</li>
<li><p>为Label增加一个Outlet</p>
</li>
<li><p>在<code>updateUI</code>中更新score Label。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)updateUI</span><br><span class="line">&#123;</span><br><span class="line">    for (UIButton *cardButton in self.cardButtons) &#123;</span><br><span class="line">        int cardIndex &#x3D; [self.cardButtons indexOfObject:cardButton];</span><br><span class="line">        Card *card &#x3D; [self.game cardAtIndex:cardIndex];</span><br><span class="line">        [cardButton setTitle:[self titleForCard:card] forState:UIControlStateNormal];</span><br><span class="line">        [cardButton setBackgroundImage:[self backgroundImageForCard:card] forState:UIControlStateNormal];</span><br><span class="line">        cardButton.enabled &#x3D; !card.isMatched;</span><br><span class="line">    &#125;</span><br><span class="line">    self.scoreLabel.text &#x3D; [NSString stringWithFormat:@&quot;Score: %d&quot;, self.game.score];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosov9rkvfg30j0126kjl.gif" class="result4" width="300" height="700" title="最终效果4" alt="加载失败">

<p>至此，一个可玩的纸牌匹配游戏App已经完成，大家可以试着让App可以同时匹配三张及以上的纸牌。</p>
]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福大学IOS7开发课程2</title>
    <url>/chinese/2021/03/15/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B2/</url>
    <content><![CDATA[<h1 id="斯坦福大学IOS7开发课程2"><a href="#斯坦福大学IOS7开发课程2" class="headerlink" title="斯坦福大学IOS7开发课程2"></a>斯坦福大学IOS7开发课程2</h1><p>这节课就着手开始实现”Card Matching Game”，纸牌匹配游戏。</p>
<p>具体来说就是实现涉及的各种类，以及XCode的简单使用。</p>
<a id="more"></a>

<h2 id="Card类"><a href="#Card类" class="headerlink" title="Card类"></a>Card类</h2><p>下面代码是<a href="https://zhang-tianxu.github.io/chinese/2021/03/15/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B1/">课程1</a>结束时的Card类，包括<code>Card.h</code>和<code>Card.m</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Card.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation&gt;</span><br><span class="line">@interface Card : NSObject</span><br><span class="line">@property (strong nonatomic) NSString *contents;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, getter&#x3D;isChosen) BOOL chosen;</span><br><span class="line">@property (nonatomic, getter&#x3D;isMatched) BOOL matched;</span><br><span class="line">- (int)match:(NSArray *)otherCards;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Card.m</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line">@interface Card()</span><br><span class="line">@end</span><br><span class="line">@implementation Card</span><br><span class="line"></span><br><span class="line">- (int)match:(NSArray *)otherCards</span><br><span class="line">&#123;</span><br><span class="line">  int score &#x3D; 0;</span><br><span class="line">  for(Card *card in otherCards) &#123;</span><br><span class="line">    if([card.contents isEqualToString:self.contents])</span><br><span class="line">      score &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="Deck类"><a href="#Deck类" class="headerlink" title="Deck类"></a>Deck类</h2><p>这节课首先添加另外一个类：整幅牌Deck，下面是上节课学的类的基本结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Deck : NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.m</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">@interface Deck()</span><br><span class="line">@end</span><br><span class="line">@implementation Deck</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>接下来为Deck类添加两个基础的方法:</p>
<ul>
<li>向Deck中添加牌的<code>addCard</code>，其中atTop表示是否将新的牌放在牌堆的顶部。</li>
<li>另一个是从Deck中随机抽取牌的<code>drawRandomCard</code>：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line"></span><br><span class="line">@interface Deck : NSObject</span><br><span class="line">- (void)addCard:(Card *)card atTop:(BOOL)atTop;</span><br><span class="line"></span><br><span class="line">- (Card *)drawRandomCard;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>如果希望<code>addCard</code>的参数<code>atTop</code>是<strong>可选参数</strong>，在Objective-C中唯一的方法就是声明一个新的函数，这个函数也叫<code>addCard</code>，但是没有参数<code>atTop</code>。这两个<code>addCard</code>是两个不同的函数，相互之间并没有关联。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line"></span><br><span class="line">@interface Deck : NSObject</span><br><span class="line">- (void)addCard:(Card *)card atTop:(BOOL)atTop;</span><br><span class="line">- (void)addCard:(Card *)card;</span><br><span class="line"></span><br><span class="line">- (Card *)drawRandomCard;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>为了存储牌堆中的牌，需要在私密API中添加一个属性，类型是可变数组<code>NSMutableArray</code>。mutable意味着可以向数组中添加或删除数据，而普通的<code>NSArray</code>是不能修改的，一旦被建立，不能添加数据也不能删除。</p>
<p><strong>在Objective-C中声明数组没办法指定数据类型。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.m</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">@interface Deck()</span><br><span class="line">@property (strong, nonatomic) NSMutableArray *cards; &#x2F;&#x2F; of Card</span><br><span class="line">@end</span><br><span class="line">@implementation Deck</span><br><span class="line">  </span><br><span class="line">- (void)addCard:(Card *)card atTop:(BOOL)atTop</span><br><span class="line">&#123;</span><br><span class="line">  if (atTop) &#123;</span><br><span class="line">    [self.cards insertObject:card atIndex:0];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    [self.cards addObject:card];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addCard:(Card *)card</span><br><span class="line">&#123;</span><br><span class="line">  [self addCard:card atTop:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Card *)drawRandomCard</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>根据上节课说到构建属性时自动生成的getter和setter，新建一个Deck类后，其所有的变量和属性都<strong><em>会被自动初始化为0/nil</em></strong>，属性<code>cards</code>是一个空指针，因此调用<code>addCard</code>时虽然不会导致程序的崩溃，但是也不能正常工作。</p>
<p>那么怎么解决这个问题呢？方法是重写属性的getter函数，在getter中添加一个判断结构，属性cards自动生成的getter是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSMutableArray *)cards</span><br><span class="line">&#123;</span><br><span class="line">  return _cards;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了在其中添加一个判断逻辑，需要手动重写这个getter：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.m</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">@interface Deck()</span><br><span class="line">@property (strong, nonatomic) NSMutableArray *cards; &#x2F;&#x2F; of Card</span><br><span class="line">@end</span><br><span class="line">@implementation Deck</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 为了处理cards为空指针的情况，手动重写getter</span><br><span class="line">- (NSMutableArray *)cards</span><br><span class="line">&#123;</span><br><span class="line">  if(!_cards) _cards &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">  return _cards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addCard:(Card *)card atTop:(BOOL)atTop</span><br><span class="line">&#123;</span><br><span class="line">  if (atTop) &#123;</span><br><span class="line">    [self.cards insertObject:card atIndex:0];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    [self.cards addObject:card];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addCard:(Card *)card</span><br><span class="line">&#123;</span><br><span class="line">  [self addCard:card atTop:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Card *)drawRandomCard</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>接下来实现<code>drawRandomCard</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Deck.m</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line">@interface Deck()</span><br><span class="line">@property (strong, nonatomic) NSMutableArray *cards; &#x2F;&#x2F; of Card</span><br><span class="line">@end</span><br><span class="line">@implementation Deck</span><br><span class="line"></span><br><span class="line">- (  NSMutableArray *)cards</span><br><span class="line">&#123;</span><br><span class="line">  if(!_cards) _cards &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">  return _cards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addCard:(Card *)card atTop:(BOOL)atTop</span><br><span class="line">&#123;</span><br><span class="line">  if (atTop) &#123;</span><br><span class="line">    [self.cards insertObject:card atIndex:0];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    [self.cards addObject:card];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addCard:(Card *)card</span><br><span class="line">&#123;</span><br><span class="line">  [self addCard:card atTop:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Card *)drawRandomCard</span><br><span class="line">&#123;</span><br><span class="line">  Card *randomCard &#x3D; nil;</span><br><span class="line">  </span><br><span class="line">  if([self.cards count]) &#123;</span><br><span class="line">    unsigned index &#x3D; arc4random() % [self.cards count];</span><br><span class="line">    randomCard &#x3D; self.cards[index];</span><br><span class="line">    [self.cards removeObjectAtIndex:index];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return randomCard;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>至此，Deck类已经完成。</p>
<h2 id="PlayingCard类"><a href="#PlayingCard类" class="headerlink" title="PlayingCard类"></a>PlayingCard类</h2><p>接下来再添加一个类：<code>PlayingCard</code>，同样的，基本结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.h</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line">@interface PlayingCard : Card &#x2F;&#x2F; 终于有个类的父类不是NSObject了</span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>给类添加两个属性<code>suit</code>和<code>rank</code>，前者表示牌的花色“桃（hearts）”、“（方片）diamons”、“（梅花）clubs”，后者表示1到13。另外在<code>.m</code>文件中，重写父类属性content的getter。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.h</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line">@interface PlayingCard : Card</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) NSString *suit;</span><br><span class="line">@property (nonatomic) NSUInteger rank;</span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  return [NSString stringWithFormat:@&quot;%d%@&quot;,self.rank, self.suit];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>注意到，字符串前面有个<code>@</code>，这<strong><em>表示把字符串变成一个字符串类</em></strong>。其中<code>%@</code>表示一个对象，当然可以是字符串。</p>
<p>重写父类属性contents的getter之后，获取contents内容会返回“数字 + 花色”，比如“3红桃”、“1梅花”、“13方片”等。但是在纸牌中，我们一般会把1说成A，11说成J等……，为了符合这个习惯，上面的contents重写可以改成下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  NSArray *rankStrings &#x3D; @[@&quot;?&quot;,@&quot;A&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;10&quot;,@&quot;J&quot;,@&quot;Q&quot;,@&quot;K&quot;];</span><br><span class="line">  &#x2F;&#x2F; 将0-13表示为?,1,2,...,J,Q,K</span><br><span class="line">  return [rankStrings[self.rank] stringByAppendingString:self.suit];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>将rank的0设置为”？“是因为objective-C默认将rank初始化为0，”？“表示这是未知的，没有经过设置的。那如果花色没经过设置也会显示”？“就更好了，解决方法也是重写suit属性的getter函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  NSArray *rankStrings &#x3D; @[@&quot;?&quot;,@&quot;A&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;10&quot;,@&quot;J&quot;,@&quot;Q&quot;,@&quot;K&quot;];</span><br><span class="line">  &#x2F;&#x2F; 将0-13表示为?,1,2,...,J,Q,K</span><br><span class="line">  return [rankStrings[self.rank] stringByAppendingString:self.suit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  return _suit?_suit:@&quot;?&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>suit的选择应该只有四种，为了防止suit被设置为其他值，还要重写suit属性的setter：<code>setSuit</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  NSArray *rankStrings &#x3D; @[@&quot;?&quot;,@&quot;A&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;10&quot;,@&quot;J&quot;,@&quot;Q&quot;,@&quot;K&quot;];</span><br><span class="line">  &#x2F;&#x2F; 将0-13表示为?,1,2,...,J,Q,K</span><br><span class="line">  return [rankStrings[self.rank] stringByAppendingString:self.suit];</span><br><span class="line">&#125;</span><br><span class="line">@synthesize suit &#x3D; _suit;</span><br><span class="line">&#x2F;&#x2F; 因为重构了suit的getter和setter，所以要手写@synthesize</span><br><span class="line">- (void)setSuit:(NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  if([@[@&quot;♥️&quot;,@&quot;♦️&quot;,@&quot;♠️&quot;,@&quot;♣️&quot;] containsObject:suit]) &#123;</span><br><span class="line">    _suit &#x3D; suit;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  return _suit?_suit:@&quot;?&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>值得注意的是，<code>setSuit</code>中的第一个<code>@</code>表示创建新的数组，在这里，每次判断都会新建这个数组。为了性能和代码简介，可以新建函数来判断setter收到的suit是否有效。实际上，这种改变对性能的提升是极其有限的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  NSArray *rankStrings &#x3D; @[@&quot;?&quot;,@&quot;A&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;10&quot;,@&quot;J&quot;,@&quot;Q&quot;,@&quot;K&quot;];</span><br><span class="line">  &#x2F;&#x2F; 将0-13表示为?,1,2,...,J,Q,K</span><br><span class="line">  return [rankStrings[self.rank] stringByAppendingString:self.suit];</span><br><span class="line">&#125;</span><br><span class="line">@synthesize suit &#x3D; _suit;</span><br><span class="line">&#x2F;&#x2F; 因为重构了suit的getter和setter，所以要手写@synthesize</span><br><span class="line"></span><br><span class="line">+ (NSArray *)validSuits</span><br><span class="line">&#123;</span><br><span class="line">  return @[@&quot;♥️&quot;,@&quot;♦️&quot;,@&quot;♠️&quot;,@&quot;♣️&quot;];</span><br><span class="line">&#125;</span><br><span class="line">- (void)setSuit:(NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  if([[PlayingCard validSuits] containsObject:suit]) &#123;</span><br><span class="line">    &#x2F;&#x2F; 类的函数的调用方法。</span><br><span class="line">    _suit &#x3D; suit;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  return _suit?_suit:@&quot;?&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>这里在函数实现前面第一次出现了<code>+</code>符号，这个符号表示这个函数是<strong>类的函数</strong>（而不是对象的函数）。</p>
<p><strong><em>一般只在两种情况下使用类的函数：</em></strong></p>
<ol>
<li><p>工具函数（utility method），比如这里的<code>validSuits</code>。</p>
</li>
<li><p>创建类的函数，比如<code>stringWithFormat</code>。</p>
<p>对rank属性做同样的检查和优化，并添加一个公开API<code>maxRank</code>返回rank的最大值，比如现在是13。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.h</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line">@interface PlayingCard : Card</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) NSString *suit;</span><br><span class="line">@property (nonatomic) NSUInteger rank;</span><br><span class="line"></span><br><span class="line">+ (NSArray *)validSuits;</span><br><span class="line">+ (NSUInteger)maxRank;</span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCard.m</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line">@implementation PlayingCard</span><br><span class="line">- (NSString *)contents</span><br><span class="line">&#123;</span><br><span class="line">  NSArray *rankStrings &#x3D; [PlayingCard rankStrings];</span><br><span class="line">  &#x2F;&#x2F; 将0-13表示为?,1,2,...,J,Q,K</span><br><span class="line">  return [rankStrings[self.rank] stringByAppendingString:self.suit];</span><br><span class="line">&#125;</span><br><span class="line">@synthesize suit &#x3D; _suit;</span><br><span class="line">&#x2F;&#x2F; 因为重构了suit的getter和setter，所以要手写@synthesize</span><br><span class="line"></span><br><span class="line">+ (NSArray *)validSuits</span><br><span class="line">&#123;</span><br><span class="line">  return @[@&quot;♥️&quot;,@&quot;♦️&quot;,@&quot;♠️&quot;,@&quot;♣️&quot;];</span><br><span class="line">&#125;</span><br><span class="line">- (void)setSuit:(NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  if([[PlayingCard validSuits] containsObject:suit]) &#123;</span><br><span class="line">    &#x2F;&#x2F; 类的函数的调用方法。</span><br><span class="line">    _suit &#x3D; suit;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)suit</span><br><span class="line">&#123;</span><br><span class="line">  return _suit?_suit:@&quot;?&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSArray *)rankStrings</span><br><span class="line">&#123;</span><br><span class="line">  return @[@&quot;?&quot;,@&quot;A&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;10&quot;,@&quot;J&quot;,@&quot;Q&quot;,@&quot;K&quot;];</span><br><span class="line">&#125;</span><br><span class="line">+ (NSUInteger)maxRank</span><br><span class="line">&#123;</span><br><span class="line">  return [[self rankStrings] count]-1;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setRank:(NSUInteger)rank</span><br><span class="line">&#123;</span><br><span class="line">  if(rank &lt;&#x3D; [PlayingCard maxRank]) &#123;</span><br><span class="line">    _rank &#x3D; rank;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="PlayingCardDeck类"><a href="#PlayingCardDeck类" class="headerlink" title="PlayingCardDeck类"></a>PlayingCardDeck类</h2><p>接下来可以开始玩牌了，创建一个新的类<code>PlayingCardDeck</code>，继承自<code>Deck</code>类，但是需要<strong>重写构造函数</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCardDeck.h</span><br><span class="line">#import &quot;Deck.h&quot;</span><br><span class="line"></span><br><span class="line">@interface PlayingCardDeck : Deck</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PlayingCardDeck.m</span><br><span class="line">#import &quot;PlayingCardDeck.h&quot;</span><br><span class="line">#import &quot;PlayingCard.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation PlayingCardDeck</span><br><span class="line">- (instancetype)init &#x2F;&#x2F; instancetype类只在init中使用</span><br><span class="line">&#123;</span><br><span class="line">  self &#x3D; [super init];</span><br><span class="line">  &#x2F;&#x2F; 调用父类的构造函数</span><br><span class="line">  if(self) &#123; </span><br><span class="line">    &#x2F;&#x2F; 父类正常完成构造，继续子类的构造函数</span><br><span class="line">    &#x2F;&#x2F; 如果父类无法完成构造，将不执行子类的构造代码</span><br><span class="line">    for (NSString *suit in [PlayingCard validSuits]) &#123;</span><br><span class="line">      for (NSUInteger rank &#x3D; 1; rank &lt;&#x3D; [PlayingCard maxRank]; rank++) &#123;</span><br><span class="line">        PlayingCard *card &#x3D; [[PlayingCard allo] init];</span><br><span class="line">        card.rank &#x3D; rank;</span><br><span class="line">        card.suit &#x3D; suit;</span><br><span class="line">        [self addCard:card];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="XCode的简单使用"><a href="#XCode的简单使用" class="headerlink" title="XCode的简单使用"></a>XCode的简单使用</h2><p>课程剩余的部分就是以纸牌游戏为例，简单介绍XCode的使用，开发一个简单的App，App内容是显示纸牌，点击纸牌将其翻转。</p>
<p>由于课程介绍的是XCode 5，笔者记笔记的时候已经是XCode 12.4了，有了不小的变化，参考笔者另一篇笔记（<a href="https://zhang-tianxu.github.io/chinese/2021/03/09/Objective-C-IOS%E5%BC%80%E5%8F%91%E4%B9%8BHelloWorld/">Objective-C IOS开发之HelloWorld</a>），应该也不难完成，就不再具体介绍实现了。</p>
<p>相较于HelloWorld这个App，课程中实现的App另外涉及了以下知识点：</p>
<ul>
<li><p>图像添加</p>
<p>直接将图片拖到<code>Assets.xcassets</code>文件夹中</p>
</li>
<li><p>button背景图片的设置</p>
<p>点击button，在属性中点击<code>Background</code>下拉菜单，就会显示上一步添加的图片选项，以及一些原始icon。</p>
</li>
<li><p>Action中的sender其实就是触发事件的View对象</p>
</li>
<li><p>类的添加</p>
<p>添加类的方法，XCode 12中其实就是新建<code>Cocoa Touch Class</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福大学IOS7开发课程1</title>
    <url>/chinese/2021/03/15/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6IOS7%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B1/</url>
    <content><![CDATA[<h1 id="斯坦福大学IOS7开发课程1"><a href="#斯坦福大学IOS7开发课程1" class="headerlink" title="斯坦福大学IOS7开发课程1"></a>斯坦福大学IOS7开发课程1</h1><p>IOS7开发课程讲了如何利用Objective-C语言开发IOS App，而且涉及到很多必须的基础知识，非常值得学习。</p>
<p>课程1讲了一些关于课程安排和作业的事情，自学就不需要了，只选取下面三个<strong>知识点：</strong></p>
<ul>
<li>IOS里有什么</li>
<li>MVC开发模型</li>
<li>Objective-C</li>
</ul>
<a id="more"></a>

<h2 id="IOS里有什么"><a href="#IOS里有什么" class="headerlink" title="IOS里有什么"></a>IOS里有什么</h2><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gok87jp5hnj20lq15ctky.jpg" class="inIOS" width="300" height="700" title="IOS里有什么" alt="加载失败">

<p>总的来说，可以将IOS涉及的组件分为4组或者说4层：</p>
<ul>
<li><p>Core OS</p>
<p>最接近硬件的一层，其实就是Unix操作系统，Unix内核中有的功能，Core OS都有，比如：</p>
<ul>
<li>OSX Kernel</li>
<li>Power Management</li>
<li>Sockets</li>
<li>File System</li>
</ul>
<p>等等……</p>
</li>
<li><p>Core Services</p>
<p>基于Core OS的面向对象层。</p>
<p>Core OS层的API几乎都是用C写的，为了以<em>面向对象</em>的方式编程，加入了Core Services层。这一层包括：</p>
<ul>
<li>Collections</li>
<li>File Access</li>
<li>Networking</li>
<li>Threading</li>
<li>SQLite</li>
<li>Core Location</li>
</ul>
<p>等等</p>
</li>
<li><p>Media</p>
<p>用于展现多媒体，包括视频、图片、声音、文件等等，是非常重要的一层。</p>
</li>
<li><p>Cocoa Touch</p>
<p>Cocoa的API起源于Mac OS X，已经有三十年左右的历史了，是UI层。对IOS开发者来说是需要花比较多时间来学习的一层。这一层可以用来构建按键、滑块、开关、文字输入、动画等等。包括：</p>
<ul>
<li>Multi-Touch</li>
<li>Alerts</li>
<li>Web View</li>
<li>Camera</li>
<li>Controls</li>
</ul>
<p>等等。</p>
</li>
</ul>
<h2 id="MVC开发模型"><a href="#MVC开发模型" class="headerlink" title="MVC开发模型"></a>MVC开发模型</h2><p>Model View Controller是一种用于组织应用程序中所有类的策略，将每个类分成Model 阵营、Controller 阵营或者View 阵营中的额一个。</p>
<p>Model用来描述你的程序是什么，以纸牌游戏为例，纸牌、牌桌甚至玩牌的规则都是独立于UI的，应该放在Model阵营中。至于纸牌是如何展示在屏幕上的，是由Controller负责的，Controller负责如何展现Model，以及展现Model的动画等。View是Controller的下属，是Controller用于构建UI的组件。</p>
<p>View是通用的，比如按键、开关等，是所有程序通用的，而Contrller是针对程序设计的，Model则是完全独立于UI的。</p>
<h3 id="MVC模型中三个阵营之间的通信"><a href="#MVC模型中三个阵营之间的通信" class="headerlink" title="MVC模型中三个阵营之间的通信"></a>MVC模型中三个阵营之间的通信</h3><h4 id="Controller-gt-Model"><a href="#Controller-gt-Model" class="headerlink" title="Controller -&gt; Model"></a>Controller -&gt; Model</h4><p>  Controller了解Model的一切，并且可以任意给Model发消息。</p>
<h4 id="Controller-gt-View"><a href="#Controller-gt-View" class="headerlink" title="Controller -&gt; View"></a>Controller -&gt; View</h4><p>  Controller也可以任意给View发送消息，如果Controller有个property指向View，把这个property成为<strong><em>outlet</em></strong>。</p>
<h4 id="Model-lt-gt-View"><a href="#Model-lt-gt-View" class="headerlink" title="Model &lt;-&gt; View"></a>Model &lt;-&gt; View</h4><p>  永远<strong>不要</strong>让Model和View之间直接通信。因为Model应该是完全独立于UI的，所以不应该给View发消息，而View是通用的，所以也不应该发消息给Model。</p>
<h4 id="View-gt-Controller"><a href="#View-gt-Controller" class="headerlink" title="View -&gt; Controller"></a>View -&gt; Controller</h4><p>View能向Controller发消息么？可以是可以，但是因为View是通用的，它对Controller并不了解，所以他们只能通过约定好的形式向Controller发送消息，有两种方式：</p>
<ul>
<li><p>target action</p>
<p>Controller在内部建立一个target，并给View一个action。当View执行一些操作，比如按键被按下的时候，view会向Controller内的target发射action，这种方式下，View可以不了解Controller，只需要知道某些操作被执行时向Controller发送action。</p>
</li>
<li><p>delegate</p>
<p>target action方式没办法处理非常复杂的通信。比如在一个滚动框中，用户按下手指准备滚动，需要让Controller知道用户要滚动了。因为是否允许用户的滚动请求，View是不知道的，所以需要让Controller代理其执行。有一种特殊的delegate，称为data source。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gok7sf8e9mj20xm0jadhu.jpg" alt="image-20210314123540992"></p>
</li>
</ul>
<p>View并不拥有它们展示的数据</p>
<h4 id="Model-gt-Controller"><a href="#Model-gt-Controller" class="headerlink" title="Model -&gt; Controller"></a>Model -&gt; Controller</h4><p>那么model能向Controller发送消息么？</p>
<p>model应该是完全独立于UI的，所以不能直接向Controller发送消息。但有的时候确实有这样的需求，比如Model中数据变化了，需要告诉Controller，这时可以通过广播的方式，向所有感兴趣的人发送消息，其中当然可以包括Controller</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gok7tedpf9j20wc0jstw6.jpg" alt="image-20210314123951433"></p>
<h3 id="MVCs模型"><a href="#MVCs模型" class="headerlink" title="MVCs模型"></a>MVCs模型</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gok7tphhwkj211q0mg4qp.jpg" alt="image-20210314124445333"></p>
<h2 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C"></a>Objective-C</h2><p>Objective-C的一些基础语法可以到<a href="https://www.yiibai.com/objective_c/" target="_blank" rel="noopener">易百Objective-C教程</a>学习，本课程中只是讲了一些和C/C++等语言不通的地方。和常见的编程语言C++或java相比，Objective-C有个重要的概念“Properties”，在Objective-C中一般不直接读写实例的变量，properties是Objective-C中读写实例的变量的方法，一般由getter函数和setter函数组成。</p>
<p>在Objective-C中，每个类由一个<code>.h</code>头文件的头文件和一个<code>.m</code>的实现文件。其中，<code>.h</code>中是公开的API，<code>.m</code>中是私密API和具体的实现。</p>
<p>在<code>.h</code>中声明类时，必须给定类的父类，其中<code>NSObject</code>是几乎所有类的父类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.h</span><br><span class="line">@interface Test: NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>由于使用了<code>NSObject</code>作为父类，所以需要引入这个类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.h</span><br><span class="line">#import &lt;Foundation&#x2F;NSObject.h&gt;</span><br><span class="line">@interface Test: NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在IOS中一般不会只引进这个类，而是将整个<code>Foundation</code>框架引进来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">@interface Test: NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在<code>.m</code>实现文件中当然要引入头文件，<code>@implementation</code>表示类的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.m</span><br><span class="line">#import &quot;Test.h&quot;</span><br><span class="line">@implementation Test</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>同时<code>.m</code>中可以添加一些私密API</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.m</span><br><span class="line">#import &quot;Test.h&quot;</span><br><span class="line">@interface Test()&#x2F;&#x2F;添加私密API</span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">@implementation Test</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>下面介绍Objective-C的Properties概念，通过<code>@property</code>在<code>.h</code>中添加一个属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">@interface Test: NSObject</span><br><span class="line">  @property (strong nonatomic) NSString *name;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>下面详细说一下<code>property</code>这行代码的构成：</p>
<p><strong>首先</strong>是关键字<code>(strong)</code>。在Objective-C中，所有的对象都被放在堆中，通过指针使用它们。通过这种方式，Objective-C不需要编程人员手动分配和释放内存地址，那么Objective-C如何知道何时释放内存呢？这就是属性声明中<code>(stong)</code>的作用，相应的还有<code>(weak)</code>。在内存管理时，只要有任意一个<code>strong</code>指针指向内存，内存就会被保留，最有一个<code>strong</code>指针被删除时，该地址会<strong>立即</strong>被回收，此时如果还有<code>weak</code>指针指向改地址，<code>weak</code>指针会被置为空。</p>
<p>对于元类型（int、bool等）的属性，不需要声明<code>strong</code>或<code>weak</code>，因为这种类型的属性并不存储在堆中，不需要内存管理。</p>
<p>与其他语言不通，在Objective-C中，引用空指针并不会导致程序崩溃，在Objective-C中你甚至可以给空指针发送数据，也不会导致程序崩溃，当然你给空指针发数据，虽然不会导致程序崩溃，也不会执行任何代码，如果发送的消息需要返回，返回值会被设为0。</p>
<p><strong>然后</strong>是关键字<code>nonatomic</code>，非原子操作。这个关键字的意思是属性的getter和setter<strong>不是线程安全的</strong>，在IOS中一般并不需要属性是线程安全的。在声明属性的同时，Objective-C会自动创建getter和setter方法。如果添加了<code>nonatomic</code>关键字，自动生成的代码是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@synthesize name &#x3D; _name;</span><br><span class="line">- (NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">  return _name;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">  _name &#x3D; name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>@synthesize</code>表示<code>_name</code>是<code>name</code>的别名。这些代码并不会显示出来，但可以直接使用。使用setter和getter的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myTest.name &#x3D; @&quot;Hello World&quot;;</span><br><span class="line">NSLog(@&quot;%@&quot;,myTest.name);</span><br></pre></td></tr></table></figure>

<p>当然也可以用中括号的方式调用，但建议使用上面的方式调用setter和getter。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[myTest setName:@&quot;Hello World&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[myTest name]);</span><br></pre></td></tr></table></figure>

<p>如果不添加<code>nonatomic</code>关键字，自动生成的代码会复杂很多，因为需要添加锁。为了简单，一般都会加上<code>nonatomic</code>关键字。</p>
<p><strong>另外</strong>，如果想要重命名属性的getter和setter，可以通过一下方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, getter &#x3D; getName, setter &#x3D; setName) NSString name;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C IOS开发之SQLite数据库</title>
    <url>/chinese/2021/03/10/Objective-C-IOS%E5%BC%80%E5%8F%91%E4%B9%8BSQLite%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>IDE: XCode Version 12.4 (12D4e)</p>
<p>参考<a href="https://www.tutorialspoint.com/ios/ios_sqlite_database.htm" target="_blank" rel="noopener">IOS开发教程</a></p>
<h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><a id="more"></a>

<ol>
<li><p>Xcode创建一个APP</p>
</li>
<li><p>选中项目文件，选中TARGETS，然后在框架（frameworks, Libraries, and Embedded Content）中添加<strong>libsqlite3.tbd</strong>（libsqlite3.0.tbd也一样）</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof54maa10j314p0u0af4.jpg" class="addSQLiteLibImg" width="500" height="600" title="添加SQLite库" alt="加载失败">
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof54tkttyj30ng0qon0f.jpg" class="addSQLiteLibImg2" width="500" height="300" title="添加SQLite库2" alt="加载失败">
</li>
<li><p>新建Objective-C类（File-&gt;New-&gt;File）选择Cocoa Touch Class，点击Next，Subclass of选择NSObject，language选Objective-C。</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof56z2pxuj30u00xm4ee.jpg" class="addObjcClassImg" width="800" height="300" title="添加Objective-C类" alt="加载失败">
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof57eshyqj315i0te0y6.jpg" class="addObjcClassImg2" width="400" height="300" title="添加Objective-C类2" alt="加载失败">
</li>
<li><p>将类的名字命名为DBManager，点击Next创建</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof57v7yg2j31600u0gpo.jpg" class="addDBManager" width="400" height="300" title="创建DBManager" alt="加载失败">
</li>
<li><p>项目中会增加<code>DBManager.h</code>和<code>DBManager.m</code>两个文件，其代码是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;DBManager.h</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#import &lt;sqlite3.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface DBManager : NSObject &#123;</span><br><span class="line">    NSString *databasePath;</span><br><span class="line">&#125;</span><br><span class="line">+(DBManager*)getSharedInstance;</span><br><span class="line">-(BOOL)createDB;</span><br><span class="line">-(BOOL) saveData:(NSString*)registerNumber name:(NSString*)name department:(NSString*)department year:(NSString*)year;</span><br><span class="line">-(NSArray*) findByRegisterNumber:(NSString*)registerNumber;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;DBManager.m</span><br><span class="line"></span><br><span class="line">#import &quot;DBManager.h&quot;</span><br><span class="line"></span><br><span class="line">static DBManager *sharedInstance &#x3D; nil;</span><br><span class="line">static sqlite3 *database &#x3D; nil;</span><br><span class="line">static sqlite3_stmt *statement&#x3D; nil;</span><br><span class="line"></span><br><span class="line">@implementation DBManager</span><br><span class="line"></span><br><span class="line">+(DBManager*)getSharedInstance&#123;</span><br><span class="line">    if(!sharedInstance) &#123;</span><br><span class="line">        sharedInstance &#x3D; [[super allocWithZone:NULL]init];</span><br><span class="line">        [sharedInstance createDB];</span><br><span class="line">    &#125;</span><br><span class="line">    return sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(BOOL)createDB &#123;</span><br><span class="line">    NSString *docsDir;</span><br><span class="line">    NSArray *dirPaths;</span><br><span class="line">    &#x2F;&#x2F; get the documents directory</span><br><span class="line">    dirPaths &#x3D; NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">    docsDir &#x3D; dirPaths[0];</span><br><span class="line">    &#x2F;&#x2F; build the path to the database file</span><br><span class="line">    databasePath &#x3D; [[NSString alloc] initWithString:[docsDir stringByAppendingPathComponent:@&quot;student.db&quot;]];</span><br><span class="line">    BOOL isSuccess &#x3D; YES;</span><br><span class="line">    NSFileManager* filemgr &#x3D; [NSFileManager defaultManager];</span><br><span class="line">    </span><br><span class="line">    if([filemgr fileExistsAtPath:databasePath] !&#x3D; NO) &#123;</span><br><span class="line">        const char *dbpath &#x3D; [databasePath UTF8String];</span><br><span class="line">        if(sqlite3_open(dbpath, &amp;database) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">            char *errMsg;</span><br><span class="line">            const char *sql_stmt &#x3D;</span><br><span class="line">            &quot;create table if not exists studentsDetail (regno integer primary key, name text, department text, year text)&quot;;</span><br><span class="line">            if(sqlite3_exec(database, sql_stmt, NULL, NULL, &amp;errMsg) !&#x3D; SQLITE_OK) &#123;</span><br><span class="line">                isSuccess &#x3D; NO;</span><br><span class="line">                NSLog(@&quot;Fail to create table&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sqlite3_close(database);</span><br><span class="line">            return isSuccess;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            isSuccess &#x3D; NO;</span><br><span class="line">            NSLog(@&quot;Fail to open&#x2F;create database&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return isSuccess;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(BOOL)saveData:(NSString *)registerNumber name:(NSString *)name department:(NSString *)department year:(NSString *)year; &#123;</span><br><span class="line">    const char *dbpath &#x3D; [databasePath UTF8String];</span><br><span class="line">    </span><br><span class="line">    if(sqlite3_open(dbpath, &amp;database) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">        NSString *insertSQL &#x3D; [NSString stringWithFormat:@&quot;insert into studentsDetail (regno, name, department, year) values (\&quot;%ld\&quot;,\&quot;%@\&quot;,\&quot;%@\&quot;,\&quot;%@\&quot;)&quot;,(long)[registerNumber integerValue], name, department, year];</span><br><span class="line">        const char *insert_stmt &#x3D; [insertSQL UTF8String];</span><br><span class="line">        if(sqlite3_prepare_v2(database, insert_stmt, -1, &amp;statement, NULL) !&#x3D; SQLITE_OK) &#123;</span><br><span class="line">            NSLog(@&quot;Prepare failure:%s&quot;,sqlite3_errmsg(database));</span><br><span class="line">        &#125;</span><br><span class="line">        if(sqlite3_step(statement) &#x3D;&#x3D; SQLITE_DONE) &#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    sqlite3_reset(statement);</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSArray*)findByRegisterNumber:(NSString *)registerNumber&#123;</span><br><span class="line">    const char *dbpath &#x3D; [databasePath UTF8String];</span><br><span class="line">    if(sqlite3_open(dbpath, &amp;database) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">        NSString *querySQL &#x3D; [NSString stringWithFormat:@&quot;select name, department, year from studentsDetail where regno &#x3D; \&quot;%@\&quot;&quot;,registerNumber];</span><br><span class="line">        const char *query_stmt &#x3D; [querySQL UTF8String];</span><br><span class="line">        NSMutableArray *resultArray &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">        if(sqlite3_prepare_v2(database, query_stmt, -1, &amp;statement, NULL) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">            if(sqlite3_step(statement) &#x3D;&#x3D; SQLITE_ROW) &#123;</span><br><span class="line">                NSString *name &#x3D; [[NSString alloc] initWithUTF8String:(const char *)sqlite3_column_text(statement, 0)];</span><br><span class="line">                [resultArray addObject:name];</span><br><span class="line">                </span><br><span class="line">                NSString *department &#x3D; [[NSString alloc] initWithUTF8String:(const char*)sqlite3_column_text(statement, 1)];</span><br><span class="line">                [resultArray addObject:department];</span><br><span class="line">                </span><br><span class="line">                NSString *year &#x3D; [[NSString alloc] initWithUTF8String:(const char*)sqlite3_column_text(statement, 2)];</span><br><span class="line">                [resultArray addObject:year];</span><br><span class="line">                return resultArray;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                NSLog(@&quot;Not found&quot;);</span><br><span class="line">                return nil;</span><br><span class="line">            &#125;</span><br><span class="line">            sqlite3_reset(statement);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>Main.storyboard</code>中添加如下组件：</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gof3hvfqacj30ga0gsgma.jpg" class="result" width="800" height="300" title="效果" alt="加载失败">
</li>
<li><p>为所有的输入框新建<code>Referencing Outlet</code></p>
</li>
<li><p>为两个button创建<code>Touch Up Inside</code>事件</p>
</li>
<li><p>创建完之后，<code>ViewController.h</code>自动被填写为:</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line">#import &quot;DBManager.h&quot;&#x2F;&#x2F;这个是手动添加的</span><br><span class="line"></span><br><span class="line">@interface ViewController : UIViewController</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *findByRegisterNumberTextField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *regNoTextField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *nameTextField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *departmentTextField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *yearTextField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UIScrollView *myScrollView;</span><br><span class="line"></span><br><span class="line">- (IBAction)findData:(id)sender;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UIButton *saveData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>ViewController.m</code>中实现<code>findData</code>和<code>saveData</code></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  ViewController.m</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)saveData:(id)sender &#123;</span><br><span class="line">    BOOL success &#x3D; NO;</span><br><span class="line">    NSString *alertString &#x3D; @&quot;Data Insertion failed&quot;;</span><br><span class="line">    if(_regNoTextField.text.length &gt; 0 &amp;&amp; _nameTextField.text.length &gt; 0 &amp;&amp; _departmentTextField.text.length &gt; 0 &amp;&amp; _yearTextField.text.length &gt; 0) &#123;</span><br><span class="line">        success &#x3D; [[DBManager getSharedInstance] saveData:_regNoTextField.text name:_nameTextField.text department:_departmentTextField.text year:_yearTextField.text];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        alertString &#x3D; @&quot;Enter all fields&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if(success &#x3D;&#x3D; NO) &#123;</span><br><span class="line">        UIAlertController *alert &#x3D; [UIAlertController alertControllerWithTitle:alertString message:nil preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">        UIAlertAction *okAction &#x3D; [UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">            NSLog(@&quot;点击了OK&quot;);</span><br><span class="line">        &#125;];</span><br><span class="line">        [alert addAction:okAction];</span><br><span class="line">        [self presentViewController:alert animated:YES completion:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)findData:(id)sender &#123;</span><br><span class="line">    NSArray *data &#x3D; [[DBManager getSharedInstance] findByRegisterNumber:_findByRegisterNumberTextField.text];</span><br><span class="line">    if(data &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        UIAlertController *alert &#x3D; [UIAlertController alertControllerWithTitle:@&quot;Data not found&quot; message:nil preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">        UIAlertAction *okAction &#x3D; [UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        &#125;];</span><br><span class="line">        [alert addAction:okAction];</span><br><span class="line">        [self presentViewController:alert animated:YES completion:nil];</span><br><span class="line">        _regNoTextField.text &#x3D; @&quot;&quot;;</span><br><span class="line">        _nameTextField.text &#x3D;@&quot;&quot;;</span><br><span class="line">        _departmentTextField.text &#x3D; @&quot;&quot;;</span><br><span class="line">        _yearTextField.text &#x3D;@&quot;&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        _regNoTextField.text &#x3D; _findByRegisterNumberTextField.text;</span><br><span class="line">        _nameTextField.text &#x3D;[data objectAtIndex:0];</span><br><span class="line">        _departmentTextField.text &#x3D;[data objectAtIndex:1];;</span><br><span class="line">        _yearTextField.text &#x3D;[data objectAtIndex:2];;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mart - Text field delegate</span><br><span class="line">-(void)textFieldDidBeginEditing:(UITextField *)textField &#123;</span><br><span class="line">    [_myScrollView setFrame:CGRectMake(10,50,300,200)];</span><br><span class="line">    [_myScrollView setContentSize:CGSizeMake(300, 350)];</span><br><span class="line">&#125;</span><br><span class="line">-(void)textFieldDidEndEditing:(UITextField *)textField &#123;</span><br><span class="line">    [_myScrollView setFrame:CGRectMake(10, 50, 300, 350)];</span><br><span class="line">&#125;</span><br><span class="line">-(BOOL) textFieldShouldReturn:(UITextField *)textField &#123;</span><br><span class="line">    [textField resignFirstResponder];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>至此，可以通过save按钮保存数据，find按钮可以查找数据，并显示在各自输入框中</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li><p><code>libsqlite3.dylib</code>vs<code>libsqlite3.tbd</code>vs<code>libsqlite3.0.tbd</code></p>
<p><code>.tbd</code> 在Xcode7后替代了<code>.dylib</code> 。而<code>libsqlite3.tbd</code>只是<code>libsqlite3.0.tbd</code>的链接，也就是两者是一摸一样的，引入任意一个的效果都是一样的。</p>
</li>
<li><p>sqlite3的使用</p>
<ol>
<li><p>创建数据库</p>
<p>SQLite的数据库就是一个文件，创建数据库也就是创建一个文件。</p>
</li>
<li><p>打开数据库</p>
<p>打开数据库其实就是用<code>sqlite3_open</code>函数打开一个文件。</p>
</li>
<li><p>执行SQL命令</p>
<p>SQLite中执行SQL命令有两种方式：</p>
<ul>
<li><code>sqlite3_exec()</code></li>
<li><code>sqlite3_prepare_v2()</code>+<code>sqlite3_step()</code></li>
</ul>
<p>两者的区别可以看<a href="https://stackoverflow.com/questions/27383724/sqlite3-prepare-v2-sqlite3-exec" target="_blank" rel="noopener">stackoverflow</a>。</p>
</li>
</ol>
</li>
<li><p>弹出框的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIAlertController *alert &#x3D; [UIAlertController alertControllerWithTitle:@&quot;警告的Title&quot; message:@&quot;警告的消息&quot;</span><br><span class="line">                           preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line"></span><br><span class="line">UIAlertAction *okAction &#x3D; [UIAlertAction actionWithTitle:@&quot;OK&quot;</span><br><span class="line">                           style:UIAlertActionStyleDefault</span><br><span class="line">                           handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">                             NSLog(@&quot;点击了OK&quot;);</span><br><span class="line">                           &#125;];</span><br><span class="line">UIAlertAction *cancelAction &#x3D; [UIAlertAction actionWithTitle:@&quot;Cancel&quot;</span><br><span class="line">                               style:UIAlertActionStyleCancel</span><br><span class="line">                               handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">                                 NSLog(@&quot;点击了Cancel&quot;);</span><br><span class="line">                               &#125;];</span><br><span class="line">[alert addAction:okAction];</span><br><span class="line">[alertController addAction:cancelAction];</span><br><span class="line"></span><br><span class="line">[self presentViewController:alert animated:YES completion:nil];</span><br></pre></td></tr></table></figure>


</li>
</ol>
]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C IOS开发之HelloWorld</title>
    <url>/chinese/2021/03/09/Objective-C-IOS%E5%BC%80%E5%8F%91%E4%B9%8BHelloWorld/</url>
    <content><![CDATA[<p>IDE: XCode Version 12.4 (12D4e)</p>
<a id="more"></a>
<ol>
<li>新建App</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofu3u9dcoj314y0ten0w.jpg" alt="image-20210311120542111"></p>
<ol start="2">
<li>给项目命名为<code>HelloWorld</code>，Interface选择<code>Storyboard</code>，Language选择<code>Objective-C</code>。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofu4wmsj2j314u0t6424.jpg" alt="image-20210311120644241"></p>
<ol start="3">
<li>打开文件<code>Main.storyboard</code>，添加一个<code>Label</code>和<code>Button</code>组件。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofubs0rgnj31iw0u0e02.jpg" alt=""></li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofudvnpftj312u0u0tcs.jpg" alt="image-20210311121521358"></p>
<ol start="4">
<li>打开两个面板，一个显示<code>Main.storyboard</code>，另一个显示<code>ViewController.h</code><br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofugj8ui9j31iq0fsdk5.jpg" alt=""></li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofuiw4hgvj31hx0u07i1.jpg" alt=""></p>
<ol start="5">
<li><p>为Label新建<code>New Referencing Outlet</code>（右键点击Label，点击<code>New Referencing Outlet</code>后的点不松开，拖到<code>ViewController.h</code>中。将新的<code>Referencing Outlet</code>命名为<code>helloLabel</code>。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gofukdlay3j31gt0u0h9a.jpg" alt=""></p>
</li>
<li><p>为Button添加<code>Touch Up Inside</code>事件，将事件命名为<code>showHelloWorld</code>。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gog2epczyxj30wg0u0h1n.jpg" alt=""><br>这时，<code>ViewController.h</code>的代码变为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  ViewController.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController : UIViewController</span><br><span class="line"></span><br><span class="line">@property (weak, nonatomic) IBOutlet UILabel *helloLabel;</span><br><span class="line">- (IBAction)showHelloWorld:(id)sender;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>同时，<code>ViewController.m</code>中也自动添加了<code>- (IBAction)showHelloWorld(id)sender {}</code>函数，在其中添加<code>_helloLabel.text = @&quot;Hello World&quot;;</code></p>
</li>
</ol>
<p>至此，最简单的IOS App开发完成。</p>
]]></content>
      <categories>
        <category>客户端开发</category>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title>github pages + hexo + next + Travis CI实现免费个人博客</title>
    <url>/chinese/2021/03/08/github-pages-hexo-next-Travis-CI%E5%AE%9E%E7%8E%B0%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>是GitHub提供的静态网页托管工具，可以用来建立个人网页，也可以建立网页介绍某个项目。</p>
<p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>是一个博客框架，而<a href="https://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT</a>是Hexo的一个主题。</p>
<p>最后Travis CI是针对GitHub的一款持续集成工具，这里用来完成网站的自动化部署。</p>
<a id="more"></a>
<h1 id="GitHub-Pages设置"><a href="#GitHub-Pages设置" class="headerlink" title="GitHub Pages设置"></a>GitHub Pages设置</h1><p>GitHub Pages主页中有建站的简单教程，为了支持MarkDown撰写博客，选择使用博客框架Hexo，并选择一个比较流行的框架NexT。</p>
<p>在此基础上可以添加许多功能：</p>
<ol>
<li><p>置顶</p>
<ol>
<li>移除默认安装的插件<code>npm uninstall hexo-generator-index --save</code></li>
<li>安装新插件<code>npm install hexo-generator-index-pin-top --save</code></li>
<li>在需要置顶的文章头部<code>top: true</code>或<code>top:整数</code>，其中整数越大的文章越靠前</li>
<li>为置顶的文章添加置顶标签,在<code>/themes/next/layout/_macro/post.swig</code>文件的<code>&lt;div class=&quot;post-meta&quot;&gt;</code>下方，插入如下代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">&lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">&lt;font color&#x3D;7D26CD&gt;置顶&lt;&#x2F;font&gt;</span><br><span class="line">&lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>数学公式</p>
<ol>
<li>编辑<code>theme/next/_config.yml</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">enable:  true</span><br><span class="line">per_page: false</span><br><span class="line">cdn: &#x2F;&#x2F;cdn.bootcss.com&#x2F;mathjax&#x2F;2.7.1&#x2F;latest.js?config&#x3D;TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure></li>
<li>为了更好的性能，不选择在所有页面下支持数学公式。在需要支持matchjax的文章头部，添加<code>mathjax: true</code></li>
</ol>
</li>
<li><p>评论功能</p>
<ol>
<li>评论功能和阅读统计都可以使用LeanCloud</li>
<li>编辑<code>theme/next/_config.yml</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">    enable: true</span><br><span class="line">    appid:  xxxxxxxx</span><br><span class="line">    appkey:  yyyyyyyyyyy</span><br><span class="line">    notify: false # mail notifier , https:&#x2F;&#x2F;github.com&#x2F;xCss&#x2F;Valine&#x2F;wiki</span><br><span class="line">    verify: false # Verification code</span><br><span class="line">    placeholder: 评论 # comment box placeholder</span><br><span class="line">    avatar: mm # gravatar style</span><br><span class="line">    guest_info: nick,mail,link # custom comment header</span><br><span class="line">    pageSize: 10 # pagination size</span><br></pre></td></tr></table></figure>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocmlo8c9sj317k0o8myh.jpg" class="commentsImg" width="400" height="600" title="评论功能" alt="加载失败"></li>
</ol>
</li>
<li><p>阅读统计<br> <a href="https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">为NexT主题添加文章阅读量统计功能</a></p>
</li>
<li><p>字数统计</p>
<ol>
<li>编辑<code>theme/next/_config.yml</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_wordcount:</span><br><span class="line">item_text: true</span><br><span class="line">wordcount: true</span><br><span class="line">min2read: true</span><br><span class="line">totalcount: true</span><br><span class="line">separated_meta: true</span><br></pre></td></tr></table></figure></li>
<li>执行<code>npm install hexo-wordcount@2 --save</code>，安装需要的库<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocmhvhwsnj30cw01iwei.jpg" class="wordCountImg" width="200" height="30" title="字数统计" alt="加载失败"></li>
</ol>
</li>
<li><p>添加网易云播放器</p>
<ol>
<li>去网易云音乐找一首喜欢的歌。</li>
<li>点击“生成外链播放器”，复制HTML代码。</li>
<li>将HTML代码添加到<code>/themes/hexo-theme-next/layout/_macro/sidebar.swig</code>中<code>&lt;aside id=&quot;sidebar&quot; class=&quot;sidebar”&gt;</code>后面，并用<code>&lt;div&gt;</code>包裹。<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocm3k2n6uj30ia0lujua.jpg" class="musicImg" width="400" height="200" title="网易云音乐" alt="加载失败"></li>
</ol>
</li>
<li><p>将标签云改为彩色</p>
<ol>
<li>在<code>themes/next/layout/</code>中新建<code>tag-color.swig</code>文件，代码为： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">     var alltags &#x3D; document.getElementsByClassName(&#39;tag-cloud-tags&#39;);</span><br><span class="line">     var tags &#x3D; alltags[0].getElementsByTagName(&#39;a&#39;);</span><br><span class="line">     for (var i &#x3D; tags.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">       var r&#x3D;Math.floor(Math.random()*75+130);</span><br><span class="line">       var g&#x3D;Math.floor(Math.random()*75+100);</span><br><span class="line">       var b&#x3D;Math.floor(Math.random()*75+80);</span><br><span class="line">       tags[i].style.background &#x3D; &quot;rgb(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .tag-cloud-tags&#123;</span><br><span class="line">    &#x2F;*font-family: Helvetica, Tahoma, Arial;*&#x2F;</span><br><span class="line">    &#x2F;*font-weight: 100;*&#x2F;</span><br><span class="line">    text-align: center;</span><br><span class="line">    counter-reset: tags;</span><br><span class="line">  &#125;</span><br><span class="line">  .tag-cloud-tags a&#123;</span><br><span class="line">    border-radius: 6px;</span><br><span class="line">    padding-right: 5px;</span><br><span class="line">    padding-left: 5px;</span><br><span class="line">    margin: 8px 5px 0px 0px;</span><br><span class="line">  &#125;</span><br><span class="line">  .tag-cloud-tags a:before&#123;</span><br><span class="line">    content: &quot;?&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .tag-cloud-tags a:hover&#123;</span><br><span class="line">     box-shadow: 0px 5px 15px 0px rgba(0,0,0,.4);</span><br><span class="line">     transform: scale(1.1);</span><br><span class="line">     &#x2F;*box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);*&#x2F;</span><br><span class="line">     transition-duration: 0.15s;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></li>
<li>在<code>/themes/next/layout/page.swig</code>中引入<code>tag-color.swig</code>，即在<code>&lt;div class=&quot;tag-cloud&quot;&gt;</code>代码段下方添加<code>{ % include &#39;tag-color.swig&#39; % }</code></li>
<li>也可以将标签云直接加入主页，在<code>/themes/next/layout/index.swig</code>中的block content代码块中加入以下代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;tag-cloud&quot;&gt;</span><br><span class="line">	  &lt;div class&#x3D;&quot;tag-cloud-tags&quot; id&#x3D;&quot;tags&quot;&gt;</span><br><span class="line">		&#123;&#123; tagcloud(&#123;min_font: 16, max_font: 16, amount: 300, color: true, start_color: &#39;#fff&#39;, end_color: &#39;#fff&#39;&#125;) &#125;&#125;</span><br><span class="line">	  &lt;&#x2F;div&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;br&gt;</span><br><span class="line">	</span><br><span class="line">	&#123;% include &#39;tag-color.swig&#39; %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>展示近期文章</p>
<ol>
<li><p>修改<code>themes/next/layout/_macro/sidebar.swig</code> 。找到<code>theme.social</code>，在该板块后隔一行添加如下代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;# recent posts #&#125;</span><br><span class="line">&#123;% if theme.recent_posts %&#125;</span><br><span class="line">&lt;div class&#x3D;&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme.recent_posts_layout  &#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;links-of-blogroll-title&quot;&gt;</span><br><span class="line">        &lt;!-- modify icon to fire by szw --&gt;</span><br><span class="line">        &lt;i class&#x3D;&quot;fa fa-history fa-&#123;&#123; theme.recent_posts_icon | lower &#125;&#125;&quot; aria-hidden&#x3D;&quot;true&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">        &#123;&#123; theme.recent_posts_title &#125;&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;ul class&#x3D;&quot;links-of-blogroll-list&quot;&gt;</span><br><span class="line">        &#123;% set posts &#x3D; site.posts.sort(&#39;-date&#39;) %&#125;</span><br><span class="line">        &#123;% for post in posts.slice(&#39;0&#39;, &#39;5&#39;) %&#125;</span><br><span class="line">        &lt;li class&#x3D;&quot;recent_posts_li&quot;&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title&#x3D;&quot;&#123;&#123; post.title &#125;&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">         &lt;&#x2F;li&gt;</span><br><span class="line">         &#123;% endfor %&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编辑<code>themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">li.recent_posts_li &#123;</span><br><span class="line">    text-align: cengter;</span><br><span class="line">    display: block;</span><br><span class="line">    word-break: keep-all;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>themes/next/_config.yml</code>中添加下方代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 近期文章设置</span><br><span class="line">recent_posts_title: 近期文章</span><br><span class="line">recent_posts_layout: block</span><br><span class="line">recent_posts: true</span><br></pre></td></tr></table></figure>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocmksvxlvj30da0460su.jpg" class="rencentPostImg" width="200" height="100" title="近期文章" alt="加载失败">

</li>
</ol>
</li>
</ol>
<h1 id="Travis-CI自动部署GitHub-Pages"><a href="#Travis-CI自动部署GitHub-Pages" class="headerlink" title="Travis CI自动部署GitHub Pages"></a>Travis CI自动部署GitHub Pages</h1><p><a href="https://docs.travis-ci.com/user/deployment/pages/" target="_blank" rel="noopener">Travis官方教程</a><br>有了Travis CI，更换电脑时，不需要在本地配置完整的环境，可以直接修改md文件，push到github后，Travis CI会自动生成和部署，非常的方便。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo: false</span><br><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - 10 # use nodejs v10 LTS</span><br><span class="line">before_script: # 配置环境</span><br><span class="line">    - npm install hexo-generator-searchdb --save # 用于支持本地搜索功能</span><br><span class="line">    - npm uninstall hexo-generator-index --save </span><br><span class="line">    - npm install hexo-generator-index-pin-top --save # 这两行用于支持置顶功能</span><br><span class="line">    - npm install --save hexo-filter-flowchart # 用于支持markdown中的流程图功能</span><br><span class="line">    - npm install hexo-wordcount@2 --save #用于支持字数统计功能</span><br><span class="line">cache: npm</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - master # build master branch only</span><br><span class="line">script:</span><br><span class="line">  - hexo generate # generate static files</span><br><span class="line">deploy:</span><br><span class="line">  provider: pages</span><br><span class="line">  skip-cleanup: true</span><br><span class="line">  github-token: $GH_TOKEN</span><br><span class="line">  keep-history: true</span><br><span class="line">  on:</span><br><span class="line">    branch: master</span><br><span class="line">  local-dir: public</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">notifications:</span><br><span class="line">   email:</span><br><span class="line">     recipients:</span><br><span class="line">       - xxx@xxx.com</span><br><span class="line">         #-</span><br><span class="line">     on_success: never # default: change</span><br><span class="line">     #on_success: change # default: change</span><br><span class="line">     on_failure: always # default: always</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>自媒体</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
  <entry>
    <title>SGX的验证</title>
    <url>/chinese/2020/06/24/SGX%E7%9A%84%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<p>Intel SGX可以很好的保证enclave（安全区域）内代码和数据的隐私性和完整性。但是如果需要多个enclave合作的话，在合作之前需要确认对方时SGX enclave。这种验证机制并不简单，分为本地验证和远程验证两种，下面会分别介绍。SGX的验证机制有很多细节，这里不会涉及太多的细节，重在帮助大家理解SGX的验证机制，更好的理解SGX的安全性以及它可能存在的弱点。</p>
<a id="more"></a>

<h2 id="本地验证-Local-Attestation"><a href="#本地验证-Local-Attestation" class="headerlink" title="本地验证 Local Attestation"></a>本地验证 <em>Local Attestation</em></h2><p><strong>SGX的本地验证用于一个enclave（称之为被验证enclave）向同一机器上的另一个enclave（称之为目标enclave）证明它的身份。</strong></p>
<p>本地验证流程：</p>
<ol>
<li>被验证enclave调用<strong>EREPORT</strong>指令，，生成验证报告并发送给目标enclave</li>
<li>目标enclave收到验证报告后，判断验证报告是否可信</li>
</ol>
<p><strong>EREPORT</strong>产生的<strong>验证报告</strong>中包含以下信息：</p>
<ul>
<li><p><strong>MAC（Message Authentication Code）标签</strong></p>
<p>由MAC加密系统产生的标签。</p>
<blockquote>
<p>MAC加密系统：</p>
<p>发送者利用MAC算法读取对称密钥和一个变长的消息，产生一个定长的MAC标签。接受者只要提供原始消息、对称密钥和MAC标签，就可以验证消息的真实性。</p>
</blockquote>
</li>
<li><p>enclave当前的身份信息</p>
<ul>
<li>enclave的measurement</li>
<li>基于证书的身份信息（比如软件开发商的安全版本号等）</li>
</ul>
</li>
<li><p>SGX实现的安全版本号（CPUSVN）</p>
</li>
<li><p>enclave提供的64-byte（512-bit）的消息</p>
</li>
<li><p><strong>KEYID</strong></p>
<p>enclave初始化时产生的一个随机数。</p>
</li>
</ul>
<p>验证报告的详细内容如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg3hm2b6arj30ic10kgof.jpg" alt="image-20200624170332771"></p>
<p>目标enclave想要通过MAC标签验证消息是由SGX实现发出的，那么<strong>生成MAC标签的对称密钥只能SGX实现和目标enclave知道</strong>。被验证enclave是不可以知道这个对称密钥的，<strong>一旦这个对称密钥泄露，验证报告就可能被伪造</strong>。</p>
<p>这个对称密钥成为<em>Report Key</em>，由<strong>EGETKEY</strong>指令产生。<strong>EGETKEY</strong>指令生成密钥的依据包括：</p>
<ul>
<li>嵌入到处理器中的一个秘密</li>
<li>包括<strong>目标enclave</strong>的measurement在内的一些信息</li>
</ul>
<p>目标enclave可以自己生成相应的对称密钥，验证报告中的信息。</p>
<p>目标enclave可以确定验证报告中的MAC标签是由SGX实现生成的，原因有二：</p>
<ol>
<li><strong>EGETKEY</strong>生成密钥的算法和MAC加密系统的MAC算法都是保密的，只有SGX实现才能产生这个MAC标签</li>
<li>只有SGX实现可以读取内嵌在处理器中的秘密</li>
</ol>
<h2 id="远程验证-Remote-Attestation"><a href="#远程验证-Remote-Attestation" class="headerlink" title="远程验证 Remote Attestation"></a>远程验证 <em>Remote Attestation</em></h2><p>相比于本地验证，远程验证要更加复杂。在介绍远程验证前，先介绍将会涉及到的一些内容：</p>
<p>在生产的过程中，处理器中的一个叫做e-fuse存储器中烧有两个秘密，我们称这两个秘密为<em>Provisioning Secret</em>和<em>Seal Secret</em>。</p>
<p><em>Provisioning Secret</em>是intel的密钥生成工具产生的，处理器生产过程中与intel的密钥生成工具通信，获取<em>Provisioning Secret</em>。在烧入处理器e-fuse的同时也会被intel保存在数据库。</p>
<p><em>Seal Secret</em>是在处理器芯片中生成的，所以Intel不知道这个秘密是什么。<em>Seal Secret</em>存在的好处在于，即便攻击者攻破了intel的密钥生成工具，也没办法生成<strong>EGETKEY</strong>生成的密钥。<em>Seal Secret</em>只有被<strong>EGETKEY</strong>做为密钥生成依据时才可以被访问，而不会暴露给任何软件。</p>
<p>远程验证流程：</p>
<ol>
<li><p>被验证enclave利用<strong>EGETKEY</strong>指令生成<em>Provisioning Key</em>，生成<em>Provisioning Key</em>的依据包括：</p>
<ul>
<li><em>Provisioning Secret</em></li>
<li>enclave当前以证书为基础的身份信息</li>
<li>SGX实现的安全版本号</li>
</ul>
</li>
<li><p>被验证enclave利用<em>Provisioning Key</em>向intel的<em>Provisioning</em>服务证明自己是可信的。</p>
<p>上面提过，intel记录了<em>Provisioning Secret</em>，同时拥有生成密钥的算法。</p>
</li>
<li><p>通过验证后，intel的<em>Provisioning</em>服务会生成一个<em>Attestation Key</em>并返还给被验证enclave</p>
</li>
<li><p>被验证enclave再利用<strong>EGETKEY</strong>指令以<em>Seal Secret</em>等信息为依据生成<em>Provisioning Seal key</em>，用这个密钥加密<em>Attestation Key</em>后存入计算机内存或磁盘。</p>
</li>
<li><p><em>Quoting Enclave<em>通过*</em>EGETKEY*<em>获得</em>Provisioning Seal key<em>，从内存中读取并解密</em>Attestation Key</em></p>
</li>
<li><p>被验证enclave向同一机器上的一个成为<em>Quoting Enclave</em>的特殊enclave执行本地验证</p>
</li>
<li><p><em>Quoting Enclave</em>将收到的本地验证的验证报告中的MAC标签换成由<em>Attestation Key</em>产生的签名（一种intel的特殊签名机制）</p>
</li>
<li><p><em>Quoting Enclave</em>将远程验证报告发送给目标enclave</p>
</li>
</ol>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li>Costan, Victor, Ilia Lebedev, and Srinivas Devadas. “Secure processors part I: background, taxonomy for secure enclaves and Intel SGX architecture.” <em>Foundations and Trends in Electronic Design Automation</em> 11.1-2 (2017): 1-248.</li>
</ol>
]]></content>
      <categories>
        <category>安全</category>
        <category>可信执行环境</category>
      </categories>
      <tags>
        <tag>SGX</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语：如何说的更快（二）</title>
    <url>/chinese/2020/04/14/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AF%B4%E7%9A%84%E6%9B%B4%E5%BF%AB%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>内容参考<a href="https://youtu.be/5wr44LGmIaw" target="_blank" rel="noopener">How to speak English fast and understand natives (Part II)</a> From <a href="https://www.youtube.com/channel/UCAQg09FkoobmLquNNoO4ulg" target="_blank" rel="noopener">linguamarina</a></p>
<p>要点：</p>
<ul>
<li>口语中的简化：<ul>
<li>Want to -&gt; wanna</li>
<li>Going to -&gt; gonna</li>
<li>Don’t know -&gt; dunno know</li>
<li>got to -&gt; gotta</li>
</ul>
</li>
<li>忽略无意义词句</li>
<li>使用缩写</li>
<li>重音、俚语和习语<a id="more"></a>

</li>
</ul>
<h2 id="口语中的简化："><a href="#口语中的简化：" class="headerlink" title="口语中的简化："></a>口语中的简化：</h2><ol>
<li>Want to会连读称wanna，比如<br>I want to go to london -&gt;I wanna go to london<br>I want to study in the US -&gt; I wanna study in the US</li>
<li>going to读成 gonna<br>I’m going to wash the car -&gt;I’m gonna wash the car</li>
<li>don’t know读成dunno know<br>I don’t know -&gt; I dunno know</li>
<li>got to 读成 gotta<br>I got to do my homework -&gt; I gotta do my homework</li>
</ol>
<h2 id="忽略口语中的一些无意义词句（fillers），比如："><a href="#忽略口语中的一些无意义词句（fillers），比如：" class="headerlink" title="忽略口语中的一些无意义词句（fillers），比如："></a>忽略口语中的一些无意义词句（fillers），比如：</h2><ol>
<li>actually</li>
<li>anyway</li>
<li>basically</li>
<li>By the way</li>
<li>Erm（象声词）</li>
</ol>
<p>当然反过来我们说的时候也可以插入一些这些句子，给自己多些时间思考</p>
<ol>
<li>I mean</li>
<li>incidentally</li>
<li>in fact</li>
<li>obviously</li>
<li>well</li>
<li>you know</li>
</ol>
<p>比如下面这个句子，去掉斜体字对意思是没有影响的：</p>
<p><em>By the way</em>, I saw Mark yesterday. <em>Erm, so obviously</em> I said ‘hello’ to him but he <em>basically</em> ignored me!</p>
<h2 id="使用缩写"><a href="#使用缩写" class="headerlink" title="使用缩写"></a>使用缩写</h2><table>
<thead>
<tr>
<th align="center">缩写规则</th>
<th>例句</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td align="center">I am -&gt; I’m</td>
<td>I am hungry -&gt; I’m hungry</td>
<td>无</td>
</tr>
<tr>
<td align="center">I will -&gt; I’ll</td>
<td>I will do that -&gt; I’ll do that<br />I will pick it up -&gt; I’ll pick it up</td>
<td>缩写不能用在人名后面<br />Kate will do that $\ne $  Kate’ll do that</td>
</tr>
<tr>
<td align="center">do not = don’t</td>
<td>I do not like it =&gt; I don’t like it</td>
<td></td>
</tr>
<tr>
<td align="center">I have =&gt; I’ve</td>
<td>I have got your back -&gt; I’ve got your back<br />I have done this befor -&gt; I’ve done this before</td>
<td></td>
</tr>
<tr>
<td align="center">I would =&gt; I’d</td>
<td>I would like to join you =&gt; I’d like to join you<br />I would like to stay home -&gt; I’d like to stay home</td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>另外在口语中注意一些几点可以提升听力：</p>
<ul>
<li>在注意口语中的重音能帮助理解口语</li>
<li>学习俚语</li>
<li>学习英语习语</li>
</ul>
]]></content>
      <categories>
        <category>语言</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>English</tag>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语：如何说的更快</title>
    <url>/chinese/2020/04/13/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AF%B4%E7%9A%84%E6%9B%B4%E5%BF%AB/</url>
    <content><![CDATA[<p><img src="https://i.ytimg.com/vi/MiebCHmiszs/hqdefault.jpg?sqp=-oaymwEZCNACELwBSFXyq4qpAwsIARUAAIhCGAFwAQ==&rs=AOn4CLAqpOOb7VavDJ4Reu3nzoseweLxcw" alt="封面"></p>
<p>内容参考<a href="https://youtu.be/MiebCHmiszs" target="_blank" rel="noopener">How to speak English fast and understand natives (Part I)</a> From <a href="https://www.youtube.com/channel/UCAQg09FkoobmLquNNoO4ulg" target="_blank" rel="noopener">linguamarina</a></p>
<p>要点：</p>
<ul>
<li>我们感觉English Native Speaker说得快，所以听上去很地道。但实际上他们不是说得快，而是把单词连起来了。</li>
<li>the 读成 duh</li>
<li>you 读成 yuh</li>
<li>以t结尾的单词后接以d开头的单词时，两者字母连读为chu。</li>
<li>Something读成Sumpthin</li>
<li>字母t出现在单词中间时，有时需要读成d</li>
</ul>
<a id="more"></a>
<p>对于句式What do you …，比如What do you do?美国人不会一个单词一个单词的读，而是读成Whudduhyuh do?句式I’m going to …，比如I’m going to do some shopping，美国人会读成I’m gonna do some shopping。甚至有人进一步简化为Ahmma do shopping。这样是为了让平时说话时更容易，更流畅。</p>
<p><strong>the 读成 duh</strong><br>比如句子：<br>What’s the weather today?<br>美国人会读成：<br>What’s duh weather today?<br><strong>you 读成 yuh</strong><br>比如句子：<br>Do you want to go?<br>会被读成：<br>Do yuh wanna go?<br><strong>t结尾的单词后接d开头的单词</strong><br>比如<br>What do you do?<br>会被读成<br>Whutchuhyuh do?<br>这也是为了让口语更顺畅<br>另外几个例子:<br>what you do for a living?<br>读成<br>Whutchuhyuh do for a living?<br>I’m goint to go out to WalMar<strong>t. D</strong>o you need anything?<br>会读成<br>Ahmma go ou’tuh Walmartchuh nee danything?<br><strong>something 读成 sumpthin</strong><br>Can you give me something?<br>读成<br>Can you give me sumpthin?<br>Let me give you something<br>读成<br>Lemmee givyuh sumpthin<br><strong>单词中的t有时会读成d</strong></p>
<table>
<thead>
<tr>
<th align="center">单词</th>
<th align="center">口语发音</th>
</tr>
</thead>
<tbody><tr>
<td align="center">letter</td>
<td align="center">ledder</td>
</tr>
<tr>
<td align="center">city</td>
<td align="center">siddy</td>
</tr>
<tr>
<td align="center">bitter</td>
<td align="center">bidder</td>
</tr>
<tr>
<td align="center">bottle</td>
<td align="center">bodduhl</td>
</tr>
<tr>
<td align="center">butter</td>
<td align="center">budder</td>
</tr>
<tr>
<td align="center">computer</td>
<td align="center">compyooder</td>
</tr>
<tr>
<td align="center">daughter</td>
<td align="center">dawdder</td>
</tr>
<tr>
<td align="center">eighty</td>
<td align="center">ayddy</td>
</tr>
<tr>
<td align="center">forty</td>
<td align="center">fordy</td>
</tr>
<tr>
<td align="center">little</td>
<td align="center">lidduhl</td>
</tr>
<tr>
<td align="center">settle</td>
<td align="center">sedduhl</td>
</tr>
<tr>
<td align="center">thirty</td>
<td align="center">thurdy</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>语言</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>English</tag>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序：如何把公众号后台上传的视频链接插入到小程序</title>
    <url>/chinese/2020/04/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E6%8A%8A%E5%85%AC%E4%BC%97%E5%8F%B7%E5%90%8E%E5%8F%B0%E4%B8%8A%E4%BC%A0%E7%9A%84%E8%A7%86%E9%A2%91%E9%93%BE%E6%8E%A5%E6%8F%92%E5%85%A5%E5%88%B0%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="微信小程序视频链接"><a href="#微信小程序视频链接" class="headerlink" title="微信小程序视频链接"></a>微信小程序视频链接</h1><p>微信小程序对链接的过滤很严格，很多视频链接都没办法直接插入到小程序的video组件。但是腾讯自己的视频还是没问题的。我是现有的微信公众号，再为其开发小程序。所以希望将之前上传到微信公众号的视频在小程序中直接复用而不占用小程序云开发的存储空间。</p>
<a id="more"></a>

<p>获取微信公众号文章中视频链接的方法：</p>
<ol>
<li>用浏览器打开公众号文章，在浏览器（以chrome为例）中打开开发者工具<sup><a href="#foot_note_1">[1]</a></sup></li>
<li>选择network并选择Media过滤其<br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdm9yjomrhj30u00vn0vv.jpg" alt=""></li>
<li>点击播放视频，这时会出现一个包，包头部中红框部分就是我们想要的链接了。<br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdm9z0moluj31ln0u0aii.jpg" alt=""></li>
</ol>
<p><span id="foot_note_1"><sub>[1]:在chrome浏览器页面部分单击右键，选择“检查”</sub></span></p>
]]></content>
      <categories>
        <category>web</category>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序：scroll-view与swiper</title>
    <url>/chinese/2020/04/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%9Ascroll-view%E4%B8%8Eswiper/</url>
    <content><![CDATA[<h1 id="scroll-view与swiper的区别"><a href="#scroll-view与swiper的区别" class="headerlink" title="scroll-view与swiper的区别"></a>scroll-view与swiper的区别</h1><p>在做小程序的时候有一个需求:主要内容做成卡片，然后通过划动在卡片之间切换。划动的内容，第一反应就想到scroll-view组件，没细想就开始做了，但是做的差不多了总出现一些小毛病：</p>
<ol>
<li>划动时会停在两个卡片中间，而不是想要的一个卡片一个卡片的划动。</li>
<li>scroll-view带惯性感性，大力划动会连续跳过好几个卡片。还是没达到一个卡片一个卡片的划动。</li>
</ol>
<p>为了解决这个问题，我尝试了很多方法。第1个问题，我通过用js设置scroll-view的划动距离，强行让划到中间的卡片复位。废了九牛二虎之力才解决了，第2个问题怎么也解决不了。最后才发现<strong>更符合我需求的组件是swiper！</strong></p>
<a id="more"></a>

<p>参考：</p>
<ul>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html" target="_blank" rel="noopener">scroll-view</a><ul>
<li>滚动视图容器</li>
</ul>
</li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html" target="_blank" rel="noopener">swiper</a><ul>
<li>滑块视图容器</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>强大的反爬虫机制</title>
    <url>/chinese/2020/04/08/%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%8F%8D%E7%88%AC%E8%99%AB%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>需求：拥有招聘网站的招聘者账户，爬取求职者们的简历信息。（不过这个好像是违法的，还好我失败了，不建议尝试)</p>
<p>尝试过的工具：</p>
<ul>
<li><a href="https://docs.scrapy.org/en/latest/" target="_blank" rel="noopener">Scrapy</a></li>
<li><a href="https://splash.readthedocs.io/en/3.4.1/" target="_blank" rel="noopener">Splash</a></li>
<li><a href="https://www.selenium.dev/documentation/en/" target="_blank" rel="noopener">selenium</a></li>
</ul>
<a id="more"></a>
<p>在尝试的过程中遇到了如下几个问题：</p>
<ol>
<li>动态网站，直接使用Scrapy爬的话，只能爬静态网页。需要用到splash渲染</li>
<li>splash渲染过的网页(和浏览器看源码得到的内容一样)和实际网页内容不符，前者body中是一些js脚本。</li>
<li>使用selenium自动化控制得到正常网页，但是会被反爬虫机制发现，提示账户存在风险。</li>
</ol>
<p>爬虫经常遇到的问题，我基本都遇到了……</p>
<p><strong>解决方案</strong></p>
<ol>
<li>现在的动态网页越来越多，可以借助splash完成渲染，这个问题不大。</li>
<li>确实会有遇到某些url是经过js处理然后再生成的情况（比如某些url的加密解密，id的运算等），这样的情况下你直接看网页源代码是找不到直接的url的，而通过检查是可以看到经过处理的url的。一般遇到这个情况，除非你了解这些url的生成方式，自行设计算法来破解，不然直接用requests库就显得力不从心了。当然，遇到这种情况也有一个“曲线救国”的办法，就是借助selenium或者splinter来模拟浏览器访问，既然是模拟浏览器，当然它们都是可以处理js程序的，所以你看到的也是直接可以访问的url。(<a href="https://fishc.com.cn/thread-82644-1-1.html" target="_blank" rel="noopener">参考</a></li>
<li>按照2中的解决方案，改用selenium。通过添加cookies可以正常登录，但是尝试通过定位网页元素点击时，就出出现下图中的提示，我猜是因为定位不小心，定位到了隐藏元素，被判定为爬虫。<br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdm65nf0zbj31hb0o1dj2.jpg" alt="警告"></li>
</ol>
<p>到这之后就放弃了，毕竟只是好奇，想试一下。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币和区块链的运行原理</title>
    <url>/chinese/2019/11/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%92%8C%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>比特币和区块链技术出现很久了，大家或多或少都有耳闻。不管是对比特币暴涨的羡慕，还是对背后技术的科普。笔者也是一样多少看过一些相关资料，但最近读区块链支付领域的顶会<sup><a href="#foot_note_1">[1]</a></sup>论文<sup><a href="#foot_note_2">[2]</a></sup>时还是发现自己对技术细节了解太少，甚至存在一些误解。</p>
<p>本文会介绍一些比特区块链的技术细节，同时尽力使其容易理解。</p>
<a id="more"></a>

<h2 id="比特币-bitcoin"><a href="#比特币-bitcoin" class="headerlink" title="比特币 bitcoin"></a>比特币 bitcoin</h2><p>所谓的比特币其实是<strong>交易</strong>组成的链。每个<strong>交易</strong>中包含大概信息就是<strong><em>谁把这个比特币转账给了谁，并且由转出比特币的人签字画押（数字签名<sup><a href="#foot_note_3">[3]</a></sup>）</em></strong>，具体来说如<a href="#pic_1">图1</a>，每个交易中包含</p>
<ul>
<li>收到比特币的人的公钥</li>
<li>由<strong>上一个交易</strong>和<strong>收到比特币的人的公钥</strong>组成的数据的哈希</li>
<li><strong>转出比特币的人的数字签名</strong>。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g91yo948kjj30lw0crab5.jpg" alt=""></p>
<center><span id="pic_1"><sub>图1： 交易链</sub></span></center>

<p>这样做的话，应该收到比特币的人就可以验证转出比特币的人是不是真的拥有这个比特币。方法就是用<strong>上一个</strong>交易中所有者的公钥去验证<strong>这次</strong>交易中的数字签名，这样就能知道这个比特币上一次被转账给了这次的转出者。</p>
<p>这里有个问题是转出比特币的人可能将同一个比特币转账给多个人，这样上面的交易链就会分叉。然而其实只有最早的那次转账是有效的，后面的转账都是非法的。为了验证交易是不是最早的一次转账，就需要一个<strong>公认的顺序</strong>。传统的方法是由中心节点指定一个顺序，大家被动接受。而比特币是通过多数人同意来认定一个顺序是不是<strong>公认</strong>的，这似乎也更符合<strong>公认</strong>这个词的含义。想要让（比特币系统所有参与者中的）多数人<strong>公认</strong>一个顺序，需要：</p>
<ul>
<li>向所有参与者广播所有的交易</li>
<li>多数参与者同意一个顺序</li>
</ul>
<p>在每次交易时，交易的接收者需要证明多数节点同意这次交易是最先收到的交易，这样接收者就能安心的完成交易了。</p>
<p><strong><em>区块链的主要任务就是达成这样的一个公认的顺序</em></strong>。</p>
<h2 id="区块链-blockchain"><a href="#区块链-blockchain" class="headerlink" title="区块链 blockchain"></a>区块链 blockchain</h2><p>区块链的基础是<strong>时间戳服务器</strong>，如<a href="#pic_2">图2</a>。</p>
<h3 id="时间戳服务器"><a href="#时间戳服务器" class="headerlink" title="时间戳服务器"></a>时间戳服务器</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g926rnfzp5j30om07gq38.jpg" alt=""></p>
<center><span id="pic_2"><sub>图2： 时间戳服务器</sub></span></center>

<blockquote>
<p>时间戳服务器计算包含多个需要被打时间戳的数据项的区块的哈希值并广泛地发布这个哈希值。时间戳能证明要得到这个哈希值，显然这些数据当时一定是存在的。每个时间戳的哈希值都纳入了上一个时间戳，形成一条链，后面的时间戳进一步增强前一个时间戳。</p>
<p><em>Bitcoin: A Peer-to-Peer Electronic Cash System<sup><a href="#foot_note_4">[4]</a></sup></em></p>
</blockquote>
<p>系统参与者通过在某个时间戳之后计算哈希来表示对某个顺序的认同，这样最长的链就是最多人认同的链，也就是我们想要的公认的顺序。</p>
<p>如果某个恶意参与者想要修改链中某个区块的内容，那必须把这个区块之后的哈希全部重算一遍，并且快速计算使自己这条链成为最长的，在所有人之前将最新哈希广播出去。这看上去是个比较难的任务，但并非不可完成，只要有足够快的计算机就可能做到。<strong>解决方法就是为计算哈希增加难度</strong>。</p>
<h3 id="工作量证明-Proof-of-Work"><a href="#工作量证明-Proof-of-Work" class="headerlink" title="工作量证明 Proof-of-Work"></a>工作量证明 Proof-of-Work</h3><p><a href="#pic_3">图3</a>是区块链中区块的内容：</p>
<ul>
<li>上一个区块的哈希</li>
<li>上面提到的比特币交易</li>
<li>一个随机数（这个随机数是用来调整计算哈希的难度的，也是工作量证明的关键）</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9281qoyhej30ow06smxl.jpg" alt=""></p>
<center><span id="pic_3"><sub>图3： 区块链</sub></span></center>

<blockquote>
<p>工作量证明采取搜索一个随机数，使得被哈希时，如使用 SHA-256，得到的哈希值以数个 0 比特开始。平均所需工作 量将随所需 0 比特呈指数级增长而验证却只需执行一次哈希。</p>
<p><em>Bitcoin: A Peer-to-Peer Electronic Cash System<sup><a href="#foot_note_4">[4]</a></sup></em></p>
</blockquote>
<p>比特币运行的步骤：</p>
<blockquote>
<ol>
<li>向所有节点广播<strong>新交易</strong></li>
<li>区块链节点将收集的新交易组成一个区块（如<a href="#pic_3">图3</a>）</li>
<li>计算满足要求（<em>工作量证明</em>）的哈希，既得到某个随机数</li>
<li>将这个区块（包含了满足要求的随机数）广播</li>
<li>其他节点确认区块中所有交易都没有被支付过，而且区块确实能够计算出满足要求的哈希</li>
<li>节点通过在这个区块之上继续计算表示对这个区块的接受</li>
</ol>
</blockquote>
<p>这样计算哈希的难度大大增加，恶意节点想要赶上并超过其他所有节点计算哈希的速度，就必须拥有巨量的计算力，而如果拥有这样的计算力，用作正常贡献获得的激励会超过作恶，这样就从动机上消除了作恶。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><span id="foot_note_1"><sub>[1]: SOSP</sub></span><br><span id="foot_note_2"><sub>[2]: Lind, J., Naor, O., Eyal, I., Kelbert, F., Sirer, E. G., &amp; Pietzuch, P. (2019, October). Teechain: a secure payment network with asynchronous blockchain access. In <em>Proceedings of the 27th ACM Symposium on Operating Systems Principles</em> (pp. 63-79). ACM.</sub></span></p>
<p><span id="foot_note_3"><sub>[3]: 可以通过我另一片博客了解：<a href="[https://zhang-tianxu.github.io/chinese/2019/11/15/%E7%94%A8%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E8%A7%A3%E9%87%8ARSA%E5%8E%9F%E7%90%86/](https://zhang-tianxu.github.io/chinese/2019/11/15/用一个例子解释RSA原理/)">《用一个例子解释RSA原理》</a></sub></span></p>
<p><span id="foot_note_4"><sub>[4]: Bitcoin: A Peer-to-Peer Electronic Cash System. Satoshi Nakamoto.<a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener">https://bitcoin.org/bitcoin.pdf</a></sub></span></p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>比特币</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>用一个例子解释RSA原理</title>
    <url>/chinese/2019/11/15/%E7%94%A8%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E8%A7%A3%E9%87%8ARSA%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>RSA是一种非对称加密算法，是以三位发明者（Ron <strong>R</strong>ivest、Adi <strong>S</strong>hamir、Leonard <strong>A</strong>dleman）的last name的首字母组成的。（来自：<a href="[https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95](https://zh.wikipedia.org/wiki/RSA加密演算法)">维基百科，RSA加密算法</a>）</p>
<p>目前RSA被广泛使用，尤其在web server的密钥、SSH等领域。因其应用广泛，所以值得学习一下。我主要用一个简单的例子来解释RSA的运行原理，以及怎么（理论上）破解它。</p>
<p>但是讲解之前还是要强调，大家都在用并不代表就是安全的。抛去各种因素不考虑，单是计算机计算能力的快速提升就让RSA加密算法越来越不安全了。看完大家就有大概的了解了。</p>
<a id="more"></a>

<h2 id="概念解释（来自：维基百科，RSA加密算法）"><a href="#概念解释（来自：维基百科，RSA加密算法）" class="headerlink" title="概念解释（来自：维基百科，RSA加密算法）"></a>概念解释（来自：<a href="[https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95](https://zh.wikipedia.org/wiki/RSA加密演算法)">维基百科，RSA加密算法</a>）</h2><blockquote>
<p><strong>公钥与私钥的产生</strong></p>
<ol>
<li>随意选择两个大的素数$p$和$q$，$p$不等于$q$，计算$N=pq$。</li>
<li>$r =(p-1)(q-1)$</li>
<li>选择一个小于$r$的整数$e$，使$e$与$r$互质。</li>
<li>求得$e$关于$r$的模逆元，命名为$d$（既$(e \times d)\ \ mod\ \ 1 = r$）</li>
<li>将$p$和$q$的记录销毁。</li>
<li>$(N,e)$是公钥，$(N,d)$是私钥。Alice将她的公钥$(N,e)$传给Bob，而将她的私钥$(N,d)$藏起来。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>加密消息</strong><br>$密文 = 明文^e\ mod\ \ N\ $</p>
</blockquote>
<blockquote>
<p><strong>解密消息</strong></p>
<p>$明文 = 密文^d\ mod\ \ N$</p>
</blockquote>
<blockquote>
<p><strong>签名</strong></p>
<p>签名过程其实就是用私钥加密，公钥解密的过程，因为公钥智能解密对应私钥加密的消息，而私钥（理论上）不会被泄露，所以能够确定就是拥有私钥的人签的名。</p>
</blockquote>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>假设Alice想要通过一个不可靠的媒体接收Bob的一条私密消息，假设这个私密消息是99（如果像发送其他格式的消息，也需要转化为整数才行，这是不难的），那么详细过程如下：</p>
<ol>
<li>生成共私钥：<ol>
<li>选择两个素数11和17，那么$N = 11 \times 17 = 187$</li>
<li>$r = (11 -1) \times (17 -1) = 160$</li>
<li>找到一个与$r$互质的整数$e = 3$</li>
<li>由$( 3 \times d)\  mod\ \ 1 = 160$的$d$可为107。</li>
<li>将$N = 187$和$e = 3$作为公钥发给Bob，自己保留$N=187$和$d = 107$</li>
</ol>
</li>
<li>加密消息<ol>
<li>Bob想要发送私密消息99</li>
<li>$密文 = 99^e\  mod\ \ N = 99^3\ mod\ \ 187 = 143$</li>
<li>将密文143发送给Alice</li>
</ol>
</li>
<li>解密消息<ol>
<li>Alice拿到密文143</li>
<li>$明文 = 143^d\ mod\ \ N = 143^{107}\ mod\ \ 187 = 99$</li>
<li>这样Alice拿到了私密消息99</li>
</ol>
</li>
</ol>
<h2 id="破解RSA"><a href="#破解RSA" class="headerlink" title="破解RSA"></a>破解RSA</h2><p>从上面加解密的过程可以意识到开始时选择的两个素数的重要性。</p>
<p>拥有公钥（$N$和$e$）再算出开始时使用的两个素数，很容易就可以算出私钥：<br>$$<br>私钥d = ((11 - 1) \times (17 - 1) \times n + 1) \div e\<br> = (160 \times n + 1) \div 3\<br> = (160 \times 2 + 1) \div 3\<br> = 107<br>$$<br>其中$n$为正整数。</p>
<p><strong>所以将N分解为两个素数就等同于破解了密码</strong>，好在大素数分解目前还没有多项式时间算法，只能用暴力法试。但是只要算力和时间足够，这并没有想象中的困难，而且密钥生成的过程中有很多因素会削弱密钥的安全性。想具体了解，大家可以看 <strong><em>trailofbits</em></strong> 的博客 <em><a href="https://blog.trailofbits.com/2019/07/08/fuck-rsa/" target="_blank" rel="noopener">Seriously, stop using RSA</a></em></p>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>加密</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title>C与Python中的socket</title>
    <url>/chinese/2019/11/15/C%E4%B8%8EPython%E4%B8%AD%E7%9A%84socket/</url>
    <content><![CDATA[<h1 id="C与Python中的socket"><a href="#C与Python中的socket" class="headerlink" title="C与Python中的socket"></a>C与Python中的socket</h1><p>本文主要是想实现一下C与Python的socket通信，顺便说一下两者各自的socket编程。所以全篇结构如下：</p>
<ul>
<li>C中的socket</li>
<li>Python中的socket</li>
<li>C与Python的socket通信</li>
</ul>
<a id="more"></a>

<h2 id="C-中的socket"><a href="#C-中的socket" class="headerlink" title="C 中的socket"></a>C 中的socket</h2><p>这部分主要参考《UNIX环境高级编程（第3版）》</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOST <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 65432</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG <span class="meta-string">"Hello FROM C Server"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_fd;</span><br><span class="line">    <span class="keyword">int</span> client_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[BUFF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">local_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">remote_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;local_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(local_addr)); <span class="comment">//清零local_addr</span></span><br><span class="line">    local_addr.sin_family = AF_INET;</span><br><span class="line">    local_addr.sin_addr.s_addr = inet_addr(HOST);</span><br><span class="line">    local_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((server_fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span> ) <span class="comment">// 新建socket</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((bind(server_fd, (struct sockaddr *)&amp;local_addr, <span class="keyword">sizeof</span>(struct sockaddr))) &lt; <span class="number">0</span>) <span class="comment">// 绑定socket</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    listen(server_fd, <span class="number">10</span>); <span class="comment">// 监听socket</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sin_size = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">        <span class="keyword">if</span>( (client_fd = accept(server_fd, (struct sockaddr *)&amp;remote_addr, &amp;sin_size )) &lt;<span class="number">0</span> ) <span class="comment">// 接受client的链接请求</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"accept:"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">pid_t</span> handle_pid;</span><br><span class="line">        handle_pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(handle_pid == <span class="number">0</span>) <span class="comment">// 子进程处理请求</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(close(server_fd) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"close:"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> len = send(client_fd, MSG, <span class="keyword">sizeof</span>(MSG),<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"len = %d\n"</span>,len);</span><br><span class="line">            <span class="keyword">if</span>(len != <span class="keyword">sizeof</span>(MSG))</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"send:"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(close(client_fd) &lt; <span class="number">0</span>) <span class="comment">// 父进程关闭client的socket，继续监听。</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"close:"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(close(client_fd) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"close:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOST <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 65432</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFF_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(HOST);</span><br><span class="line">    server_addr.sin_port = htons(PORT);</span><br><span class="line">    <span class="keyword">if</span>((server_fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span> ) <span class="comment">// 新建socket</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((connect(server_fd, (struct sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(struct sockaddr)) &lt; <span class="number">0</span>) ) <span class="comment">// 连接server</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"connect:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = recv(server_fd, buf, BUFF_SIZE, <span class="number">0</span>); <span class="comment">//连接成功后接收信息</span></span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">        len = recv(server_fd, buf, BUFF_SIZE, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(server_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Python-中的socket"><a href="#Python-中的socket" class="headerlink" title="Python 中的socket"></a>Python 中的socket</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#server.py</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">65432</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">  s.bind((HOST, PORT))</span><br><span class="line">  s.listen(<span class="number">5</span>)</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, addr = s.accept()</span><br><span class="line">    <span class="keyword">with</span> conn:</span><br><span class="line">      conn.send(<span class="string">b"Hello From Python Server!"</span>)</span><br><span class="line">      conn.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#client.py</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">65432</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">  s.connect((HOST, PORT))</span><br><span class="line">  msg_part = s.recv(<span class="number">10</span>)</span><br><span class="line">  msg = msg_part</span><br><span class="line">  <span class="keyword">while</span> len(msg_parg) == <span class="number">10</span>:</span><br><span class="line">    msg += msg_parg</span><br><span class="line">    msg_parg = s.recv(<span class="number">10</span>)</span><br><span class="line">  msg += msg_part</span><br><span class="line">  print(msg)</span><br></pre></td></tr></table></figure>



<h2 id="C与Python的socket通信"><a href="#C与Python的socket通信" class="headerlink" title="C与Python的socket通信"></a>C与Python的socket通信</h2><p>C和Python通过套接字是可以直接通信的。需要注意的是消息的格式。socket传输的内容是byte流，C中可以使用强制类型转换，Python中则需要<code>pack()</code>与<code>unpack()</code>。</p>
<p>比如：</p>
<p>在C写的server端发送：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> msg = htonl(<span class="number">999</span>);</span><br><span class="line">send(client_fd, (<span class="keyword">const</span> <span class="keyword">void</span> *)&amp;msg, <span class="keyword">sizeof</span>(msg),<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>Python端接收：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> *</span><br><span class="line">(msg,) = unpack(<span class="string">'&gt;1I'</span>,socket.socket.recv(<span class="number">4</span>))</span><br><span class="line">print(msg)</span><br></pre></td></tr></table></figure>

<p><code>unpack()</code>的第一个参数表示格式，<code>&gt;1I</code>中的<code>&gt;</code>表示大端（相应的<code>&lt;</code>就表示小端），<code>1I</code>表示一个整数。</p>
<p><code>pack()</code>与<code>unpack()</code>的详细操作见<em>博主 *</em>三月沙** 的《<a href="https://sanyuesha.com/2018/03/10/why-pack-unpack/" target="_blank" rel="noopener">Python 中的 pack 和 unpack</a>》*。</p>
<hr>
<p>反过来也是一样：</p>
<p>在Python写的server中发送</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conn.send(pack(<span class="string">'&gt;I'</span>,<span class="number">999</span>))</span><br></pre></td></tr></table></figure>

<p>C写的client中接收：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> msg;</span><br><span class="line"><span class="keyword">int</span> len = recv(server_fd, (<span class="keyword">int</span> *)&amp;msg, <span class="keyword">sizeof</span>(<span class="keyword">int</span>),<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ntohl(*msg));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Python</tag>
        <tag>socket</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记——Scaling Intel SGX Apps with Intel SGX Card</title>
    <url>/chinese/2019/07/08/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Scaling-Intel-SGE-Apps-with-Intel-SGX-Card/</url>
    <content><![CDATA[<h1 id="Scaling-Intel-SGX-Apps-with-Intel-SGX-Card"><a href="#Scaling-Intel-SGX-Apps-with-Intel-SGX-Card" class="headerlink" title="Scaling Intel SGX Apps with Intel SGX Card"></a>Scaling Intel SGX Apps with Intel SGX Card</h1><p>这边笔记完全来自下面这篇论文：</p>
<p>Chakrabarti S, Hoekstra M, Kuvaiskii D, et al. Scaling Intel® Software Guard Extensions Applications with Intel® SGX Card[C]//Proceedings of the 8th International Workshop on Hardware and Architectural Support for Security and Privacy. ACM, 2019: 6.</p>
<h2 id="太长不看版"><a href="#太长不看版" class="headerlink" title="太长不看版"></a>太长不看版</h2><p>本文介绍了一个Intel 提出的一个新硬件——Intel SGX Card，这个SGX Card可以直接插在普通服务器的PCIe插槽上，有了这个新硬件带来一下好处：</p>
<ol>
<li>使得普通服务器据有SGX特性</li>
<li>突破SGX的128MB的内存限制，使SGX应用程序得到扩展。但是在维持SGX特性的同时实现这种扩展是要在一定程度上牺牲性能的。</li>
</ol>
<p>本文演示了在不可信数据中心中利用Intel SGX Card部署Intel SGX应用程序的四种方法。 为了加速Intel SGX应用程序的内存扩展部署，论文作者们开发了一个内存共享库，用于主机和SGX Card之间的快速异步通信，并通过VNF用例突出显示SGX Card的能力。</p>
<a id="more"></a>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>云计算的出现彻底改变了大型互联网应用部署和扩展的方式。但是很多公司还是不想将IT基础设施迁移到云上，原因有二：</p>
<ol>
<li>通常意义上的安全考量</li>
<li>对于商业机密数据的保护</li>
</ol>
<p>Intel SGX技术针对在不可信公共云上计算隐私数据这种情况，提供了一种硬件强制实现的可信执行环境。但是到目前为止Intel SGX还是有两个限制：</p>
<ol>
<li>只支持<strong>单插槽平台</strong>（<em>single-socket platforms</em>）</li>
<li>安全内存被限制在128MB以内</li>
</ol>
<p>本文介绍了一个硬件——SGX Card，SGX Card的特性如下：</p>
<ul>
<li>有三个独立的CPU，用于处理需要安全保证的任务。</li>
<li>多个SGX Card可以通过PCI Express总线连接到服务器主机上，提升服务器的额外CPU数量。</li>
</ul>
<p>有了额外的SGX Card，云服务提供商（CSP）可以使他们现有的服务平台具有Intel SGX的防护能力。随着隐私数据计算需求的增加，CSP们可以逐步为他们的数据中心增加SGX Card。</p>
<p>本文主要描述了在云环境下如何通过SGX Card在保持既定服务器形式的情况下扩展资源密集型SGX应用。我们将展示如何跨SGX Card节点横向扩展SGX应用程序，同时将对性能的影响降至最低。</p>
<p>SGX Card使得Intel SGX</p>
<ul>
<li>支持双插槽服务器平台（<em>dual-socket server platforms</em>），并且可以很容易地和现有数据中心基础架构整合。</li>
<li>通过软件支持，使得应用程序可以在SGX Card上的三个$Intel^® Xeon^® E3$处理器横向扩展，以获得更多的安全内存。</li>
</ul>
<p>本文还有如下贡献：</p>
<ul>
<li>对SGX Card的分析</li>
<li>SGX Card的内存共享库</li>
<li>提出了四种能够高效利用SGX Card的软件架构</li>
<li>展示了一个SGX Card的应用案例</li>
</ul>
<h2 id="Intel-SGX"><a href="#Intel-SGX" class="headerlink" title="Intel SGX"></a>Intel SGX</h2><p>本问讨论如何提升应用程序的<strong>安全性</strong>和<strong>可扩展性</strong>，前者由Intel SGX保证，后者由SGX Card保证。</p>
<h3 id="Intel-SGX架构"><a href="#Intel-SGX架构" class="headerlink" title="Intel SGX架构"></a>Intel SGX架构</h3><p>Intel SGX是对Intel CPU的一个ISA（指令集架构）扩展，它提供了提升应用程序机密部分机密性和完整性的能力。尽管应用程序的非机密部分处在不可信内存，但是机密部分被放在SGX的enclave中，enclave是一段对包括操作系统和hypervisor在内的其他任意软件都是不透明的内存空间。出于enclave中的代码可以执行几乎所有的CPU指令，并且可以读取enclave内外的数据。然而enclave外的特权/非特权软件对enclave数据的直接读取都会失败。enclave数据离开CPU芯片时，Intel SGX都会对数据作额外的加密。所以尝试直接读取RAM数据的硬件攻击也是无法成功的。</p>
<p>在硬件层面上引入了一些新的x86指令，用于对enclave做initialize、enter、resume和exit操作。当处于enclave模式时，CPU禁止对kernel的上下文切换。所以想要执行系统调用就必须先离开enclave，执行完系统调用后再重新进入SGX。离开enclave时会刷新TLB（Translation Lookaside Buffer），但是TLB对性能来说是很重要的，所以对于I/O密集型应用（需要经常离开enclave）来说，Intel SGX会有比较高的性能开销。</p>
<p>为了实现enclave数据的私密性和完整性，增加了一个硬件——EPC（Enclave Page Cache）。EPC是物理内存中的一个区域，这块区域不能被对应enclave以外的任何软件存取。所有从CPU发送到EPC的数据都会被CPU-secific的临时密钥加密。将数据从EPC移动到CPU会对数据进行解密并确保其完整性。目前，EPC大小为128M，其中只有大约96MB可以被用户数据使用。这么大的内存对某些应用（比如KMS）是足够的，但是如果enclave的工作量超出EPC的大小，就必须执行代价高昂的分页。在现有版本的Intel SGX上想要达到好的性能，就必须通过限制代码和数据大小来避免分页。</p>
<h3 id="建立Intel-SGX架构"><a href="#建立Intel-SGX架构" class="headerlink" title="建立Intel SGX架构"></a>建立Intel SGX架构</h3><p>Intel SGX为应用程序提供了熟悉的构建环境。开发过程中的一个根本不同在于要把程序分为可信与不可信两部分，前者放在enclave中。一些类似于Intel SGX SDK的工具需要手动分割代码，但是可以自动生成一些用于两部分代码通信的粘合代码（glue code）。已经有人提出根据开发者提供的代码注释来分割现有应用的自动分割工具。另外还有一些工具允许直接重用现有程序，只需很少甚至不需要任何修改。所有用户代码都在enclave中执行，只有不受信任的I/O系统调用执行在外面。</p>
<p>应用程序不受信的任部分必须将数据传输到安全区，以便enclave对这些数据执行私密计算。 类似地，在安全区完成计算之后，它必须将结果传递回不受信任的应用程序（然后通过不受信任的I/O将这些结果转发给最终用户）。Intel SGX中enclave和不受信任部分代码之间唯一的通信方式是共享不受信任的应用程序内存（enclave可以不受信任内存中的数据）。将通过不受信任内存进行通信分为<strong>同步通信</strong>和<strong>异步通信</strong>两种。</p>
<p><strong>同步通信：</strong></p>
<p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190707190211447.png" alt="image-20190707190211447"></p>
<p>在同步模式中（如上图），不被信任的部分想要对私密数据执行私密操作时步骤如下：</p>
<ol>
<li>它必须把数据放在与enclave共享的内存中</li>
<li>然后进入enclave（也就是所谓的ECALL）</li>
<li>然后读取共享内存中的数据进行相应操作。</li>
</ol>
<p>同样的，enclave想要执行不可信操作时的过程也是：</p>
<ol>
<li>必须将该操作所需要的数据放入共享内存</li>
<li>然后离开（exits）enclave</li>
<li>然后该操作被不被信任的部分执行（这就是所谓的OCALL）</li>
</ol>
<p><strong>异步通信：</strong></p>
<p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190707190234316.png" alt="image-20190707190234316"></p>
<p>在异步模式下，不被信任的部分和enclave利用共享内存以生产者-消费者的模式独立执行。比如，不被信任的部分可能执行I/O操作并且在共享队列中存储网络包，同时enclave按照自己的节奏接受这些包。</p>
<p>不管是异步模式还是同步模式，不被信任的部分和enclave都可以运行在独立的地址空间。通过RPC和共享内存实现ECALLs和OCALLs</p>
<h2 id="Intel-SGX-Card"><a href="#Intel-SGX-Card" class="headerlink" title="Intel SGX Card"></a>Intel SGX Card</h2><p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190707223636636.png" alt="image-20190707223636636"></p>
<p>上图是SGX Card的硬件架构，其中PCH指平台路径控制器<em>Platform Controller Hub</em>，DIMM指双线存储器模块<em>Dual In-line Memory ModuleSP</em>指<em>Scable Processor</em>。从图中我们可以看出每个SGX Card有三个Intel Xeon E3 CPU，每个CPU有其自己的本地RAM和完整的软件堆栈，所以每个Card节点运行其自己的操作系统并且通过自己的网络与外界通信。这在单个机架中提供了更多的计算能力，从而增加了云密度。</p>
<p>SGX Card通过非透明的PCIe Bridge与主机（通常是Intel Xeon Scable Processor）。SGX Card中的每个处理器都连接着自己的PCH、Flash、DIMM，单个处理器独立工作并且可以被用作三个独立服务器。在本文中SGX Card每个Card节点（card node）。也就是说每个SGX Card包含三个Card节点，每个Card节点像独立计算机一样处理数据，被自己的操作系统管理。</p>
<p>将三个Card节点放在一个PCIe Card上的优点是在Card和主机之间移动数据时能够提供高吞吐量和低延迟，这是Intel SGX Card的显着特征，我们用这种特征来构建内存共享库并高效地扩展Intel SGX应用程序。</p>
<h3 id="从软件视角看SGX-Card"><a href="#从软件视角看SGX-Card" class="headerlink" title="从软件视角看SGX Card"></a>从软件视角看SGX Card</h3><p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190707230800302.png" alt="image-20190707230800302"></p>
<p>上图是Intel SGX Card的软件架构，可以看出，SGX Card通过建立在PCIe上的虚拟网络和块I/O与主机进行通信。所以每个Card节点有其独立的网络和文件系统。</p>
<p>主机通过专用的带外接口启动并管理每个Card节点，主机也会配置Card节点的网络。Card节点通过专用虚拟以太网链路与主机连接。Card节点的IP地址由主机或者外部DHCP服务器分配。Card节点的虚拟以太网接口和主机网络之间的虚拟桥接器使得Card节点能够与外部网络进行通信。</p>
<h3 id="Memory-access-model"><a href="#Memory-access-model" class="headerlink" title="Memory access model"></a>Memory access model</h3><p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190708093633782.png" alt="image-20190708093633782"></p>
<p>从途中可以看出SGX Card的每个CPU都运行在自己的内存空间中。这就意味之每个Card节点都有完全独立于主机和其他Card节点的DRMA内存。</p>
<p>如同之前的图2所示，Card上的CPU和主机上的CPU都连接到同一个PCI主线上。这种拓扑逻辑下CPU可以做到通过DMA对其他CPU物理地址的读写，PCI bridges在两边都会暴露一个DMA窗口，通过这个DMA窗口就能调用远程数据。在软件层面，通过正确的内存映射，运行在其中一个CPU上的应用程序可以存取运行在其他CPU上的应用程序的内存。要注意共享内存区域必须是固定的，以防止其他CPU通过DMA读取内存页时，该内存页的拥有者CPU上的操作系统将该页调出内存。</p>
<p>SGX Card在主机侧和Card侧都会暴露DMA engine，DMA engine在两侧可以存取的内存数量是由PCI配置空间寄存器来配置的。远程内存范围可以映射到相应CPU访问范围的MMIO（Memory-Mapped I/O）地址空间。由于主机和Card节点可以具有不同的存储量，因此主机和Card上的DMA窗口大小可以不同。 将DMA窗口映射到MMIO空间后，该范围将显示为系统物理地址空间的一部分，并且可以映射给任何打算访问远程内存的应用程序。</p>
<p>在Card上，只需要将MMIO内存空间映射给应用程序就足够了。此外，DMA还必须被编程为能够成为两侧物理地址空间的桥梁。需要注意的是，利用DMA窗口从主机到Card的通信和从Card到主机的通信是不同的。</p>
<p>Card上的PCI bridges仅桥接Card节点和主机之间的PCI通信，但不桥接多个Card节点之间的PCI通信。 这样做在保证安全的同时也是的Card节点不能通过共享存储器直接相互通信。 如果需要在Card节点之间共享存储器，则可以以两个或更多个Card节点共享主机上的一系列物理存储器，当然这样做会增加内存访问延迟。</p>
<h3 id="Cache-Coherency"><a href="#Cache-Coherency" class="headerlink" title="Cache Coherency"></a>Cache Coherency</h3><p>尽管主机和Card节点可以共享内存，但是它们的内存空间还是存在Cache Coherency的问题。因为PCI总线不是Cache Coherent的，所以在其中一个内存空间更改内存，并不会自动在另一个内存空间反映为dirty cache line。而且，因为缺少snooping机制，cache line的更新也不会反映在其他内存空间中。造成这些的主要原因是没有能够用来运行cache coherency协议的额外连接。另外对于相同物理地址的地址映射在不同的地址空间可能不同。</p>
<p>所以，运行在主机上的应用程序和运行在Card节点的应用程序的进程间通信会有额外的性能开销。在需要Coherency时为了保证正确性，CPU每次都必须直接（ 绕过Cache）读写远程内存。</p>
<p>为了减轻这个问题，为远程内存映射选取合适的缓存技术变得非常重要。一个明显但是错误的选择是使用默认的写回策略，因为写回策略不会吧Cache line刷到远端（只能由应用程序明确的指定刷新），这回引发应用程序的一些错误行为。另一种常见选择就是写穿策略。</p>
<p>不幸的是，写穿策略不能提供高效的写性能，因为每次写都将分别在PCI总线上发送。所以，为了正确且高效，如果应用想要写到远程内存，这是必须使用<em>write-combine</em>缓存：</p>
<p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190708141304500.png" alt="image-20190708141304500"></p>
<p><em>write-combine</em>缓存是Intel架构为了高效PCI总线传输而支持的一类内存缓存，它允许数据暂时存放在被称为WCB（<em>Write-Combine Buffer</em>）的缓存区，以burst的模式一起释放，而不是将数据作为单个bits/bytes传输。一旦WCB满了，或者明确的刷新时间发生，就会对远程内存执行一次<em>combine</em>写。<em>Write-Combine</em>提高了PCI总线的利用率，进而提升了性能。</p>
<h2 id="Intel-SGX应用运行在SGX-Card上"><a href="#Intel-SGX应用运行在SGX-Card上" class="headerlink" title="Intel SGX应用运行在SGX Card上"></a>Intel SGX应用运行在SGX Card上</h2><p>本文提出四种在SGX Card上设计安全SGX应用的方法：</p>
<ol>
<li>对于非资源密集型的单enclave SGX应用程序，可以将整个应用程序放入SGX Card节点。</li>
<li>只将应用程序的可信任部分加载到Card节点，其他部分运行在主机上。</li>
<li>如果是资源密集型应用程序、多enclave SGX应用程序，可以<em>network scale-out</em>的方法将应用程序部署在Card节点上，然后通过它们之间的虚拟网络实现通信。</li>
<li>最后主机和Card可以使用共享内存而不是网络I/O来实现通信。</li>
</ol>
<p>一般来说，现代数据中心的服务器都有一些（超过10个）PCIe插口，所以可以容纳多个SGX Card。不过下面的介绍中我们假设只有一个SGX Card。</p>
<p>下面对上面说的4种方法逐个介绍</p>
<h3 id="整个应用程序加载到SGX-Card节点"><a href="#整个应用程序加载到SGX-Card节点" class="headerlink" title="整个应用程序加载到SGX Card节点"></a>整个应用程序加载到SGX Card节点</h3><p>对SGX Card的最简单的使用就是将整个应用程序都运行在Card节点上。因为每个Card节点有它自己的操作系统、文件系统以及网络。这种部署不需要对SGX应用进行修改。</p>
<p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190708143911796.png" alt="image-20190708143911796"></p>
<p>此类部署通过与已部署的主机服务器共享空间和电源，解决了云密度问题并很好地适应现有数据中心。 每个主机可以继续执行自己的资源密集型计算，并且Card上的Card节点可以托管多个独立的SGX应用程序。</p>
<h3 id="只加载可信任部分"><a href="#只加载可信任部分" class="headerlink" title="只加载可信任部分"></a>只加载可信任部分</h3><p>前面提到过SGX应用程序的可信部分和不可信部分不能在同一地址空间执行。这使得应用程序的不可信部分运行在主机CPU，可信部分运行在Card节点这种部署方式成为可能。</p>
<p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190708144302939.png" alt="image-20190708144302939"></p>
<p>在这种部署方式下，应用程序的不可信部分运行在高性能的服务器上，另一方面，可信部分可以使用Card处理器的所有内核执行enclave中的计算，也可以向外扩展到同一主机上的其他Card节点。</p>
<p>这种部署方式所需要的人工划分的工作应该是最少的。如果原SGX应用程序的可信部分和非可信部分的通信是同步的，那么只有OCALL/ECALL层必须修改，用RPC替换原来的函数调用。如果通信是异步的，那么在应用程序启动期间，必须实例化主机和Card节点之间的共享内存区域。</p>
<h3 id="利用Network-Scale-Out"><a href="#利用Network-Scale-Out" class="headerlink" title="利用Network Scale-Out"></a>利用Network Scale-Out</h3><p>上面两种部署方式的一个主要缺陷就是单enclave SGX应用程序会被Card节点的EPC大小所限制。目前Intel SGX服务器的EPC内存是有限的，超过这个内存限制就会出现代价高昂的换页。</p>
<p>有了SGX Card，应用程序可以扩展到多个enclave上执行，比如计算和数据被分开不晒在Card节点上运行的几个enclave上。因此，一个SGX Card就可以将EPC内存扩大原来的3倍，如果有个更多SGX Card则可以将EPC内存扩展到更大。这种部署方式的另外一个好处就是所有enclave共享主机上的不可信RAM。</p>
<p>然而想要采用这种部署方式，原来的SGX应用程序必须经过修改以支持执行在独立EPC内存区域上的多个enclave。特别的，应用程序需要可信部分与不可信部分之间的高效通信方式：要么通过TCP/IP网络消息实现同步通信，要么通过共享内存实现异步通信。</p>
<p>前者比较简单，每个Card节点运行自己的TCP/IP网络栈，并且有自己独立的IP地址，对应用程序的修改和<em>只加载可信任部分</em>部署方式类似，用RPC替代直接的OCALL/ECALL。</p>
<p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190708151514478.png" alt="image-20190708151514478"></p>
<h3 id="利用内存扩展"><a href="#利用内存扩展" class="headerlink" title="利用内存扩展"></a>利用内存扩展</h3><p>应用程序的可信部分和非可信部分也可以通过共享内存通信。在启动时，不可信部分会在不可信RAM中实例化一个共享内存区域，然后告诉所有的enclave。在运行时，应用程序的不可信部分和可信部分都遵从一个应用程序指定协议，安全一致地存储/加载数据</p>
<p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190708152648689.png" alt="image-20190708152648689"></p>
<p>虽然我们主要使用内存扩展设计来实现主机和Card之间的共享内存通信，但我们也可以使用主机的共享内存作为每个Card节点几乎无限的不可信存储。 但是，Card节点上的enclave必须小心将其私有数据存储在不受信任的主机RAM中，并对其进行适当加密和完整性保护。<br>可以在PCIe总线上模拟主机和卡之间的共享内存。 由于Intel SGX Card节点与主机之间的共享内存不具有Cache Coherency，因此我们开发了一个库，可缓解Cache Coherency问题，并为不受信任的部分和enclave之间的通信提供高级别API。</p>
<h2 id="其他贡献"><a href="#其他贡献" class="headerlink" title="其他贡献"></a>其他贡献</h2><h3 id="威胁模型"><a href="#威胁模型" class="headerlink" title="威胁模型"></a>威胁模型</h3><p>在本文中我们使用和普通Intel SGX相同的威胁模型，可信基只有enclave以及主机和Card上的CPU。不被信任的包括SGX 应用的不可信部分、其他应用、所有的特权软件、主机和不可信SGX Card上的所有的硬件，主机和Card节点的通信也是不被信任的。</p>
<p>理论上，使用Intel SGX Card的部署具有与普通Intel SGX环境相同的威胁模型。用作通信的PCIe总线必须被看作不可信硬件组件，所以enclave必须保护所有的出入数据，用HMAC（<em>Hash-based Message Authentication Code</em>）保证完整性，用加密保证私密性，用版本号防止回滚。在两个Card节点的enclave与enclave通信时也需要同样的保护，因为它们的通信需要通过主机内存。如果通过PCIe发送的数据的pattern必须隐藏，那么就必须采用某种混淆计算来消除pattern。</p>
<h3 id="enclave的远程验证"><a href="#enclave的远程验证" class="headerlink" title="enclave的远程验证"></a>enclave的远程验证</h3><p>SGX应用程序的客户端在向enclave传输私密数据之前必须执行远程证明，以获得对enclave内和Intel SGX平台本身执行的代码的信任。对于SGX Card上的部署，远程验证有一下几个选择：</p>
<ol>
<li>一种简单的方法就是将Card节点暴露在外部网络中，进而暴露给最终用户。然后，客户端对在三个Card节点上运行的三个enclave进行远程证明。 这种方法的缺点是客户必须知道SGX Card上的所有enclave并执行多轮网络通信。</li>
<li>用户将整个服务器看作一个黑盒。每个用户只需要验证作为信任根的那个enclave。这个enclave在去验证其他enclave。如果有多个SGX Card，可以利用信任链验证所有的enclave。</li>
<li>数据中心可能有一个类似OpenStack Barbican的运行在enclave内的密钥管理器，可以证明数据中心所有SGX Card上的所有enclave。因此，该密钥管理器成为信任和供应的单一根。</li>
</ol>
<h2 id="内存共享库"><a href="#内存共享库" class="headerlink" title="内存共享库"></a>内存共享库</h2><p>如同上面提到的，SGX Card允许应用程序通过共享内存实现扩展。大量数据可以在运行在主机上的不可信部分和运行在SGX Card上的可信部分间快速传输。</p>
<p>对于Intel SGX应用程序，尽管不可信部分和可信部分运行在不同的计算平台上，但在Card节点上运行的enclave可以直接与主机上的不可信应用程序通信，而不会离开enclave这种模式能够提供性能上的提升。 应用程序的不受信任部分可以在主机平台上进行扩展，而可信部分可以在多个Card节点上进行扩展以满足性能要求。</p>
<h3 id="库的设计"><a href="#库的设计" class="headerlink" title="库的设计"></a>库的设计</h3><p>我们设计并且建立了一个内存共享库，它为应用程序提供用来利用PCIe主线远程共享内存的高级别API。</p>
<p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190708161348110.png" alt="image-20190708161348110"></p>
<p>这个库有三个级别的API：</p>
<ol>
<li>使用<em>Write-Combine</em>的低级别的共享内存访问原语API</li>
<li>为主机和Card节点通信提供的异步队列API</li>
<li>为主机和Card节点之间任务分配提供的任务队列API</li>
</ol>
<p>低级别API提供了初始化主机和Card节点上的共享内存区域的功能。 初始化内存区域后，开发人员可以调用低级别API函数来读取和写入远程内存（使用写入组合缓存策略）。</p>
<p>异步队列API提供函数在主机和Card节点之间建立一个SPSC（<em>Single Producer Single Consumer</em>）共享队列，并且提供两个函数来实现出列和入列。通常，应用程序开发人员将创建与Card节点一样多的队列，以便主机将对特定Card节点的请求放入相应队列进行排队。</p>
<p>任务队列API提供函数建立SPMC（<em>Single Producer Multiple Consumer</em>）队列，其他和异步队列API类似。这当主机将可由任何可用Card节点执行的请求排入队列时，这个API对于任务分发非常有用。</p>
<h3 id="库的实现"><a href="#库的实现" class="headerlink" title="库的实现"></a>库的实现</h3><p>内存共享库的基础是使用SGX Card PCIe驱动提供的API任意编程DMA引擎的能力，该库利用Sysfs等抽象用户空间接口进行DMA引擎编程。</p>
<p>要调度应用程序请求，库必须与远程端的对应方通信。 该通信发生在现有的虚拟网络接口或基于PCI的通信协议上。</p>
<p>在我们的实现远行中在主机上的不可信应用程序存储一块内存然后告诉SGX Card驱动它打算和指定Card节点共享这块内存。同时Card节点上的enclave也会请求驱动将远程内存映射到它的地址空间。结果，主机上的驱动向Card节点上的驱动提供物理地址（或物理地址范围）。 然后，SGX Card上的驱动通过这些远程物理地址之间的映射对DMA引擎进行编程，并将MMIO范围映射到SGX Card上应用程序的地址空间中。</p>
<p>这个基础通信渠道一旦建立，异步通信原语和任务队列就可用于主机上的不可信应用程序和Card节点上的enclave之间的高级别数据交换。</p>
<p>注意到如果应用程序为内存共享保留4KB的页，那内存共享库可能需要在DAM引擎中创建多个映射，因为物理地址可能是不连续的。在理想状态下，应用程序应该使用2MB到1GB的巨页来保留共享内存。使用巨页可确保连续的物理地址范围。 由于操作系统永远都不会讲巨页换出，所以巨页还具有确保内存永久固定的好处。</p>
<h3 id="总体性能"><a href="#总体性能" class="headerlink" title="总体性能"></a>总体性能</h3><p>通常情况下CPU和DRAM之间的存取时间大约是100ns，而CPU和PCI寄存器之间的存取时间大约在400ns-500ns之间。远程内存读取因为增加了PCI和DRAM之间的存取，所以会额外增加大约100ns的开销。通常，与本地内存相比访问远程内存时开销可能达到约5倍，因此应用程序的吞吐量会下降。然而，吞吐量的这种下降可以通过并行计算来补偿。 通过在Intel SGX Card上的多个Card节点上使用多个Intel SGX enclave，并将请求分配给这些enclave（使用内存共享），我们可以提高应用程序的整体吞吐量。</p>
<h2 id="用例——VNF（Virtual-Network-Function）"><a href="#用例——VNF（Virtual-Network-Function）" class="headerlink" title="用例——VNF（Virtual Network Function）"></a>用例——VNF（Virtual Network Function）</h2><p>为了展示Intel SGX Card的能力，我们从零开发了可扩展的支持Intel SGX的安全监控VNF。我们的安全监视器检查网络上的所有数据包，并根据远程管理员提供的预定义规则进行转发。</p>
<h3 id="VNF的架构"><a href="#VNF的架构" class="headerlink" title="VNF的架构"></a>VNF的架构</h3><p>我们的VNF运行在enclave中，包含L2/L3网络功能，支持Cuckoo哈希查找表和IPSec，关闭TLS/SSL以实现和远程管理员控制台的安全通信。远程管理员与enclave建立安全的SSL通道，执行远程证明，然后将协议规则和哈希表条目发送到enclave。 初始化后，enclave会连续运行安全监视器VNF，并将统计信息发送回远程管理员。</p>
<p>在将VNF一直到enclave的过程中遇到了一些挑战：</p>
<ol>
<li>在Intel SGX中ECALL/OCALL的代价高昂，所以我们希望尽量减少进出enclave的次数。</li>
<li>EPC换页在当前的Intel SGX实现下代价高昂，所以我们力争尽量减小VNF占用的内存大小。</li>
</ol>
<p>基于上面的设计要求，我们把VNF切分，运行在两个核上：</p>
<p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190708190831527.png" alt="image-20190708190831527"></p>
<p>数据包I/O发生在第一个核生的不可信内存中，而安全监控则在第二个内核的enclave内运行。在第一个核上的不可信部分接受来自NIC的数据包，将指向数据的指针通过RX ring转发给第二个核，然后第二个核上的enclave执行真正的VNF处理所有数据包。第一个核从第二个核接受信息并且将被准许的修改过的数据包通过TX ring发回给NIC。安全监视器VNF永远不会离开enclave，其内存占用空间仅包含带有规则的哈希表，而不包括网络数据包。</p>
<p>这个设计在保证监视器规则隐私性和完整性的同时，性能下降少于10%。（注意我们是要保护远程配置的规则/策略，而不是网络数据包内容。）在我们的实验中，我们不会被SGX限制，而是被NIC 40Gbps的容量限制。为了扩展到40Gbps以上，我们将安全监视器VNF移植到Intel SGX Card上。</p>
<h3 id="在Intel-SGX上扩展VNF"><a href="#在Intel-SGX上扩展VNF" class="headerlink" title="在Intel SGX上扩展VNF"></a>在Intel SGX上扩展VNF</h3><p>我们在安全监视器用例中使用了内存扩展。为此，我们修改了VNF的receive/transmit rings以在内存共享库上运行。这使我们能够利用主机CPU上的四个核协助NIC将数据包转发到一个Card节点上的四个核。一旦使用内存共享库提供的API初始化底层生产者/消费者异步队列，我们的安全监视器就可以无缝地工作了。在内存扩展的过程中我们没有遇到具体问题。<br>我们用五个NIC和五个Card节点评估了我们的原型。为了维持吞吐量，我们在主机CPU上使用了20个内核来处理数据包I/O.在实验中，我们使用Cuckoo哈希表执行5元组查找，在384B大小的TCP/IP数据包上有100K条目;每个enclave使用8个超线程。我们的实验表明完美的可扩展性：我们的基于SGX Card的安全监控器在零数据包丢失的情况下实现了200Gbps的吞吐量，是单个Intel SGX enclave的整整五倍。</p>
<p><img src="http://pubn1s4ko.bkt.clouddn.com/blog/study/pro/paper/image-20190708195153068.png" alt="image-20190708195153068"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们演示了在不受信任的数据中心中使用Intel SGX Card部署Intel SGX应用程序的四种方法。 为了促进Intel SGX应用程序的内存扩展部署，我们开发了一个内存共享库，用于主机和SGX Card之间的快速异步通信，并通过VNF用例突出显示SGX Card的能力。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>Chakrabarti S, Hoekstra M, Kuvaiskii D, et al. Scaling Intel® Software Guard Extensions Applications with Intel® SGX Card[C]//Proceedings of the 8th International Workshop on Hardware and Architectural Support for Security and Privacy. ACM, 2019: 6.</li>
<li>Ittai Anati, Shay Gueron, Simon Johnson, Vincent Scarlata. Innovative technology for CPU based attestation and sealing. HASP’2013 </li>
<li>Victor Costan, Srinivas Devadas. Intel® SGX Explained.IACR Cryptology ePrint Archive, 2016 </li>
<li>Meni Orenbach, Pavel Lifshits, Marina Minkin, Mark Silberstein. Eleos: ExitLess OS Services for SGX Enclaves. EuroSys’2017 </li>
<li>Sergei Arnautov, Bohdan Trach, Franz Gregor, Thomas Knauth, Andre Martin, Christian Priebe, Joshua Lind, Divya Muthukumaran, Dan O’Keeffe, Mark L. Stillwell, David Goltzsche, David Eyers, Rüdiger Kapitza, Peter Pietzuch, Christof Fetzer. SCONE: secure Linux containers with Intel® SGX. OSDI’2016 </li>
<li><a href="https://github.com/intel/linux-sgx" target="_blank" rel="noopener">https://github.com/intel/linux-sgx</a>. Intel SGX for Linux. Accessed: 2019 </li>
<li>Andrew Baumann, Marcus Peinado, Galen Hunt. Shielding applications from an untrusted cloud with Haven. OSDI’2014 </li>
<li>Chia-Che Tsai, Mona Vij, Donald Porter. Graphene-SGX: A Practical Library OS for Unmodified Applications on SGX. USENIX ATC’2017 </li>
<li>Joshua Lind, Christian Priebe, Divya Muthukumaran, Dan O’Keeffe, Pierre-Louis Aublin, Florian Kelbert, Tobias Reiher, David Goltzsche, David Eyers, Rudiger Kapitza, Christof Fetzer, Peter Pietzuch. Glamdring: Automatic Application Partitioning for Intel SGX. ATC’2017 </li>
<li>Ofir Weisse, Valeria Bertacco, Todd Austin. Regaining Lost Cycles with HotCalls: A Fast Interface for SGX Secure Enclaves. ISCA’2017 </li>
<li>Dmitrii Kuvaiskii, Somnath Chakrabarti, Mona Vij. Snort Intrusion Detection System with Intel Software Guard Extension (Intel SGX). arXiv:1802.00508, 2018 </li>
<li>Bohdan Trach, Alfred Krohmer, Sergei Arnautov, Franz Gregor, Pramod Bhatotia, Christof Fetzer. Slick: Secure Middleboxes using Shielded Execution. arXiv:1709.04226, 2017 </li>
<li>Hagit Attiya, Amotz Bar-Noy, Danny Dolev. 1995. Sharing memory robustly in message-passing systems. J. ACM 42, 1 1995 </li>
<li><a href="https://asylo.dev" target="_blank" rel="noopener">https://asylo.dev</a>. Google Asylo. Accessed: 2019 </li>
<li>Wenting Zheng, Ankur Dave, Jethro G. Beekman, Raluca Ada Popa, Joseph E. Gonzalez, Ion Stoica. Opaque: an oblivious and encrypted distributed analytics platform. NSDI’2017 </li>
<li>sajin Sasy, Sergey Gorbunov, Christopher Fletcher. ZeroTrace:  Oblivious Memory Primitives from Intel SGX. Cryptology ePrint Archive, 2017 </li>
<li><a href="https://redis.io" target="_blank" rel="noopener">https://redis.io</a>. Redis. Accessed: 2019</li>
<li>Felix Schuster, Manuel Costa, Cédric Fournet, Christos Gkantsidis, Marcus Peinado, Gloria Mainar-Ruiz, Mark Russinovich. VC3: Trustworthy Data Analytics in the Cloud Using SGX. SP’2015 </li>
<li>Olga Ohrimenko, Felix Schuster, Cédric Fournet, Aastha Mehta, Sebastian Nowozin, Kapil Vaswani, Manuel Costa. Oblivious Multi-Party Machine Learning on Trusted Processors. USENIX Security’2016 </li>
<li>Tyler Hunt, Zhiting Zhu, Yuanzhong Xu, Simon Peter, Emmett Witchel. Ryoan: a distributed sandbox for untrusted computation on secret data. OSDI’2016 </li>
<li>Seongmin Kim, Juhyeng Han, Jaehyeong Ha, Taesoo Kim, Dongsu Han. Enhancing security and privacy of tor’s ecosystem by using trusted execution environments. NSDI’2017 </li>
<li>Shweta Shinde, Dat Le Tien, Shruti Tople, Prateek Saxena. Panoply: Low-TCB Linux Applications with SGX Enclaves. NDSS’2017 </li>
<li>Ming-Wei Shih, Mohan Kumar, Taesoo Kim, and Ada Gavrilovska. S-NFV: Securing NFV states by using SGX. SDN-NFV Security’2016 </li>
<li>David Goltzsche, Signe Rüsch, Manuel Nieke, Sébastien Vaucher, Nico Weichbrodt, Valerio Schiavoni, Pierre-Louis Aublin, Paolo Costa, Christof Fetzer, Pascal Felber, Peter Pietzuch, Rüdiger Kapitza. EndBox: Scalable Middlebox Functions Using Client-Side Trusted Execution. DSN’2018 </li>
<li>Michael Coughlin, Eric Keller, Eric Wustrow. Trusted Click: Overcoming Security issues of NFV in the Cloud. SDN- NFVSec’2017 </li>
<li>Huayi Duan, Xingliang Yuan, Cong Wang. LightBox: SGX-assisted Secure Network Functions at Near-native Speed. arXiv:1706.06261, 2017 </li>
<li>Alexey Gribov, Dhinakaran Vinayagamurthy, Sergey Gorbunov. StealthDB: a Scalable Encrypted Database with Full SQL Query Support. arXiv:1711.02279, 2017 </li>
<li>Saba Eskandarian, Matei Zaharia. ObliDB: Oblivious Query Processing using Hardware Enclaves. arXiv:1710.00458, 2018 </li>
<li>Christian Priebe, Kapil Vaswani, Manuel Costa. EnclaveDB: A Secure Database using SGX. SP’2018 </li>
<li>Rohit Sinha, Mihai Christodorescu. VeritasDB: High Throughput Key-Value Store with Integrity. Cryptology ePrint Archive 2018/251, 2018 </li>
<li><a href="https://www.intel.com/content/www/us/en/products/servers/accelerat" target="_blank" rel="noopener">https://www.intel.com/content/www/us/en/products/servers/accelerat</a> ors/visual-compute-accelerator-SGX accelerator1585lmv.html. Intel Visual Compute accelerator (Intel SGX Card). Accessed: 2018 </li>
<li><a href="https://redis.io/topics/cluster-spec" target="_blank" rel="noopener">https://redis.io/topics/cluster-spec</a>. Redis Cluster Specification. Accessed: 2019 </li>
<li><a href="https://github.com/twitter/twemproxy" target="_blank" rel="noopener">https://github.com/twitter/twemproxy</a>. twitter/twemproxy. Accessed: 2019 </li>
<li>Yelick, Bonachea, Chen, Colella, Datta, Duell, Graham, Hargrove, Hilfinger, Husbands, and Iancu. Productivity and performance using partitioned global address space languages. PASCO’2007 </li>
<li>Aaftab Munshi, Benedict Gaster, Timothy G. Mattson, and Dan Ginsburg. OpenCL programming guide. Pearson Education, 2011 </li>
<li>Marcus Brandenburger, Christian Cachin, Rüdiger Kapitza, Alessandro Sorniotti. Blockchain and Trusted Computing: Problems, Pitfalls, and Solution for Hyperledger Fabric. arXiv:1805.08541, 2018</li>
<li>Rolf Neugebauer, Gianni Antichi, José Fernando Zazo, Yury Audzevich, Sergio López-Buedo, Andrew W. Moore. Understanding  PCIe performance for end host networking. SIGCOMM ‘2018 </li>
<li>Somnath Chakrabarti, Brandon Baker, Mona Vij. Intel SGX Enabled Key Manager Service with OpenStack Barbican. ArXiv:1712.07694, 2017</li>
<li>Jack Regula. Using non-transparent bridging in PCI Express systems. PLX Technology white paper, 2004 </li>
<li><a href="http://www.cpushack.com/tag/knights-corner" target="_blank" rel="noopener">http://www.cpushack.com/tag/knights-corner</a>. CPU of the Day: The 61 Knights of the Intel Xeon Phi. Accessed: 2019 </li>
</ol>
]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>SGX</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>在k8s上部署Jenkins</title>
    <url>/chinese/2019/06/26/%E5%9C%A8k8s%E4%B8%8A%E9%83%A8%E7%BD%B2Jenkins/</url>
    <content><![CDATA[<h1 id="在k8s上部署Jenkins"><a href="#在k8s上部署Jenkins" class="headerlink" title="在k8s上部署Jenkins"></a>在k8s上部署Jenkins</h1><p>谷歌在k8s上部署Jenkins的方法，都写的很复杂，各种配置文件一堆，还都失败了！<strong>最终部署成功后发现只需要一句命令就可以了。</strong></p>
<a id="more"></a>

<p>这个命令就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl run jenkins --image&#x3D;jenkinsci&#x2F;blueocean --port 5000</span><br></pre></td></tr></table></figure>

<p>命令解释</p>
<ol>
<li><code>--image=jenkinsci/blueocean</code>用来指定镜像，<a href="https://hub.docker.com/r/jenkinsci/blueocean/" target="_blank" rel="noopener"><code>jenkinsci/blueocean</code> image</a>(来自 the <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub repository</a>)。 该镜像包含当前的<a href="https://jenkins.io/download" target="_blank" rel="noopener">长期支持 (LTS) 的Jenkins版本</a> （可以投入使用） ，捆绑了所有Blue Ocean插件和功能。这意味着你不需要单独安装Blue Ocean插件。</li>
<li><code>--port 端口号</code>用于指定deployment的端口号，可以随便指定.</li>
</ol>
<p>通过<code>kubectl get deployments</code>可以看到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME       READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">jenkins    1&#x2F;1     1            1           10s</span><br></pre></td></tr></table></figure>

<p>显示READY说明deployment创建成功。这是在本地集群已经可以访问，如果想要在外部访问，需要将deployment暴露未service：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment jenkins --type&#x3D;NodePort --target-port&#x3D;8080</span><br></pre></td></tr></table></figure>

<p>命令解释：</p>
<ol>
<li><code>--type=NodePort</code>是将service的类型设置为NodePort，这样才能被外部看到</li>
<li><code>--target-port=8080</code>是映射（例如“发布”）<code>jenkinsci/blueocean</code> 容器的端口8080到主机上的端口8080</li>
</ol>
<p>这一步完成后执行<code>kubectl get service</code>查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)           AGE</span><br><span class="line">jenkins     NodePort    10.107.210.195   &lt;none&gt;        5000:30509&#x2F;TCP    6m35s</span><br></pre></td></tr></table></figure>

<p>可以看出service对外暴露的端口是30509，可以通过<code>kubectl edit service jenkins</code>命令将配置中的<code>- nodePort</code>修改为你想要暴露出去的端口即可。</p>
<p>浏览器访问得</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/DevOps/jenkins/unlock_jenkins.png" alt="image-20190626205811349"></p>
<p>这里要求<strong><em>Administrator password</em></strong>，正常来说是通过<code>/var/jenkins_home/secrets/initialAdminPassword</code>来查看，但是因为运行在docker中，所以需要查看docker的log。我们这里更进一步又把docker放到了k8s中，所以要查看jenkins的docker对应的pod的log，方法如下：</p>
<ol>
<li><p><code>kubectl get pods</code>，找到jenkins对应的pod的NAME，我的对应的名称为jenkins-747ddfbdb6-4msmw</p>
</li>
<li><p><code>kubectl logs jenkins-747ddfbdb6-4msmw</code>查看pod的log</p>
</li>
<li><p>在显示的log中就有我们需要的<strong><em>Administrator password</em></strong>，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jenkins.install.SetupWizard init</span><br><span class="line">INFO:</span><br><span class="line"></span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br><span class="line"></span><br><span class="line">Jenkins initial setup is required. An admin user has been created and a password generated.</span><br><span class="line">Please use the following password to proceed to installation:</span><br><span class="line"></span><br><span class="line">7f54c6c500e242e9bbc804c169c52a3c</span><br><span class="line"></span><br><span class="line">This may also be found at: &#x2F;var&#x2F;jenkins_home&#x2F;secrets&#x2F;initialAdminPassword</span><br><span class="line"></span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br></pre></td></tr></table></figure>

<p>输入上面的password就能进入注册界面：</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/DevOps/jenkins/create_admin_user.png" alt="image-20190626210358399"></p>
</li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>Jenkins官方文档：<a href="https://jenkins.io/zh/doc/book/installing/#setup-wizard" target="_blank" rel="noopener">https://jenkins.io/zh/doc/book/installing/#setup-wizard</a></p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>Jenkins</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>为k8s配置可视化</title>
    <url>/chinese/2019/06/24/%E4%B8%BAk8s%E9%85%8D%E7%BD%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<h1 id="为k8s配置可视化"><a href="#为k8s配置可视化" class="headerlink" title="为k8s配置可视化"></a>为k8s配置可视化</h1><p>K8s dashboard是k8s集群的web-based UI工具，用户可以通过dashboard管理运行在集群上的应用以及集群自身。</p>
<p>安装本身非常容易，只需要下面一条语句就可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;dashboard&#x2F;v1.10.1&#x2F;src&#x2F;deploy&#x2F;recommended&#x2F;kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure>

<p>但是再次由于墙的原因，国内执行这条语句会出现<code>ErrImagePull</code>的错误。如果你已经执行了，就需要删除这个pod。但是如果直接用<code>kubectl delete pods &lt;pod name&gt; --namespace=&lt;namespace&gt;</code>的话，通过<code>kubectl get pods --all-namespaces</code>查看会发现它马上就会重新建立。这是因为要直接删除<code>kubectl delete deployment &lt;deployment name&gt;</code>。</p>
<a id="more"></a>

<p>所以在国内还得需要镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull registry.cn-qingdao.aliyuncs.com&#x2F;wangxiaoke&#x2F;kubernetes-dashboard-amd64:v1.10.0</span><br><span class="line">docker tag registry.cn-qingdao.aliyuncs.com&#x2F;wangxiaoke&#x2F;kubernetes-dashboard-amd64:v1.10.0 k8s.gcr.io&#x2F;kubernetes-dashboard-amd64:v1.10.0</span><br><span class="line">docker image rm registry.cn-qingdao.aliyuncs.com&#x2F;wangxiaoke&#x2F;kubernetes-dashboard-amd64:v1.10.0</span><br></pre></td></tr></table></figure>

<p>下载完镜像后执行<code>kubectl apply -f http://mirror.faasx.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml</code>就部署完成了，可以通过命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;kubectl get pods --namespace&#x3D;kube-system&#96;</span><br></pre></td></tr></table></figure>

<p>查看，然后可以通过<code>kubectl get service --namespace=kube-system</code>查看dashboard的外网暴露端口。如果发现暴露的端口类型是<code>ClusterIP</code>，可以运行<code>kubectl edit service  kubernetes-dashboard --namespace=kube-system</code>大概配置文件，找到type，将ClusterIP改成NodePort。同时也可以通过这个命令修改<code>NodePort</code>以达到修改暴露端口的目的。</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/DevOps/k8s/kubectl_edit_service.png" alt="image-20190624073355080"></p>
<p>现在在本级上通过访问<code>localhost:端口</code>就能访问图形界面了。但是想要在其他机器访问，需要SSL证书，通过https来访问。</p>
<ol>
<li><p>生成私钥和证书签名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl genrsa -des3 -passout pass:x -out dashboard.pass.key 2048</span><br><span class="line">openssl rsa -passin pass:x -in dashboard.pass.key -out dashboard.key</span><br><span class="line">rm dashboard.pass.key</span><br><span class="line">openssl req -new -key dashboard.key -out dashboard.csr</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成SSL证书</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -sha256 -days 365 -in dashboard.csr -signkey dashboard.key -out dashboard.crt</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建dashboard用户</p>
<p>执行<code>kubectl create -f dashboard-user-role.yaml</code>命令，其中<code>dashboard-user-role.yaml</code>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: ClusterRoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io&#x2F;v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: admin</span><br><span class="line">  annotations:</span><br><span class="line">    rbac.authorization.kubernetes.io&#x2F;autoupdate: &quot;true&quot;</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin</span><br><span class="line">  namespace: kube-system</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    kubernetes.io&#x2F;cluster-service: &quot;true&quot;</span><br><span class="line">    addonmanager.kubernetes.io&#x2F;mode: Reconcile</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取登陆dashboard的token</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl describe secret&#x2F;$(kubectl get secret -nkube-system |grep admin|awk &#39;&#123;print $1&#125;&#39;) -nkube-system</span><br></pre></td></tr></table></figure>

<p>该语句返回的结果中会包含token</p>
</li>
<li><p>登陆</p>
<p>在其他机器浏览器访问<code>https://master的ip:暴露端口</code>，比如我的例子中就是<code>https://10.0.0.23:30502</code>。登陆时选择token登陆，粘贴上面命令返回的token就可以成功登陆。</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/DevOps/k8s/k8s_dashboard.png" alt="image-20190623211428221"></p>
</li>
</ol>
<h2 id="部署官方用例"><a href="#部署官方用例" class="headerlink" title="部署官方用例"></a>部署官方用例</h2><p>官方给出了用于测试的用例，如果k8s部署正确的话，可以直接通过下面的两条命令部署：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create namespace sock-shop</span><br><span class="line"></span><br><span class="line">kubectl apply -n sock-shop -f &quot;https:&#x2F;&#x2F;github.com&#x2F;microservices-demo&#x2F;microservices-demo&#x2F;blob&#x2F;master&#x2F;deploy&#x2F;kubernetes&#x2F;complete-demo.yaml?raw&#x3D;true&quot;</span><br></pre></td></tr></table></figure>

<p><code>kubectl edit service  front-end --namespace=sock-shop</code>来编辑服务的配置，主要是端口。</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/DevOps/k8s/kubectl_edit_service_2.png" alt="image-20190624073309186"></p>
<p>部署完成后通过<code>NodePort:端口</code>可以直接访问，是一个袜子购物网站，支持购物车等功能：</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/DevOps/k8s/sock_shop.png" alt="image-20190624073545125"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>k8s dashboard官方：<a href="https://github.com/kubernetes/dashboard#kubernetes-dashboard" target="_blank" rel="noopener">https://github.com/kubernetes/dashboard#kubernetes-dashboard</a></li>
<li>K8s heapster官方：<a href="https://github.com/kubernetes-retired/heapster" target="_blank" rel="noopener">https://github.com/kubernetes-retired/heapster</a></li>
</ol>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>安装kubelet、kubeadm和kubectl</title>
    <url>/chinese/2019/06/24/%E5%AE%89%E8%A3%85kubelet%E3%80%81kubeadm%E5%92%8Ckubectl/</url>
    <content><![CDATA[<h1 id="通过kubeadm部署k8s-cluster"><a href="#通过kubeadm部署k8s-cluster" class="headerlink" title="通过kubeadm部署k8s cluster"></a>通过kubeadm部署k8s cluster</h1><p>Kubeadm 是一个工具，通过提供 <code>kubeadm init</code> 和 <code>kubeadm join</code> 来作为创建 Kubernetes 集群的最佳实践“快速路径”。</p>
<h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><p>我在配置时一共使用了4台内存为16G，有4个CPU的服务器，它们的配置相同，具体如下：</p>
<p>操作系统：Ubuntu 16.04.6 LTS</p>
<p>内核版本：4.4.0-146-generic</p>
<p>架构：amd64</p>
<p>docker版本：18.9.5/18.9.6</p>
<p>Kubelet版本：v1.15.0</p>
<table>
<thead>
<tr>
<th align="center">主机名</th>
<th align="center">内部ip</th>
<th align="center">角色</th>
</tr>
</thead>
<tbody><tr>
<td align="center">master</td>
<td align="center">10.0.0.23</td>
<td align="center">kubernetes主节点</td>
</tr>
<tr>
<td align="center">node1</td>
<td align="center">10.0.0.66</td>
<td align="center">kubernetes从节点</td>
</tr>
<tr>
<td align="center">node2</td>
<td align="center">10.0.0.53</td>
<td align="center">kubernetes从节点</td>
</tr>
<tr>
<td align="center">Slaver03</td>
<td align="center">10.0.0.69</td>
<td align="center">kubernetes从节点</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a>硬件要求</h2><ol>
<li>一台或多台运行Ubuntu 16.04+, CentOS 7 或 HypriotOS v1.0.1+</li>
<li>每台机器1GB 或者更多内存，太少可能无法运行你的应用。</li>
<li>集群中完整的网络连接，公网或者私网都可以。</li>
</ol>
<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>官方提供了安装脚本，在root模式下一条命令即可完成安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -s https:&#x2F;&#x2F;get.docker.com&#x2F; | sudo sh</span><br></pre></td></tr></table></figure>

<p>在我安装时<code>https://get.docker.com/</code>没有被墙，如果被墙，也可以替换为国内镜像。我知道的国内镜像有：</p>
<ul>
<li>阿里云的镜像：<a href="http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/intranet" target="_blank" rel="noopener">http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/intranet</a></li>
<li>Daocloud的镜像： <a href="https://get.daocloud.io/docker" target="_blank" rel="noopener">https://get.daocloud.io/docker</a></li>
</ul>
<h2 id="防火墙SELINUX及swap"><a href="#防火墙SELINUX及swap" class="headerlink" title="防火墙SELINUX及swap"></a>防火墙SELINUX及swap</h2><p>我查到的教程里都要求关闭防火墙、禁用SELINUX和swap。但是因为我在配置过程中调过很多参数，很多命令都是了一下，所以也不清楚是不是真的必要，现在都写下来，如果没做出了问题，可以参考：</p>
<ol>
<li><p>关闭防火墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl disable firewalld.service </span><br><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁用SELINUX</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁用swap</p>
<p>这歌是要在所有节点做</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="安装kubelet、kubeadm-和-kubectl"><a href="#安装kubelet、kubeadm-和-kubectl" class="headerlink" title="安装kubelet、kubeadm 和 kubectl"></a>安装kubelet、kubeadm 和 kubectl</h2><p>kubernetes的国外安装其实非常简单，国内安装的主要问题在于kubernetes部件所需的官方镜像在 <a href="https://link.zhihu.com/?target=http%3A//gcr.io">http://gcr.io</a>(Google Cloud Container Registry)上，很不幸，这个网站被墙了。所以解决了这个问题，国内环境的安装也就简单了。</p>
<p>解决方法也很简单，用国内的一个景象来替换掉官方景象就可以了。以Ubuntu为例，替换方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;&#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.list</span><br><span class="line">deb 国内镜像链接 kubernetes-xenial main</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>目前我知道的国内还能用的景象是阿里的：<a href="https://mirrors.aliyun.com/kubernetes/apt/" target="_blank" rel="noopener">https://mirrors.aliyun.com/kubernetes/apt/</a></p>
<p>所以将官方镜像替换为阿里镜像的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;&#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.list</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;apt&#x2F; kubernetes-xenial main</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>替换完整后执行下面两条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install -y kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure>

<p>执行第2条命令的时候可能会出现警告：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WARNING: The following packages cannot be authenticated!</span><br><span class="line">  cri-tools kubernetes-cni kubelet kubectl kubeadm</span><br><span class="line">E: There were unauthenticated packages and -y was used without --allow-unauthenticated</span><br></pre></td></tr></table></figure>

<p>只需要将第二条命令改为<code>apt-get install -y kubelet kubeadm kubectl --allow-unauthenticated</code>就可以了。</p>
<h2 id="初始化master"><a href="#初始化master" class="headerlink" title="初始化master"></a>初始化master</h2><p>初始化master本身也很简单，只需要一条语句<code>kubeadm init</code>，但是因为墙的原因，又一次变得复杂。由于官方镜像地址被墙，所以我们需要首先获取所需镜像以及它们的版本。然后从国内镜像站获取。</p>
<p>首先通过<code>kubeadm config images list</code>获取完成<code>kubeadm init</code>需要的一些镜像，这些镜像本来需要从google的服务器pull，现在我们从国内镜像中下载下来然后更改它们的tag，使得<code>kubeadm init</code>知道需要的镜像已经下载完成，然后在执行<code>kubeadm init</code>就可以不用pull，直接顺利完成。</p>
<p>下面是我使用<code>kubeadm config images list</code>获取的需要的镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">k8s.gcr.io&#x2F;kube-apiserver:v1.15.0</span><br><span class="line">k8s.gcr.io&#x2F;kube-controller-manager:v1.15.0</span><br><span class="line">k8s.gcr.io&#x2F;kube-scheduler:v1.15.0</span><br><span class="line">k8s.gcr.io&#x2F;kube-proxy:v1.15.0</span><br><span class="line">k8s.gcr.io&#x2F;pause:3.1</span><br><span class="line">k8s.gcr.io&#x2F;etcd:3.3.10</span><br><span class="line">k8s.gcr.io&#x2F;coredns:1.3.1</span><br></pre></td></tr></table></figure>

<p>国内镜像仓库我知道的有两个，dockerhub的：<code>mirrorgooglecontainers/</code> 和阿里的：<code>registry.cn-hangzhou.aliyuncs.com</code></p>
<p>可以直接通过<code>docker pull 镜像仓库地址/需要的镜像</code>下载，然后通过<code>docker tag 原标签 需要的标签</code>将镜像的标签改为<code>kubeadm init</code>需要的标签就可以了，针对上面列出的我需要的镜像，下面这些命令完成了镜像的下载和标签更改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull mirrorgooglecontainers&#x2F;kube-apiserver:v1.15.0</span><br><span class="line">docker tag mirrorgooglecontainers&#x2F;kube-apiserver:v1.15.0 k8s.gcr.io&#x2F;kube-apiserver:v1.15.0</span><br><span class="line">docker pull mirrorgooglecontainers&#x2F;kube-controller-manager:v1.15.0</span><br><span class="line">docker tag mirrorgooglecontainers&#x2F;kube-controller-manager:v1.15.0 k8s.gcr.io&#x2F;kube-controller-manager:v1.15.0</span><br><span class="line">docker pull mirrorgooglecontainers&#x2F;kube-scheduler:v1.15.0</span><br><span class="line">docker tag mirrorgooglecontainers&#x2F;kube-scheduler:v1.15.0 k8s.gcr.io&#x2F;kube-scheduler:v1.15.0</span><br><span class="line">docker pull mirrorgooglecontainers&#x2F;kube-proxy:v1.15.0</span><br><span class="line">docker tag mirrorgooglecontainers&#x2F;kube-proxy:v1.15.0 k8s.gcr.io&#x2F;kube-proxy:v1.15.0</span><br><span class="line">docker pull mirrorgooglecontainers&#x2F;pause:3.1</span><br><span class="line">docker tag mirrorgooglecontainers&#x2F;pause:3.1 k8s.gcr.io&#x2F;pause:3.1</span><br><span class="line">docker pull mirrorgooglecontainers&#x2F;etcd:3.3.10</span><br><span class="line">docker tag mirrorgooglecontainers&#x2F;etcd:3.3.10 k8s.gcr.io&#x2F;etcd:3.3.10</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;coredns:1.3.1</span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com&#x2F;coredns:1.3.1 k8s.gcr.io&#x2F;coredns:1.3.1</span><br></pre></td></tr></table></figure>

<p>上面的命令完成后，<code>kubeadm init</code>命令就可以顺利完成了。</p>
<p>接下来的安装变得简单起来，可以参考官网文档中<a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/" target="_blank" rel="noopener">利用kubeadm 建立一个集群</a>。</p>
<p>步骤就是</p>
<ol>
<li><p>初始化master</p>
<p>就是刚刚说的<code>kubeadm init</code>这条语句，不过受下面一步的影响，需要不同参数，所以先不要急着执行，先看完。</p>
</li>
<li><p>安装网络插件</p>
<p>使得各个pod之间可以通信，有多种选择，每中网络插件支持的架构有所不同，我选了<em>Weave Net<em>，</em>Weave Net</em> 只能在<code>amd64</code>, <code>arm</code> 和 <code>arm64</code> 上运行。可以通过下面两条命令完成安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export kubever&#x3D;$(kubectl version | base64 | tr -d &#39;\n&#39;)</span><br><span class="line">kubectl apply -f &quot;https:&#x2F;&#x2F;cloud.weave.works&#x2F;k8s&#x2F;net?k8s-version&#x3D;$kubever&quot;</span><br></pre></td></tr></table></figure>

<p>安装后通过<code>kubectl get pods --all-namespaces</code>命令查看各个pod的状态，如果都是Runing，就可以开始添加从节点了。</p>
<p>注：如果选择<em>Calico</em>、<em>flannel</em>，为了可以让网络协议正确运行，必须在执行<code>kubeadm init</code>时添加参数<code>--pod-network-cidr=192.168.0.0/16</code></p>
</li>
<li><p>添加从节点</p>
<p>在执行<code>kubeadm init</code>的返回结果末尾会给出<code>kubeadm join --token &lt;token&gt; &lt;master-ip&gt;:&lt;master-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</code>格式的命令，直接复制在自节点root模式下执行就可以完成加入。都加入完成过一分钟返回master通过<code>kubectl get nodes</code>查看所有节点的状态。显示应该如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME       STATUS   ROLES    AGE   VERSION</span><br><span class="line">master     Ready    master   49m   v1.15.0</span><br><span class="line">node1      Ready    &lt;none&gt;   32m   v1.15.0</span><br><span class="line">node2      Ready    &lt;none&gt;   47m   v1.15.0</span><br><span class="line">slaver03   Ready    &lt;none&gt;   17m   v1.15.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果需要的话，删除节点</p>
<p>删除节点之前一定要“排干”节点，也就是将该节点中的pod转移到其他node。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl drain &lt;node name&gt; --delete-local-data --force --ignore-daemonsets</span><br></pre></td></tr></table></figure>

<p>排干后就可以删除了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl delete node &lt;node name&gt;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="其他一些不重要的点"><a href="#其他一些不重要的点" class="headerlink" title="其他一些不重要的点"></a>其他一些不重要的点</h2><h3 id="初始化root密码"><a href="#初始化root密码" class="headerlink" title="初始化root密码"></a>初始化root密码</h3><p><code>sudo passwd root</code></p>
<h3 id="各节点间免密钥登陆"><a href="#各节点间免密钥登陆" class="headerlink" title="各节点间免密钥登陆"></a>各节点间免密钥登陆</h3><ol>
<li><p>生成密钥对（如果没有的话）</p>
<p>执行命令（需要确认的地方全部会车）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>这样就在<code>.ssh/</code>文件夹中生成了<code>id_rsa</code>和<code>id_rsa_pub</code>密钥对</p>
</li>
<li><p>将公钥加入到要登陆主机的<code>.ssh/authorized_keys</code></p>
<p>有两种方法</p>
<ol>
<li><p>通过<code>ssh-copy-id</code>命令</p>
<p>ssh-copy-id命令可以把本地的ssh公钥文件安装到远程主机对应的账户下</p>
<p>达到的功能：</p>
<p>ssh-copy-id - 将你的公共密钥填充到一个远程机器上的authorized_keys文件中。</p>
<p>使用方法：</p>
<p> <code>ssh-copy-id [-i [identity_file]] [user@]machine</code></p>
<p>比如<code>ssh-copy-id ubuntu@10.0.0.23</code></p>
</li>
<li><p>远程操作</p>
<p>可以通过<code>cat .ssh/id_rsa.pub | ssh ubuntu@10.0.0.23 &#39;cat &gt;&gt; .ssh/authorized_keys&#39;</code>达到和上述一样的目的。</p>
</li>
</ol>
</li>
<li><p>尝试登陆</p>
<p>ssh <a href="mailto:ubuntu@10.0.0.23">ubuntu@10.0.0.23</a></p>
</li>
</ol>
<h3 id="更改主机名称"><a href="#更改主机名称" class="headerlink" title="更改主机名称"></a>更改主机名称</h3><p>可以通过下面这个命令把主机名称修改为<code>new_host_name</code></p>
<p><code>hostnamectl --static set-hostname new_host_name</code></p>
<h2 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><ol>
<li><p>从节点加入成功，但是通过<code>kubectl get nodes</code>查看，master的STATUS处于Ready，但是从节点全部是NotReady。</p>
<p>这个坑我踩了很久才踩平，尝试过很多方法后发现，不光是kubelet、kubeadm 和 kubectl，连<code>kubeadm init</code>需要的那些镜像也需要在所有节点上安装。这样节点在介入后才能正常运行。</p>
</li>
<li><p>执行<code>kubeadm reset</code>重置后重新初始化时出错</p>
<p>重置后会有一些配置残留，主要是etcd集群留下的，删除<code>/var/lib/etcd</code>文件夹就可以重新初始化了。</p>
</li>
<li><p>coreDNS pod一直处于pending状态</p>
<p>可能是由于安装<strong>网络插件</strong>之前，<code>kubeadm init</code>需要的参数没有添加。</p>
</li>
<li><p>使用kubectl delete pods xxx删除对应的pod,提示删除成功，但是立马又回生成一个</p>
<p>要先删除对应deployment</p>
</li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>k8s官方文档：<a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/" target="_blank" rel="noopener">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/</a></li>
<li>参考安装教程1:<a href="https://www.codesheep.cn/2018/12/27/kubeadm-k8s1-13-1/" target="_blank" rel="noopener">程序羊</a> :sheep::sheep::sheep::sheep::sheep::sheep:</li>
<li>参考安装教程2:<a href="https://juejin.im/post/5b8a4536e51d4538c545645c#heading-14" target="_blank" rel="noopener">掘金作者Ethan_cn</a>:</li>
</ol>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>centos安装和配置Jenkins</title>
    <url>/chinese/2019/03/21/centos%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEJenkins/</url>
    <content><![CDATA[<h1 id="centOS-安装配置Jenkins"><a href="#centOS-安装配置Jenkins" class="headerlink" title="centOS 安装配置Jenkins"></a>centOS 安装配置Jenkins</h1><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARUAAAC2CAMAAADAz+kkAAAB0VBMVEX////+/v4AAAD///0AAAG5u7y5u7373L///f/3PDn+3L4dWGzi4+JtbW3Qz9B1dXXHx8e1tLchISGfn6AZWmwXFhj29vb73sDp6enk4+ba2todWG373r3x8fHBwMLc3NyqqqqFhYVOTk5nZ2eTk5MOAABbW1v6PDKXl5dpaWkxMTH/7tX/584oKChCQkL7TEwREREbFRP/993yQDb/6NEbAABGR0coAAD27tr/8tBHQj0iAAB7Ki3//+oqgpkmJiaCws4lVFxyu88dDBIBDxFhfoYZWHUpU2IQABxKUluQw9dyutGIp7YACBodKzg7coU8ip+GMSxFERC6QkBcGhrqSketPzgkAhWXLi/7UV0lcYUMHS0AHxcPXWkPLTZUZnOLzt93kp8jP0vIUFfYUVAAEQYzdpUhNTR1lpaRSkk4AAnhTkak0eRGX1+7OTMzEQsAHiP6OUUpRktqGhSHLTRKDQCSPzlcABWCJjB9rbUyRkavOUE4bHqNJyTjVUEUPEAWACETHwpFGyQ5gYrWXWIdFyQjHxENJiMbMUUpSF+OjHnQyq8vBxhSS0B8cV+xrZ7NwKZsGRPtZF5/eW3Ir5JsaHJkLTI8LyainYxRHBQcHzj2Dc87AAAcaklEQVR4nO2di18bx7WAdwfJkozQE60WSYveC3oiIQES2GBbBBontjGvOOGapARwa1rbeTS3uXaatinXsblCtPTW5P6198zMPqXFL2zhLj4/G9BoX/PpnDPnnJldMcPWd0HOkX+a1+fg32mJdZixMu+lXayYSs9pXwXDdrT0nKJQKp3X1HURQt5UvC+T6Yv7B6Mc8y5QOU1h4SPhY2LWghQpFd0eFhT4rFLpASSsx11A6d1foWfJeCp1mJxMYzLjXpZhzygVgOJJIBTwNZDoql0kUqu1DgvARXSemrKctgWFkgglYwWU8NRquWq1ms/nq7nRi3xrEqHy4GlhOV0qvBtZUrzg9rV6alUiQUlyoy3wNF7mdKzo9KiwPUwMoZTAxcBWMBMbFkzEFoyA1GsiQjEaNJwZKiwjJFGCZ2IJNAyKks8DDdv58xGiKZEI/mu0D2FtOUNUAEoWxZnQ/7qRtaeay9swEvgXDJ6PABn42xa01ZoIec4SFYYdR34Yf+LlVg/4WBuhIkkQ/wAowWAtWyoJpxC4nBqVYTTMuPriYvwiZWIDo8H/VTZgSKPOUjoBQc1ZocIFknyskC1mL+byQRu2l+DoaM6mpRKp1lqteBpsqNtQTocKjCt+lC2hUmImczGPvawtCLHb/lFOtSMYiGoQ36FyQzwjVBjGjQIoOShwflQj9hOse7KAYL+uaout3moePZ1EDcSfEb8yjEoFD+fyuzOYCvjV2h4gabWOYHw+b5MtyJbL12tHJGg5C1QEFMjyA/Fkn7sP1SKgKvlaubCXq+frERypBLXeJddCYtcD3FOhAjEt7xLdIBKVXBztVW0QqZwHzxuUqOC/wOdA0NL17PlUqCSRW0hiKO5kOhfEXmXyqB7BIxEdkmUbCmJAwQMU7bYJdZ8KyzBF5PETKO5iM0fitaNqJIhjlkgwcp5ELzbiWbAEqzS+Jft2SbpOBU7JBlCIqkq88DSHQ/tg1YZVxhbJHVYhAYLgJW+LYEbBf7byVXC3JqeCK8RRhFwZSsV3EKSBLUERDF6MH0RwRBf55x7WlWC9NjmaG0uZnQqIC0KQQUlXAnvnJSpYMYL5nEfMRXAt4eiwjhtytcmD+rO42amAI0OlMjrXFydYSjWSHEeoBwnm8xcnW3VsUnswOGFKtVjz4qTFZWYquG7vQel//Qt5RFHMAJhSlfgT7FfBXvIQtrnQAR6PRxuHOWjZ24uhwf0GCsEoZFYqIK5G4+//uLCLw3s00xf37UVsGAKmYrMdtFzVUHYShzC5I7RXr+/DVo29/caWb4BiNSEVPPGTTS//Y/P+LhKH/SIqx4stoiv0f/UpJIMIHeawwx2deVbL7zWbR7XR/b/+YikKJqWCx2QRLW6OfLuFWjhWiqPJzGH9vI0OQ0Ai/7Q52Xyai2Aq+T0kjuZzuVykLi5/+T+oz7xU4mhiaWRnER0xrabbKRRmMs9GpaiNjEQAIZcngVwwUj9CT+ukUfz7yMMp5DcpFRiTS7dGHDtT6KJLnEG+2iG4jZyGiqQyEVLPjsDbuOBiyyV+GFr5Nl0KmZIKwxZnl1ccjp0x8eJerdxKHB409w/yNsWCZCpkRILcsN5ErSpQyd6sVHaWLSJrQiosM4ymNh0VoJK5mD9oju49q+XqeQ0S+c/zBAr8rGVRK2+rotXKUGVpCgJ/HBmzdrvdPFQYobS1OuJwOFbuFoDKYS5/VLV1mA/JC3EahKU6iPZzQOVexVGp/ICynKwsbxtL16iw4GoXwX4cjk+XUc22dwjdJTNjHRIJ5nKUSs6DjvK2PbQzVKlUNu+Dw8VZPmMiKgyH0MPKkGPI8dW3KJXPH2DbCUY6oQQj1aMappUHG4O4P380tQKqMlS5NevjJMJmocIyfrT8KTAB2ZxCNVpna9cV0hSsTjrzkAG1JtF+LR/JZf4T251jaOe+XFJ4y0y6aUE+y0PSO3As36BmDQ+9B23DD3513hbJNydbrcM0au7l8rl/1tC3eL+hoZGbqNgdKN2igrPCqU2iKY7K0ObUteZeDeKRg3q7Y4nggvZeufxMPNqrg77MHHjQl5UhgmVzDLJEM1HBM0AXJFWpDI18ObGFsjPocFQPJQ8B7eFBPT+KVz3lcntgQ08vHk7tVCjOkW9QiukxExVsQA5FRna+GbPMFgVpilmO3qr5evUQlZ81m6LYrDZxplirbX2zQtxRxeFYtRTMRcWFJv6hUoExZelCepKTqAQlP5urNmujLbFBFlKGGsh3lKu30C0HddLgpieQkzEPFTwCfTPi0Mnm/RknpRI5CNJqQj53GK/Xq6HW0eF+s3rUqlXP1ycnNpVdVpbJKh+zUMFTQLf0VIZWFlGLTjLXm7kgrbFERsVDnDfnRkdH87l8JJJvoZsj2Hio4V2wuJluZENdosJl00t6VXHAQHt4MY+Tw3orWaPRS9BWe4b2jw72iAQj+Vrh7uaQDMVRWSVjs2mo8Ghss41KZXNqpoZNKBjJTR7lpCVxdYhnJTkInofB+9bKkLrLPYS4biTOXaLiQnd32qk4fgATquLCQbCGPDky9QEOJtfabzabh2BdQbCfv27iHEi2up00uFvzULFKmaF2FKps3s32VDEIW/UAuWo2KSnK1+ujo7kcON9auTy1VFEtCAf9LhNRiaHlkQ4q0EdrjeTNERiAPTllhpnMw0eqtcl0uTyxqmLBHtpqIirDSmRLeoeprCz98kkDKwsGEcm1UGuUzL5HyJJByJhbjU/WPl/zjX1XkT3L0MgyLj2ZhkpKRwX6V9m8OVEulVBfD1mkbjsPWJrVXFBahFzP7TVR4/pP09tr5cbNncpZoDJUWbm1WLp2/dF8A2Wco3WsILmaJ5E+3KvX6zmcFTZRyRe4Mz+9vb3W2LrwpyHTU4HscHUxXdq4sTC9PV+ylJutA0ignxayk7sNNLn/9Ok+zoB8vq2tdPrrhekbD7ZmpcqM2aiofgWG2Z2bY+n/e7SwDbKw0Uj7i4VsIYvu/zJVCjTGyj6E0pOpeHpqeenLxWvh6YXp9XTgwopKBYs5qPhlKpXKysP7pdLl6elpTGW7fx35OY53in/YHNlcXZ7YmmmB4tRas4tLnzpGHqafzG0vLGwEPrknW5DXRFTwyEx8w8rmhdLW40cL01g+C4f7+5+golfgxnGaVIF3x1Ai/nQf3VzBprZzf2Nubm564cEnS/LI7DERFQ+6S2xg5+ZU4NrXPxEk/eHwXBjLjwglSg9HhvAGI0vfTEz8cXnibyPgkys7v2zM9fb331i/S4ahoZ0JWo0zCRUnauwM4YrtVmMXexRg0t/fS5j0hvtvb6zN4qIu7vnI3/713aeb95fvVcDBrixvgDqFw2vL1K/sjCHBRFQ4X/oe9OtPi7vXb2CPMjd3+zbFAqoAf15+/N0ICUqG7l2YujCys/gdGFwFKG6Ee3vnnly75RjCEe692QK999ocVFgR3cKf9t/R/Pb0NjGcfqwtvf1EwnPrtyQqlZEvF1cvoO9WKtiPLM+Hgd3G2A4euxwj36IkveXOHFQgYMGJ0MgPjbXt6ek5iqUXqIDA73B44xtaMQCV+A6hD93oP/94a/XeamMev3/9D3ierIJrcX4z6QoziCZ2wHEsNRrh6WnqT6iaEH0J919e3KHTGys3ZwedAucaB6+8gf5yGejNW25+BUwg0MHOln37ULpGhbOU8OA6shz4eWH7M4kK4YGxQNcfrDq++srh2FxGJRfPOzk288EXVz9eW3sSDs/jOh4436GlLdSdNSxdmw9K0hBkNR24sf3ZnJYKtiVsQpAJbD6c+PDjx1ne7ksx4geXPrr68bXe/rkfF4lbGVq5gNzdWcLSNSpedPdPQGXnLo5rqQlhJemVR+j5iaV7PyyiX1+99D1KMVGBSfz6ykdXP//xdnjuwR/poL05ATGcqaj0cAitQtdWLpTXF6b7Zb8Snru90U9e3f4xnS6h7y9dufLF79M87FH8/spH369BMDOPiAFB/I9murTcqStUyM0lcToKPSzP3pj+rJeOQZhK6VE/CeXCGxvoNwDlyhVQFjbBF76/8sV/fQ2h7Tr4aeyJV34BJaJUTDEGESpONLYEn/jOYukRodJLfMpc/+yjaWxNMFr/XPwdhnLl0udlIcE3vr/06/XbQG/tJkT/kA48HCvxjN1cVHoYMQ1xO15vsbEwHe6lzrYXqNzAVADP/K8+vHoJlOWjjz7Gtxpeu3rp+m0cyVhWcXAHwUqa+Fp8wLcMpZtUQqAsDsdXS2PXwbH0EyjYpaxhKuH+ufDlUmP2A8Dy0ZVLHxYYfv13v3/S3z/XfwfyStCUkVuo7JQPaB4qPUwmvQweYmcRtIMiwT8wlV6aI85f301vfXD16hUYhlyu33/8AEKZ8HzppmNoZOXerftoGM+mdoFJV6n0CJbSDyNDI8sWoBLulZKg8Nr0NHQ+jHPEufn1QBp9/v0XX/yHGPv19ctgQL0bY19+uro8VUIo7RvsSrjfLSrUGeDnrXwCDveWpXeaRLckRQyvgT31Ki+frJfT6M5vPkCF8Q08Ys9f++W3d9NbCPkHRYS6dedHl6hgIQ73/qZjCW1Mf0brTeGNy7fXbmxr0iLIiO74dlFj95PAhxsgj8uNMYTEGF49GcehrXmoyOMpwxeuLa/cS68vKFR2N2aByvzly19vrIM8eDA7Gwg0GuVdkEBgNx3wlWaGcVDH9TBcIM2pkM1ChbUzHmS5+be7uwvYwYYhRJnf/XPg+vVr9FlxjWyxmBgfL2bBiez++ZPZv5SyYhYlgYQz5Y72sKAsVjNSsYNrSf/2r9duEFcyF16fnd0FfRhPxmODIV4QOCKCEIqhJzdubMCo40Rxho1nwYLAAAdR0oRUsNsdRqXyLqXS++jRo59+euIWOGVD6dGPAoceTW/Pgx9hMkXG5ecFXgAqAkJ281HB52NSqJwmVPB4fOOz6bC7rZ8wWvFc+dH09DwS8bjFMXxGFN0e2CyLXCalAljSj7ZxcTJM/s8n6M138gaEijA5/1n/E0tWgIjYychhPuMmU4fmo4I7GEf927Rki2Pa+SxrQCXxMyRGgYCT4UA9uNiw38qz8BtnzSakAn+BUcxTXQkTNGAijJ4K4xTEjbn+Xh9e2eSzMoLV6vV6eYa3mlhXvBIVoi29YRTVdlSi0rcOId0M8oIviYGrJcOTwPvJhKr5qNh78CK5jQXZr4BcG9Q5HkrFvX67v/8xSgl8cZjjMRY+GrKLWK/MSIXFVL5egNheVpY1v7afChVIqe+k+xiuKHr9KXcyk4pyVpRhTEkFn3IQPX4Upikz1pd13XprQmWATz2A4PdOoxina29Tg1FO8CNsbGal4kL/Xbr+BOL9flLm30i0XRJQGfA/gPfvNNKJmIvn4iiRGJ9B+Fmd5ssOlV5nULoc+PlJmNTier/26dZb4+iVH7BaNq5ff1zy4cSQYa3Dcbc7BaOQmeoreipgJC53CQWAC50MQgPtVISoC2eLpeIgviHVbtcfzZxUsLoMxH1od3f968uXb9/GK4s1/phQCaFYNAnhih1Dsdt1j8Y3KxVSa0kVUKMR8D2+s5Vi9G8xXDSKGC6lW55+FqjYyVP4EwE8wJRFu2YMwsKFnIgb8IIS0bv/Ow5oVirUWzjPpeLxsk8woCIMhHBtRWmkpiQZk0mpUDT03QSuD+iosFEeqAgF0a42ng0quGfkCVaMH/n1usLaowLio5wY4Bm1UbeFWamwpGKJJYTE9sITUBmIcm68tOk05F2gwmYDQhuVAQ4NsPYkTpG7AKFD3gEquMTWtlqH4blCJolQiT+7usJ4lMFGviqBw8/MTnTldjoDeSeoCNkixzJSoZLkOgKfQX6B7cKjVgzlnaBCTIgKfiijnYPxJ4YGma7c0W0k7waVQeQTU4MDdGLILvBRjz9B7o8601QE8lzKQDYhZvqSYqLog1eWKLal7tKQ5VSpqAlOKCVmA5ovJvNl+0jZ7Sz6FQUKcbBO16A3FvPHvIOukFOQZlfPJhX62/j7FtluPATN+LpOkwojJ4MsHZDJZnblTZoMnoacNpXnthhAMdHa7OO9bdvFMGzPc7VDjmBMnTO3i10ym+dcrmR1b6bzx5/mnaJif5EvYboC5Z2hom77Mtu9oc4ff5bTpiKFJZzA885oyOWxCsd1GusQw4a81pD9bUe9p06FZTzJZGK8mC34SiSu9R7bYUgQPEUkVRjMTsWPdOI9VlXsjFfe6C3fU/YOUHG5E5ANWiQ5lgquW0qbIeR7u0W6F1KJuQ2kL/TmqGC/wscVLEDl2HmSFFKw+E+XSh8yEs9z93kVKlLUn3gxFZYVZSoW/KUFbwOHfFEvouLPdjIpiG9UV7AaWJX+Hm9BWipupueNs9Bc0guowAfJedxaJAmP8GpInk+FMLArLuM5VHQW9HYfZPRCKkTBXZqCkMTqTVGRLsOpoWLcYUgHBIkKwg+hP1ULopJQqPS9MpJXpmK8CZ5glj+dt/3tFi9JRbUh96szeTNUcOLIOJPkGvi3HPS/JJW+d4MKqIsQir79NbddoaI5nzxytHVL71eO2ZelBZZXdGvavelppWuwkxT9NKkoUzt2FYjueo+noistyHd2vtLJ9VwYzamPw9IdC1I+Jm1Zv0NXkBEVhqyKksu4r3Vuva5oL6Dt/TdJhc4LO6NRJy/Ir7W/tZdHNuV5PEmoi8I6dKVzZ8MOM/rZAWkjDk7BY+/TducZfRNfAC9QIs4BIyhvRFd4f1IKgLNJv3LXPqmZOHHFJOYfjrszhJgQy5BNi24X81wLslvPWa3Wc+fO4R/Wcy5ytIGoy3MOjpaKZ1zKKXDjoBefgk6scdY+copsxmOXvJBKhY+5i2Q2biYRt/J4pDdcN3RyKqG2TCkTld4QSrp2vOpiWNPUJ2hqR526oj9oknEGdIejXyLKFnWNeFfvjPp6nK7sVk7Cx9uOKiLjZyuflAonncjtiloL0iZ+iYr+EkKMkNA1jHOaC9ZTAVxZ0l8SyBIIUSS9plvRc7Az2la8ELVP+xohXr17j+RaRMTYOW/cR/c0rtSckAovmU6MvPBJ29DvPWVdsaIGQpTX6w491PF+hXWNS1AyHuBnd/mLOipklA7FRNo5sukgJ51Q2ayoUMFPCMUOHVmkzNZLXxo+cfokVEAlpcYMPXFM3mhY3iSlMsB1tEDSLcqvLUiz6q3Tr5D7iIia0PvdseMcVNWA6gputCIlZST5vehOarAoWST2IWQjq3xrgJBFxwWNJ9IVVrYZmpYwvLKsICoPBwmNbmRJVYYflz9O8BbscVR6WHyfLvAWGDq0kHHZ30aF1HLjGosJkL3ZpNJUpAMw/C/QgT/AyxrKgGYRbAbr6U9CRW7NSmMiN96xlRfp92RlBcNXWBCO9yuMHbSqZKVz8FJHsKvSUSE65FI1KCEwePKR4bLyduBZaJAjbYVK6iCJT4pN8U1SYdX6gpuRLl7djJe28igtohJOuGUqSEl9O2NbXGISoUv2Hmk3HIPZO6kwmtLMuEDdSI9GqazS6OyXixDynlhi2I+/UQtiGcVFKG5EHfnkg6pU1PJdTKHikWO5Tm8LphdnmbZwlu2gwmipUM/ZY2dV/ZEKvIxiZwivt1OON4MfXvJGLcjZgUDjXOWv39ZSsUvW4FGoDB7nbfHC0hh4F7s+ptXqivJGOxV8uIGS3DYsORGN9xE98nfhMV7RzxitfHh9KsNKm1LbVqd2kgZU5HWjrmOoqHmQAIMyvc1dokGvXKaCCBW5cQDJg5CGSkBLxa5YkDTWZ+ODvF06vOF6kNenklDbhlOpVBxEbUqwBlRoynwsFUVXpChIvaNbzhB1uiI3duiKvYMKy2h8Mg0MS6KfRr5GefMJ/Ep7UKYTQyqSib+ISpQEEggPUW23zdvb3AXLGlHBh2ujAg64pFKRwcQHyPHfpF/RBPS+DgmIBlQY6eae51Oxhkqymbh1qwVBMzqp2O3GfkVDRXp8Eo5lLXp9weOE4YKZY6lE/fGUV3lcjAEVXqXiYbkOYY6h8kJdiSvTq8SNq5f6ulQksKQPOnXBZ6D+72WpSOVrj+TwXkCFkY8tn6GHlW4r7aTCPp+KBakXr7/n44RUWNIni04QGSw71zccQ8Wtdvg4KhoLkgMvRl/MeC0qEFdpB1HN53gyKmRJg6WdC0KGT/8xpqL2pcgeZ0GM6m2HdTvT4x5DhX0hlRROgJSLjtGnLOKevTYVqsT4B0ezeB2XPoPg1piKZgqVPr47o7xOKRsllDbRQNs6+L4sFSu+5U5RHCnPPCkVRgjR5xIyvFR7UKgEDAYhQypqlif7DCW4V+NYTSA7o60Sn5QKNsdhlUqC6t+JqDC4yGFRrpCzajwMQkLndJUxFc06BJq+FJTXvLKVZvK5beEG5MUno8KOqxc9fHIqdFyOydeEayspVR2FThMypqLW0MaJ/qqetaipvqsV0mTbAVylmHFs+1wqasSP65EKFvy5UAKYCpKpyHMGuohfTsH1sS2Dn/mC5G8CpymnvDTk5amwqsFQLRjUGJA6saGU3kjyq9EUZ0EZl4xyZqpkmvS1gworlQIIu6KUWNtZmQpqz5nVPIgqlo6KdB0WJWOlpbg+aaesvXMljLG3VVyGdHKFUlG3mWpoJV7TDBE7ErkXULFok3qD+kpRVZaUNIjYDeorbVSoibKdVMg5vcrpYKOUtFP8pcegqNSTlPbD1XdNuxlIQHEtLC6kZjurTi4DKuplOqU2i2z+IaRavmx8Gipxo0qCV2lUqaTkw0mfgryOWSotkEHuJalIQ7N0gYJSjrUy2qGGVeYSsIixkMBx0VgC/vbRr1FmtHWouPwhKVUnC/VHxPZiimr0kWPjcqzSVCC1VsJYbgqohUZ11yQ5mrQMSUp1imQFA3yAbR8Dm6AtcaJfPS9FhY5C9ON1yRMams9CFg8ykiIvzTfwmho/ikdJpYPz+BQqSBzksG3wsZKqGRkXh6lwAdWGSv4oBz7fW5LrK5AM+AdwUmHHu0pZH3h9FzktFyoqR0PjVgGXFhCFlJRpppCUB1EO+gzxuDyI3h/ZF4ullPGoGDJYIsGLqEPiUjQZb38jy5EiG5KpkAv1S17bojDASiotOVbbAinNfhbSx6xU5tLuiSOHZHubm2RtFjpmJr0ulwdrtEVRYKo+L0FFN5WDxde+VkAWV0K/YZ+i252LUgVGKLS3pTRFPVmGScpU1LW5O7ZCHRcJAmcfb28TSdaWZLxt60HFKGNXxs6Xo8JwfqW/xbjrmI2IvkhT6hDkJmOaBZZOV7vACUPtbTzDe9qaPDyJKQT9dh1Hg2vqbASaHaeIQmfo3PyAX5ScpE+MSd6KZTvulTieClYszukaHPREBUYuExwreP0Bz+nbDHawP/cgml3bn3BlvJXBJqzRIhflOf74p+AMkXtg1T1edgySjvXqYsyOlXpJK8d2jZBZHi0BXEbtkUq8ZGu6P8t2VEFoN6UNlOPpjq409tA5Ef3VSa9ev0J5QpFvrGTkzmouuK23Wn2i9ZjnioaK0ob/aqOibm5wcadHRduNjn6xmm6wms+TfS4VnWIaHtOg6fkX110qr3BX8mue4WTH/reg8vJbv5oYHvvfhsqrywmPfUpUXv62FXqVPa8or3/s09SV03ncwWsLc64bVN6ap3hL0h1d+beT91SM5D0VI3lPxUjeUzGS91SM5D0VI3lPxUjeUzGS91SM5D0VI3lPxUjOMcPW99Iuw/8PIyBTGl8+RCIAAAAASUVORK5CYII=" alt="jenkins"></p>
<p>我是在阿里云的ECS上部署Jenkins的，ECS无法提供图形界面的显示，这带来了几个问题：</p>
<ol>
<li><p>文件下载和传输不方便<br>采用Xftp等ftp工具。</p>
</li>
<li><p>配置Jenkins要访问localhost，ECS上没办法使用浏览器</p>
<p>利用公网IP，在其他机器上访问和控制。</p>
</li>
</ol>
<a id="more"></a>

<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p><a href="https://jenkins.io/zh/doc/pipeline/tour/getting-started/" target="_blank" rel="noopener">官网</a>给出的依赖要求：</p>
<blockquote>
<p>第一次使用 Jenkins，您需要：</p>
<ul>
<li>机器要求：<ul>
<li>256 MB 内存，建议大于 512 MB</li>
<li>10 GB 的硬盘空间（用于 Jenkins 和 Docker 镜像）</li>
</ul>
</li>
<li>需要安装以下软件：<ul>
<li>Java 8 ( JRE 或者 JDK 都可以)</li>
<li><a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a> （导航到网站顶部的Get Docker链接以访问适合您平台的Docker下载）</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="安装java"><a href="#安装java" class="headerlink" title="安装java"></a>安装java</h3><ol>
<li><p>去<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">官网</a>下载相应版本，对于centos是 Linux x64的<code>.tar.gz</code>版本。（因为官方需要点击<em>Accept License Agreement</em>才能下载，利用<code>wget</code>是默认不同意，虽然可以下载，但是不能实现解压。）</p>
</li>
<li><p>利用xftp将下载的<code>.tar.gz</code>发送到CSE中，然后解压。</p>
</li>
<li><p>修改环境变量。<br><code>vim /etc/profile</code><br>在该文件末尾添加配置内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_HOME&#x3D;&#x2F;解压目录&#x2F;jdk1.8.0_161 </span><br><span class="line">export CLASSPATH&#x3D;$:CLASSPATH:$JAVA_HOME&#x2F;lib&#x2F; </span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用<code>source /etc/profile</code>重新加载配置文件</p>
</li>
<li><p>已经完成，可以利用<code>java -version</code>查看是否成功。</p>
</li>
</ol>
<h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>安装docker的教程很多，大家可以自行参考。这个给出<a href="http://www.runoob.com/docker/centos-docker-install.html" target="_blank" rel="noopener">菜鸟教程</a>的安装教程。</p>
<h2 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h2><h3 id="jenkins-war方法"><a href="#jenkins-war方法" class="headerlink" title="jenkins.war方法"></a>jenkins.war方法</h3><p><a href="http://mirrors.jenkins.io/war-stable/latest/jenkins.war" target="_blank" rel="noopener">直接下载jenkins.war</a>，然后传入ECS，利用命令<code>java -jar jenkins.war --httpPort=8080</code>启动命令。然后就可以通过ECS公网ip加8080端口访问并配置了。</p>
<p>不过这样存在的问题是，当你断开与ECS的连接时，服务就中断了。这是无法接受的。所以我们希望jenkins能够以服务的形式长久存在。</p>
<h3 id="服务方法"><a href="#服务方法" class="headerlink" title="服务方法"></a>服务方法</h3><p>利用yum安装jenkins，只需三行命令</p>
<ol>
<li><code>sudo wget -O /etc/yum.repos.d/jenkins.repo &lt;http://jenkins-ci.org/redhat/jenkins.repo&gt;</code></li>
<li><code>sudo rpm --import &lt;http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key&gt;</code></li>
<li><code>yum install jenkins</code></li>
</ol>
<p>安装完成后直接<code>sudo service jenkins start</code>是有问题的，需要配置一些东西。</p>
<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><h3 id="启动服务失败"><a href="#启动服务失败" class="headerlink" title="启动服务失败"></a>启动服务失败</h3><p>我直接启动后显示失败报错如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Starting jenkins (via systemctl):  Job for jenkins.service failed because the control process exited with error code. See &quot;systemctl status jenkins.service&quot; and &quot;journalctl -xe&quot; for details.</span><br><span class="line">                                                           [FAILED]</span><br></pre></td></tr></table></figure>

<p>出错是因为你的java地址和jenkins给出的默认路径不符，需要手动配置。</p>
<p>配置过程：</p>
<ol>
<li>编辑<code>/etc/init.d/jenkins</code></li>
<li>将你的java安装地址加入<code>candidates</code>中。如<code>/opt/oracle/product/java/jdk1.8.0_45/bin/java</code></li>
<li>重新启动服务<br><code>sudo service jenkins restart</code></li>
</ol>
<h3 id="启动服务成功但不能访问"><a href="#启动服务成功但不能访问" class="headerlink" title="启动服务成功但不能访问"></a>启动服务成功但不能访问</h3><p>完成这几步骤后服务成功启动，但是又出现了新的问题，就是利用ip和端口访问时出现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Jenkins Can&#39;t finish HTTP request</span><br></pre></td></tr></table></figure>

<p>利用<code>systemctl status jenkins</code>查看服务状态发现jenkins的状态出入<code>exited</code>，而不是<code>running</code>。</p>
<p>google了之后发现是jenkins的配置文件中关于用户的默认配置是’jenkins’，将用户改为’root’访问成功。</p>
<h2 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h2><p>至于Jenkins的入门配置，官方给出了教程，放出<a href="https://jenkins.io/zh/doc/pipeline/tour/hello-world/" target="_blank" rel="noopener">传送门</a>供大家参考。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Jenkins官方文档：<a href="https://www.runoob.com/docker/centos-docker-install.html" target="_blank" rel="noopener">https://www.runoob.com/docker/centos-docker-install.html</a></li>
<li>菜鸟教程：<a href="https://www.runoob.com/docker/centos-docker-install.html" target="_blank" rel="noopener">https://www.runoob.com/docker/centos-docker-install.html</a></li>
<li>java官网：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.006 Lecture 4 堆和堆排序</title>
    <url>/chinese/2019/02/27/MIT-6-006-Lecture-4-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="MIT-6-006-Lecture4-堆和堆排序"><a href="#MIT-6-006-Lecture4-堆和堆排序" class="headerlink" title="MIT 6.006 Lecture4 堆和堆排序"></a>MIT 6.006 Lecture4 堆和堆排序</h1><p>由优先级队列来引出堆，然后用堆来实现堆排序。</p>
<a id="more"></a>

<h2 id="优先级队列-Priority-Queue"><a href="#优先级队列-Priority-Queue" class="headerlink" title="优先级队列 Priority Queue"></a>优先级队列 Priority Queue</h2><p>优先级队列的维基定义：</p>
<blockquote>
<p>In computer science, a priority queue is an abstract data type which is like a regular queue or stack data structure, but where additionally each element has a “priority” associated with it. In a priority queue, an element with high priority is served before an element with low priority. </p>
<p>在计算机科学中，优先级队列是一种类似于普通队列或普通栈的抽象数据结构，但是每个元素都会有一个对应的“优先级”。在优先级队列中，优先级高的元素会被优先服务。</p>
</blockquote>
<p>MIT 6.006课程给出的定义：</p>
<blockquote>
<p>A data structure implementing a set S of elements, each associated with a key, supporting the following operations:</p>
<ul>
<li>insert(S,x): insert element x into set S</li>
<li>max(S): return element of S with largest key</li>
<li>extract_max(S): return element of S with largest key and remove it from S</li>
<li>increase_key(S,x,k): increase the value of element x’s key to new value k.(assumed to be as large as current value)</li>
</ul>
<p>优先级队列是一个数据结构，这个数据结构实现一个集合S，集合中的每个元素都对应一个关键词，而且这个数据结构支持下列操作：</p>
<ul>
<li>insert(S,x): 把元素x插入到集合S中</li>
<li>max(S): 返回集合S中有最大关键字的元素</li>
<li>extract_max(S): 返回集合S中有最大关键字的元素，并将其从集合中删除。</li>
<li>increase_key(S,x,k): 将x元素的关键词的值提升到k。</li>
</ul>
</blockquote>
<p><strong>优先级队列经常用堆来实现</strong>。</p>
<h2 id="堆-Heaps"><a href="#堆-Heaps" class="headerlink" title="堆 Heaps"></a>堆 Heaps</h2><h2 id="堆排序-Heapsort"><a href="#堆排序-Heapsort" class="headerlink" title="堆排序 Heapsort"></a>堆排序 Heapsort</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>MIT</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 53 Maximum SubArray</title>
    <url>/chinese/2019/02/26/leetcode-53-Maximum-SubArray/</url>
    <content><![CDATA[<h1 id="leetcode-53-Maximum-Subarray"><a href="#leetcode-53-Maximum-Subarray" class="headerlink" title="leetcode 53 Maximum Subarray"></a>leetcode 53 Maximum Subarray</h1><p><strong>最大子序列和</strong>问题是用于讲解<strong>分治策略</strong>的一个经典例题，这个例题可以帮助我们很好的理解分治策略。但对于这个问题，分治策略并不是最高效的算法。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个整数数组 <code>nums</code> ，找到<strong>其中一个</strong>具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],</p>
<p>输出: 6</p>
<p>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
</blockquote>
<a id="more"></a>

<h2 id="解体思路"><a href="#解体思路" class="headerlink" title="解体思路"></a>解体思路</h2><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>暴力法的思路很简单，就是尝试所有可能的子序列起始点，根据排列组合知识很容易知道一共有$A^2_n = n \times (n - 1)$种可能。遍历所有可能并找出最大和，时间复杂度为$\Theta(n^2)$。</p>
<h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>分治策略的思想就是递归的解决一个问题，《算法导论》中给出了分治策略的三个步骤：</p>
<ol>
<li>分解（Divide）：<br>将原问题划分为一些子问题，这些子问题和原问题一样，只不过规模更下。</li>
<li>解决（Conquer）：<br>递归地解决这些子问题，如果子问题的规模足够小，就停止递归，直接求解。</li>
<li>合并（Combine）：<br>将子问题的解合并为原问题的解。</li>
</ol>
<p><strong>最大子序列和</strong>问题的分治策略也可以对应上面三步：</p>
<ol>
<li><p>分解：<br>将整个数组划分为左右两个子数组，分别求两个子数组的最大子序列和。这样两个子问题和原问题一样，规模变为原来一半。</p>
</li>
<li><p>解决：<br>递归地分解数组，知道数组中只有一个元素时，可以直接把这个元素作为最大子序列和，返回给上一层。</p>
</li>
<li><p>合并：<br>合并过程是这个问题的<strong>关键</strong>。在分解步骤中你可能已经发现，两个子数组的最大子序列和中较大的那个并不一定就是原问题的最大子序列和。这是因为在划分数组的时候将两个子数组完全隔开了，而最大子序列可能会跨越两个子数组，所以要考虑这种情况。<br>所以原问题的最大子序列和一共有<strong>三种</strong>可能的情况：</p>
<ol>
<li>完全在左边子数组中</li>
<li>完全在右边子数组中</li>
<li>跨越左右两个子数组</li>
</ol>
<p>上面两种情况只需要递归的解决就可以，而第3种情况需要仔细考虑，想要找出跨越两个数组的最大子序列和需要遍历整个数组，所以这一过程的时间复杂度是$\Theta(n)$。那么可以得出分治策略解决该问题的运行时间：</p>
</li>
</ol>
<p>$$<br>T(n) =<br>\begin{cases}<br>\Theta(1)&amp;if\ \ n\ =\ 1 \<br>2T(\frac{n}{2}) + \Theta(n)&amp;if\ \ n\  &gt; \ 1<br>\end{cases}<br>$$</p>
<p>用<strong>主方法</strong>解此递归式得时间复杂度为$\Theta(nlog_2n)$。</p>
<h3 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h3><p>这个问题最重要的是理解分治策略，理解了分治策略后我们可以进一步优化时间复杂度。实际上我们可以在一次遍历内找出最大子序列和。</p>
<p>从头开始遍历时，每加入一个元素我们都可以比较加入和不加入两种情况下哪一个和更大，这样就会得到这一步的最大子序列和。然后用一个变量保存全局最大子序列和，就能得到我们想要的值。这其实有点类似动态规划。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="暴力法-1"><a href="#暴力法-1" class="headerlink" title="暴力法"></a>暴力法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_p</span><span class="params">(nums: List[int], s: int, e: int)</span> -&gt; int:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(s,e+<span class="number">1</span>):</span><br><span class="line">       sum += nums[i]</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        max_subarray_sum = float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i,len(nums)):</span><br><span class="line">                <span class="keyword">if</span> sum_p(nums,i,j) &gt; max_subarray_sum:</span><br><span class="line">                    max_subarray_sum = sum_p(nums,i,j)</span><br><span class="line">        <span class="keyword">return</span> max_subarray_sum</span><br></pre></td></tr></table></figure>

<p>leetcode美国版超时。国内版96ms，击败9.45%。</p>
<h3 id="分治法-1"><a href="#分治法-1" class="headerlink" title="分治法"></a>分治法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_cross_subarray</span><span class="params">(nums: List[int],s: int, m: int, e: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># 求解跨越子数组的情况</span></span><br><span class="line">    left_sum = <span class="number">0</span></span><br><span class="line">    left_max_sum = float(<span class="string">'-inf'</span>)</span><br><span class="line">    print(left_max_sum)</span><br><span class="line">    left_i = left_max_i = m</span><br><span class="line">    <span class="keyword">while</span> left_i &gt;= s:</span><br><span class="line">        left_sum += nums[left_i]</span><br><span class="line">        <span class="keyword">if</span> left_sum &gt; left_max_sum:</span><br><span class="line">            left_max_sum = left_sum</span><br><span class="line">            left_max_i = left_i</span><br><span class="line">        left_i -= <span class="number">1</span></span><br><span class="line">    right_sum = <span class="number">0</span></span><br><span class="line">    right_max_sum = float(<span class="string">'-inf'</span>)</span><br><span class="line">    right_i = right_max_i = m + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> right_i &lt;= e:</span><br><span class="line">        right_sum += nums[right_i]</span><br><span class="line">        <span class="keyword">if</span> right_sum &gt; right_max_sum:</span><br><span class="line">            right_max_sum = right_sum</span><br><span class="line">            right_max_i = right_i</span><br><span class="line">        right_i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> left_max_sum + right_max_sum</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray2</span><span class="params">(nums: List[int],s: int, e:int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> s == e:</span><br><span class="line">        <span class="keyword">return</span> nums[s]</span><br><span class="line">    m = (s + e) // <span class="number">2</span></span><br><span class="line">    maxnum1 = maxSubArray2(nums,s,m)</span><br><span class="line">    maxnum2 = maxSubArray2(nums,m+<span class="number">1</span>,e)</span><br><span class="line">    maxnum3 = max_cross_subarray(nums,s,m,e)</span><br><span class="line">    <span class="keyword">return</span> max(maxnum1,maxnum2,maxnum3)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> maxSubArray2(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>leetcode用时：124ms，击败5.41%。</p>
<h3 id="一次遍历-1"><a href="#一次遍历-1" class="headerlink" title="一次遍历"></a>一次遍历</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        local_max = nums[<span class="number">0</span>]</span><br><span class="line">        global_max = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            local_max = max(local_max + nums[i],nums[i])</span><br><span class="line">            <span class="keyword">if</span> local_max &gt; global_max:</span><br><span class="line">                global_max = local_max</span><br><span class="line">        <span class="keyword">return</span> global_max</span><br></pre></td></tr></table></figure>

<p>leetcode用时：48ms，击败66.85%。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Leetcode国际版：<a href="https://leetcode.com/" target="_blank" rel="noopener">https://leetcode.com/</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.006 Lecture3 插入排序和归并排序</title>
    <url>/chinese/2019/02/22/MIT-6-006-Lecture3-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="MIT-6-006-Lecture3-插入排序和归并排序"><a href="#MIT-6-006-Lecture3-插入排序和归并排序" class="headerlink" title="MIT 6.006 Lecture3 插入排序和归并排序"></a>MIT 6.006 Lecture3 插入排序和归并排序</h1><p>这是排序部分的第一讲，我们会<strong>先</strong>介绍一下排序问题及其应用，<strong>然后</strong>介绍<strong>插入排序</strong>和<strong>归并排序</strong>两种算法，并对比。<strong>最后</strong>用Python实现这两种算法。</p>
<a id="more"></a>

<h2 id="排序问题及其应用"><a href="#排序问题及其应用" class="headerlink" title="排序问题及其应用"></a>排序问题及其应用</h2><h3 id="什么是排序问题"><a href="#什么是排序问题" class="headerlink" title="什么是排序问题"></a>什么是排序问题</h3><blockquote>
<p><strong>Input:</strong><br>   array A[1…n] of numbers.<br><strong>Output:</strong><br>   permutation B[1…n] of A such that B[1] ≤ B[2] ≤ … ≤ B[n] .<br><strong>e.g.</strong><br>   A = [7, 2, 5, 5, 9.6] → B = [2, 5, 5, 7, 9.6] </p>
</blockquote>
<p>排序问题给定一个输入数组A，算法处理后输入一个有序数组B。</p>
<h3 id="排序算法的应用"><a href="#排序算法的应用" class="headerlink" title="排序算法的应用"></a>排序算法的应用</h3><p>排序算法在很多方面都有应用，比如：</p>
<ul>
<li>组织一些数据库，比如歌曲库、书单库、电话簿</li>
<li>让某些问题变得简单<br>比如找数组中值、二叉查找、找统计离群点等</li>
<li>一些不太明显的应用，比如数据压缩、电脑绘图等。</li>
</ul>
<p>可以说排序算法是计算机科学一个很重要的基础，所以掌握好排序算法是很重要也很必要的。</p>
<h2 id="两种排序算法"><a href="#两种排序算法" class="headerlink" title="两种排序算法"></a>两种排序算法</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序可以说是最简单的一种排序算法，只需要四五行的Python代码就能实现。当然简单在很多时候意味着低效。</p>
<p>伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Insertion-Sort(A[],n)</span><br><span class="line">2. 	for j &lt;-- 2 to n</span><br><span class="line">3. 		将A[j]插入到已经排好序的子数组A[1..j-1]中</span><br><span class="line">4. 		通过调换位置讲A[j]放在正确的位置</span><br></pre></td></tr></table></figure>

<p>上述伪代码中第3行，将A[j]插入到已经排好序的子数组，这个过程中<strong>有一定的优化空间</strong>。因为子数组已经是排好序的，所以我们可以选择二分法插入。这样时间复杂度就变成了$\Theta(n)$变为$\Theta(log_2n)$。</p>
<p>即便是用二分查找法找到合适的位置，但是第4行伪代码中将A[j]插入到合适的位置依然要花费$\Theta(n)$。因为插入的过程是通过交换位置实现的。</p>
<p>所以不难看出插入排序要遍历2..n-1元素，将每个元素插入到合适位置的时间复杂度是$\Theta(n)$。所以插入排序的<strong>整体时间复杂度是$\Theta(n^2)​$。</strong></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序算法是<strong>分治策略</strong>一种典型的应用。《算法导论》中给出了分治策略的三个步骤：</p>
<ol>
<li>分解（Divide）：<br>将原问题划分为一些子问题，这些子问题和原问题一样，只不过规模更下。</li>
<li>解决（Conquer）：<br>递归地解决这些子问题，如果子问题的规模足够小，就停止递归，直接求解。</li>
<li>合并（Combine）：<br>将子问题的解合并为原问题的解。</li>
</ol>
<p>对应到归并排序算法</p>
<ol>
<li>分解：<br>将针对整个数组的排序分为对左右两个子数组的排序。</li>
<li>解决<br>递归地解决这些子问题，当子问题的规模只剩一个元素是，不用排序就是有序的了。</li>
<li>合并：<br>归并排序算法的关键和难点也是在合并这一过程。合并做到将两个有序的数组原地合并为一个有序的数组。</li>
</ol>
<p>归并排序算法伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Merge-Sort A[1..n]</span><br><span class="line">	if n &#x3D; 1</span><br><span class="line">		done</span><br><span class="line">	else</span><br><span class="line">		Merge-Sort A[1..n&#x2F;2]</span><br><span class="line">		Merge-Sort A[n&#x2F;2 + 1 .. n]</span><br><span class="line">		Merge the two sorted sub-arrays</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<p>可以列出归并排序的递归式：<br>$$<br>T(n) =<br>\begin{cases}<br>\Theta(1)\ \ 若\ n \le c\<br>2T(\frac{n}{2}) + \Theta(n)<br>\end{cases}<br>$$<br>利用<strong>master theory</strong>容易得出归并排序算法的时间复杂度是$\Theta(nlog_2n)​$</p>
<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><p>python本身已经内置了排序算法，而且时间复杂度不错。我们自己实现一遍主要是为了理解算法。</p>
<h3 id="插入排序-1"><a href="#插入排序-1" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">InsertionSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">		j = i - <span class="number">1</span></span><br><span class="line">		tmp = nums[i]</span><br><span class="line">		<span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">if</span> nums[j] &gt; tmp:</span><br><span class="line">				nums[j+<span class="number">1</span>] = nums[j]</span><br><span class="line">				j -= <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">		nums[j + <span class="number">1</span>] = tmp</span><br></pre></td></tr></table></figure>



<h3 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(nums,s,m,e)</span>:</span></span><br><span class="line">	left = nums[s:m+<span class="number">1</span>]</span><br><span class="line">	right = nums[m+<span class="number">1</span>:e+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">	i = j = <span class="number">0</span></span><br><span class="line">	k = s</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">		<span class="keyword">if</span> left[i] &lt; right[j]:</span><br><span class="line">			nums[k] = left [i]</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			nums[k] = right[j]</span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">		k += <span class="number">1</span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">while</span> i &lt; len(left):</span><br><span class="line">		nums[k] = left[i]</span><br><span class="line">		k += <span class="number">1</span></span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">while</span> j &lt; len(right):</span><br><span class="line">		nums[k] = right[j]</span><br><span class="line">		k += <span class="number">1</span></span><br><span class="line">		j += <span class="number">1</span>	</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MergeSort2</span><span class="params">(nums,s,e)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> s != e:</span><br><span class="line">		m = (s + e) // <span class="number">2</span></span><br><span class="line">		MergeSort2(nums,s,m)</span><br><span class="line">		MergeSort2(nums,m+<span class="number">1</span>,e)</span><br><span class="line">		Merge(nums,s,m,e)</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MergeSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">	MergeSort2(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>MIT</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 56 Merge Intervals</title>
    <url>/chinese/2019/02/13/leetcode-56-Merge-Intervals/</url>
    <content><![CDATA[<h1 id="leetcode-56-区间合并——Merge-Intervals"><a href="#leetcode-56-区间合并——Merge-Intervals" class="headerlink" title="leetcode 56 区间合并——Merge Intervals"></a>leetcode 56 区间合并——Merge Intervals</h1><p>排序算法有很多应用，区间排序就是一种典型的应用。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一组区间，合并所有重叠的区间。</p>
<p>例子1：</p>
<blockquote>
<p>输入：[[1,3],[2,6],[8,10],[15,18]]</p>
<p>输出：[[1,6],[8,10],[15,18]]</p>
</blockquote>
<p>例子2：</p>
<blockquote>
<p>输入：[[1,4],[4,5]]</p>
<p>输出：[[1,5]]</p>
</blockquote>
<a id="more"></a>

<h2 id="解体思路"><a href="#解体思路" class="headerlink" title="解体思路"></a>解体思路</h2><p>按照区间的起始点对区间进行排序，那么可以合并的区间一定是相邻的。</p>
<p>算法步骤如下：</p>
<ol>
<li>将给定的一组区间<strong>按照起始点进行排序</strong>。</li>
<li>设置<em>new_start</em>和<em>new_end</em>两个变量来存储即将插入结果队列的区间起始点和终点，从左往右开始遍历排好序的区间。</li>
<li>如果当前区间和下一个区间有重叠，更新<em>new_end</em>，<strong>注意新的值一定要大于当前<em>new_end</em></strong>。</li>
<li>如果当前区间和下一个区间没有重叠，将<em>new_start</em>和<em>new_end</em>作为起始点和终点的区间插入结果。</li>
</ol>
<ul>
<li>时间复杂度<br>对序列排序的时间复杂度是$\Theta(n \times log_2{n})$，而对序列遍历的时间复杂度是$\Theta(n)$。所以整个算法的时间复杂度是$\Theta(n \times log_2{n})$。</li>
<li>空间复杂度<br>空间复杂度和排序算法有关。比如<strong>空间复杂度</strong>是$\Theta(1)$，而合并排序的时间复杂度是$\Theta(n)$。</li>
</ul>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>我一开始的实现不够简洁，逻辑虽然简单，但是代码看上去很臃肿。具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="comment"># class Interval:</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: <span class="string">'List[Interval]'</span>)</span> -&gt; 'List[Interval]':</span></span><br><span class="line">        sorted_int = sorted(intervals,key=<span class="keyword">lambda</span> x:x.start) <span class="comment">#sort intervals by start</span></span><br><span class="line">        </span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        length = len(sorted_int)</span><br><span class="line">        <span class="keyword">if</span> length &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        new_start = sorted_int[<span class="number">0</span>].start</span><br><span class="line">        new_end = sorted_int[<span class="number">0</span>].end</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; length):</span><br><span class="line">            <span class="keyword">if</span> new_end &gt;= sorted_int[i].start:</span><br><span class="line">                new_end = max(sorted_int[i].end,new_end)</span><br><span class="line">                i = i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = Interval(new_start,new_end)</span><br><span class="line">                result.append(tmp)</span><br><span class="line">                new_start = sorted_int[i].start</span><br><span class="line">                new_end = sorted_int[i].end</span><br><span class="line">                </span><br><span class="line">        tmp = Interval(new_start,new_end)//处理最后一个区间</span><br><span class="line">        result.append(tmp)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p><strong>leetcode用时：60ms，排名85.63%。</strong></p>
<p>在看过大神的代码后学到了一个<strong>技巧</strong>，就是对<strong>访问列表是对负数的应用</strong>。例如<code>list[-1]</code>表示访问列表的最后一个元素，这个技巧在这个题目中可以使得代码变得简洁。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="comment"># class Interval:</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: <span class="string">'List[Interval]'</span>)</span> -&gt; 'List[Interval]':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        sorted_int = sorted(intervals,key=<span class="keyword">lambda</span> x:x.start) <span class="comment">#sort intervals by start</span></span><br><span class="line">        </span><br><span class="line">        result = [sorted_int[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(sorted_int)):</span><br><span class="line">            <span class="keyword">if</span> result[<span class="number">-1</span>].end &gt;= sorted_int[i].start:</span><br><span class="line">                <span class="keyword">if</span>(result[<span class="number">-1</span>].end &lt; sorted_int[i].end):</span><br><span class="line">                    result[<span class="number">-1</span>].end = sorted_int[i].end</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(sorted_int[i])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p><strong>leetcode用时：56ms，排名99.24%。</strong></p>
<p>这个实现相比于第一个实现不仅变得简洁，而且<strong>省去了新建区间的过程</strong>，直接利用已有区间，这样省下了一定的时间，时间性能排名上升。</p>
<h2 id="超慢实现"><a href="#超慢实现" class="headerlink" title="超慢实现"></a>超慢实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="comment"># class Interval:</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type intervals: List[Interval]</span></span><br><span class="line"><span class="string">        :rtype: List[Interval]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> i: i.start)</span><br><span class="line">        temp = intervals[<span class="number">0</span>]</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(intervals[:]):<span class="comment">#在循环中使用len()函数，非常影响性能</span></span><br><span class="line">            next = intervals[i]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> temp.end &lt; next.start:</span><br><span class="line">                res.append(temp)</span><br><span class="line">                temp = next</span><br><span class="line">            <span class="keyword">elif</span> temp.end &gt;= next.start:</span><br><span class="line">                temp = Interval(temp.start, max(temp.end, next.end))</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        res.append(temp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><strong>leetcode用时：748ms</strong></p>
<p>这个超慢实现还是常见的<strong>低效循环</strong>错误，课件只要避免在<a href="https://freshmanhaner.github.io/2018/10/05/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/#more" target="_blank" rel="noopener">如何优化程序性能</a>提到过的常见错误，可以很大程度上提升程序的时间性能。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Leetcode国际版：<a href="https://leetcode.com/" target="_blank" rel="noopener">https://leetcode.com/</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 2 AddTwoNumbers</title>
    <url>/chinese/2019/02/10/leetcode-2-AddTwoNumbers/</url>
    <content><![CDATA[<h1 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定两个<strong>非空</strong>链表来表示两个非负整数。整数的数位反向存储，每个链表节点存储一个数字。将两个整数相加并以相同的格式返回结果。</p>
<p>例如：</p>
<blockquote>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p>
<p>输出：7 -&gt; 0 -&gt; 8</p>
<p>其实就是 342 + 465 = 807</p>
</blockquote>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个题目本身难度不大，不知道难度为什么是<em>中等</em>。我解题过程中主要的纠结点是对结果链表头部的处理，因为链表头部相对于其他节点比较特殊，需要单独考虑。其他没有发现什么难点，无非是对链表和指针的操作。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>对于链表头节点的问题，我选择创建一个空的头节点，这样可以统一处理头节点和其他节点，在最后返回时跳过空的头节点。</p>
<p>我的第一次实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: <span class="string">'ListNode'</span>, l2: <span class="string">'ListNode'</span>)</span> -&gt; 'ListNode':</span></span><br><span class="line">        carry = <span class="number">0</span> <span class="comment">#进位</span></span><br><span class="line">        </span><br><span class="line">        lp1 = l1</span><br><span class="line">        lp2 = l2</span><br><span class="line">        </span><br><span class="line">        lsum = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        res = ListNode(<span class="number">0</span>)</span><br><span class="line">        lpr = res</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lp1:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lp2:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(lp1 <span class="keyword">and</span> lp2):</span><br><span class="line">            lsum = lp1.val + lp2.val + carry</span><br><span class="line">            <span class="keyword">if</span>(lsum &gt;= <span class="number">10</span>):</span><br><span class="line">                lsum -= <span class="number">10</span></span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            new_digit = ListNode(lsum)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">            lpr = lpr.next</span><br><span class="line">            lp1 = lp1.next</span><br><span class="line">            lp2 = lp2.next</span><br><span class="line">        <span class="keyword">while</span>(lp1):</span><br><span class="line">            lsum = lp1.val + carry</span><br><span class="line">            <span class="keyword">if</span> lsum &gt;= <span class="number">10</span>:</span><br><span class="line">                lsum -= <span class="number">10</span></span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            new_digit = ListNode(lsum)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">            lpr = lpr.next</span><br><span class="line">            lp1 = lp1.next</span><br><span class="line">        <span class="keyword">while</span>(lp2):</span><br><span class="line">            lsum = lp2.val + carry</span><br><span class="line">            <span class="keyword">if</span> lsum &gt;= <span class="number">10</span>:</span><br><span class="line">                lsum -= <span class="number">10</span></span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            new_digit = ListNode(lsum)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">            lpr = lpr.next</span><br><span class="line">            lp2 = lp2.next</span><br><span class="line">        <span class="keyword">if</span> carry != <span class="number">0</span>:</span><br><span class="line">            new_digit = ListNode(carry)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">        res = res.next</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>leetcode运行时间128ms。</p>
<p>第一次的实现表现不佳，用时排名接近50%。主要问题在于每次循环都用if/else判断lsum是否大于等于10，这样其实浪费了不少时间。那么我们能不能无论lsum是否小于10，都统一处理呢？可以！</p>
<p>优化后代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: <span class="string">'ListNode'</span>, l2: <span class="string">'ListNode'</span>)</span> -&gt; 'ListNode':</span></span><br><span class="line">        carry = <span class="number">0</span> <span class="comment">#进位</span></span><br><span class="line">        </span><br><span class="line">        lp1 = l1</span><br><span class="line">        lp2 = l2</span><br><span class="line">        </span><br><span class="line">        lsum = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        res = ListNode(<span class="number">0</span>)</span><br><span class="line">        lpr = res</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(lp1 <span class="keyword">and</span> lp2):</span><br><span class="line">            lsum = lp1.val + lp2.val + carry</span><br><span class="line">            carry = lsum // <span class="number">10</span></span><br><span class="line">            lsum = lsum % <span class="number">10</span></span><br><span class="line">            new_digit = ListNode(lsum)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">            lpr = lpr.next</span><br><span class="line">            lp1 = lp1.next</span><br><span class="line">            lp2 = lp2.next</span><br><span class="line">        <span class="keyword">while</span>(lp1):</span><br><span class="line">            lsum = lp1.val + carry</span><br><span class="line">            carry = lsum // <span class="number">10</span></span><br><span class="line">            lsum = lsum % <span class="number">10</span></span><br><span class="line">            new_digit = ListNode(lsum)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">            lpr = lpr.next</span><br><span class="line">            lp1 = lp1.next</span><br><span class="line">        <span class="keyword">while</span>(lp2):</span><br><span class="line">            lsum = lp2.val + carry</span><br><span class="line">            carry = lsum // <span class="number">10</span></span><br><span class="line">            lsum = lsum % <span class="number">10</span></span><br><span class="line">            new_digit = ListNode(lsum)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">            lpr = lpr.next</span><br><span class="line">            lp2 = lp2.next</span><br><span class="line">        <span class="keyword">if</span> carry != <span class="number">0</span>:</span><br><span class="line">            new_digit = ListNode(carry)</span><br><span class="line">            lpr.next = new_digit</span><br><span class="line">        <span class="keyword">return</span> res.next</span><br></pre></td></tr></table></figure>

<p>leetcode运行时间96ms。</p>
<p>96ms的表现已经超越99.26%的实现。</p>
<h2 id="超慢实现"><a href="#超慢实现" class="headerlink" title="超慢实现"></a>超慢实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l3val = <span class="number">0</span></span><br><span class="line">            add1 =<span class="number">0</span> </span><br><span class="line">            l3 = ListNode(<span class="number">0</span>)</span><br><span class="line">            l3last = l3</span><br><span class="line">            <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 :</span><br><span class="line">                l3val=<span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> l1 :</span><br><span class="line">                    l3val = l1.val</span><br><span class="line">                    <span class="comment">#print(l1.val)</span></span><br><span class="line">                    l1 = l1.next</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">if</span> l2 :</span><br><span class="line">                    l3val += l2.val</span><br><span class="line">                    <span class="comment">#print(l2.val)</span></span><br><span class="line">                    l2 = l2.next</span><br><span class="line">                l3val += add1</span><br><span class="line">                add1 = l3val//<span class="number">10</span></span><br><span class="line">                l3last.next = ListNode(l3val%<span class="number">10</span>)</span><br><span class="line">                l3last = l3last.next</span><br><span class="line">                print(add1)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> add1==<span class="number">1</span>:</span><br><span class="line">                l3last.next = ListNode(<span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> l3.next</span><br></pre></td></tr></table></figure>

<p>leetcode用时312ms。</p>
<p>这个超慢实现，我不太确定慢的原因。我觉得可能的原因有：</p>
<ol>
<li>循环中的两个分支多数情况下都要经过，这限制了处理器的预执行优化，影响性能。</li>
<li>实现中有<code>print()</code></li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Leetcode国际版：<a href="https://leetcode.com/" target="_blank" rel="noopener">https://leetcode.com/</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的系统指令</title>
    <url>/chinese/2019/01/25/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="常见的系统指令"><a href="#常见的系统指令" class="headerlink" title="常见的系统指令"></a>常见的系统指令</h1><p>系统指令大概可以用于实现下来功能：</p>
<ol>
<li>指针参数验证 <em>Verification of pointer parameters</em></li>
<li><strong>描述符表寻址</strong> <em>Addressing descriptor tables</em></li>
<li><strong>多任务处理</strong> <em>Multitasking</em></li>
<li><strong>协同处理和多任务处理</strong> <em>Coprocessing &amp; Multiprocessing</em></li>
<li><strong>输入输出</strong> <em>Input&amp;Output</em></li>
<li><strong>中断控制</strong> <em>Interrupt control</em></li>
<li>调试 <em>Debugging</em></li>
<li>TLB检查 <em>TLB testing</em></li>
<li><strong>系统控制</strong> <em>System control</em></li>
</ol>
<p>接下来我们详细介绍：</p>
<a id="more"></a>

<h2 id="指针参数验证"><a href="#指针参数验证" class="headerlink" title="指针参数验证"></a>指针参数验证</h2><ol>
<li><p>ARPL</p>
<p>该指令一般用于保证子程序的选择器参数不会要求比调用者允许的更高的特权。用法是<code>ARPL r/m16, r16</code>，r/m16表示第一个操作数是16位内存变量或者16位寄存器，这个操作数用于存放选择器的值。r16表示16位寄存器。如果第一个操作数的RPL（<em>Requested privilege level</em>）$\le$第二个操作数的RPL，EFLAGS中的ZF位置1，并且提升第一个操作数的RPL使之不小于第二个操作数的RPL。否则的话不改变RPL，将ZF位置0。</p>
</li>
<li><p>LAR<br>装载读写权限位。</p>
</li>
<li><p>LSL<br>装载段界。</p>
</li>
<li><p>VERR<br>确定当前特权级能否读段。</p>
</li>
<li><p>VERW<br>确定当前特权级能够写段。</p>
</li>
</ol>
<h2 id="描述符表寻址"><a href="#描述符表寻址" class="headerlink" title="描述符表寻址"></a>描述符表寻址</h2><ol>
<li>LLDT<br>LLDT的作用是装载局部描述符表寄存器LDTR。</li>
<li>SLDT<br>SLDT的作用是读取局部描述符表寄存器LDTR中的内容读取出来并存储。</li>
<li>LGDT<br>LGDT的作用是装载全局描述符表寄存器GDTR。</li>
<li>SGDT<br>SGDT的作用是读取全局描述符表寄存器GDTR中的内容读取出来并存储。</li>
</ol>
<p>关于LDTR和GDTR请见<a href="https://freshmanhaner.github.io/2019/01/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E5%9B%9B%E7%B1%BB%E5%AF%84%E5%AD%98%E5%99%A8/#more" target="_blank" rel="noopener">操作系统程序员必须了解的四类寄存器</a></p>
<h2 id="多任务处理"><a href="#多任务处理" class="headerlink" title="多任务处理"></a>多任务处理</h2><ol>
<li>LTR<br>LTR的作用是装载任务寄存器TR。</li>
<li>STR<br>SLDT的作用是读取任务寄存器TR中的内容读取出来并存储。</li>
</ol>
<p>关于TR请见<a href="https://freshmanhaner.github.io/2019/01/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E5%9B%9B%E7%B1%BB%E5%AF%84%E5%AD%98%E5%99%A8/#more" target="_blank" rel="noopener">操作系统程序员必须了解的四类寄存器</a></p>
<h2 id="协同处理和多任务处理"><a href="#协同处理和多任务处理" class="headerlink" title="协同处理和多任务处理"></a>协同处理和多任务处理</h2><ol>
<li>CLTS<br>清除CR0寄存器中的TS标志（任务转换标志）。我们在<a href="https://freshmanhaner.github.io/2019/01/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E5%9B%9B%E7%B1%BB%E5%AF%84%E5%AD%98%E5%99%A8/#more" target="_blank" rel="noopener">操作系统程序员必须了解到四类寄存器</a>中介绍过，TS标志在每次发生任务切换后由处理器置1.</li>
<li>ESC<br>逃脱指令。</li>
<li>WAIT<br>挂起指令的执行，等待协处理器不忙。</li>
<li>LOCK<br>用于声明下一条指令的总线锁信号。在多处理器环境下这条指令可以用来确保对共享内存的独占。</li>
</ol>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><ol>
<li><p>IN<br>IN指令将一个字节（byte）或者一个字（word）的数据从指定端口传送到指定寄存器。<br>其中端口号存储在DX寄存器中，寄存器由指令指定。</p>
</li>
<li><p>OUT<br>OUT指令将一个字节（byte）或者一个字（word）的数据从指定寄存器传送到指定端口。<br>其中端口号存储在DX寄存器中，寄存器由指令指定。</p>
</li>
<li><p>INS<br>一般用于从指定端口读入字符串。</p>
</li>
<li><p>OUTS</p>
<p>一般用于将字符串输入指定端口。</p>
</li>
</ol>
<h2 id="中断控制"><a href="#中断控制" class="headerlink" title="中断控制"></a>中断控制</h2><ol>
<li>CLI<br>关中断。既清除中断使能标记。</li>
<li>STI<br>开终端。既将中断使能标记置1.</li>
<li>LIDT<br>装载IDT（异常描述符表）寄存器。</li>
<li>SIDT<br>将IDT中的内容读出来，并存储。</li>
</ol>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>用<code>MOV</code>指令改变调试寄存器，至于什么是调试寄存器以及有什么作用，请见<a href="https://freshmanhaner.github.io/2019/01/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E5%9B%9B%E7%B1%BB%E5%AF%84%E5%AD%98%E5%99%A8/#more" target="_blank" rel="noopener">操作系统程序员必须了解的四类寄存器</a></p>
<h2 id="TLB检查"><a href="#TLB检查" class="headerlink" title="TLB检查"></a>TLB检查</h2><p>用<code>MOV</code>指令改变检查寄存器，至于什么是检查寄存器以及有什么作用，请见<a href="https://freshmanhaner.github.io/2019/01/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E5%9B%9B%E7%B1%BB%E5%AF%84%E5%AD%98%E5%99%A8/#more" target="_blank" rel="noopener">操作系统程序员必须了解的四类寄存器</a></p>
<h2 id="系统控制"><a href="#系统控制" class="headerlink" title="系统控制"></a>系统控制</h2><ol>
<li><p>SMSW<br>设置CR0中的MSW位，既机器状态字（machine status word）。</p>
</li>
<li><p>LMSW<br>设置CR0中的MSW位。</p>
</li>
<li><p>HLT</p>
<p>停止指令执行并将处理器置为HALT状态。</p>
</li>
<li><p>MOV<br>用<code>MOV</code>指令改变控制寄存器，至于什么是控制寄存器以及有什么作用，请见<a href="https://freshmanhaner.github.io/2019/01/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E5%9B%9B%E7%B1%BB%E5%AF%84%E5%AD%98%E5%99%A8/#more" target="_blank" rel="noopener">操作系统程序员必须了解的四类寄存器</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统程序员必须了解的五类寄存器</title>
    <url>/chinese/2019/01/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E5%9B%9B%E7%B1%BB%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    <content><![CDATA[<h1 id="操作系统程序员必须了解的四类寄存器"><a href="#操作系统程序员必须了解的四类寄存器" class="headerlink" title="操作系统程序员必须了解的四类寄存器"></a>操作系统程序员必须了解的四类寄存器</h1><p>供操作系统程序员使用的寄存器可以分为下面这么几类：</p>
<ul>
<li><strong>EFLAGS</strong></li>
<li><strong>Memory-Management Registers</strong></li>
<li><strong>Control Registers</strong></li>
<li><strong>Debug Registers</strong></li>
</ul>
<p>接下来我们分别介绍一下这几类寄存器。</p>
<a id="more"></a>

<h2 id="EFLAGS"><a href="#EFLAGS" class="headerlink" title="EFLAGS"></a>EFLAGS</h2><p>操作系统在很多地方都要<strong>关闭中断、打开中断</strong>，实现这一点就要用到EFLAGS寄存器，当然EFLAGS寄存器的作用不只是这一点。</p>
<p>下图是EFLAGS寄存器的所有位，其中灰色代表保留为，不可使用。图下方的表格会详细介绍每一位的作用，比较重要的位被标为<strong>黑体</strong>。</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/OS/EFLAGS_register.png" alt="EFLAGS"></p>
<table>
<thead>
<tr>
<th align="center">简称</th>
<th align="center">中文名称</th>
<th align="center">标志类型</th>
<th align="center">具体作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ID</td>
<td align="center">识别标志</td>
<td align="center">系统标志</td>
<td align="center">如果ID为能够被设置，表示处理器支持CPUID命令。</td>
</tr>
<tr>
<td align="center">VIP</td>
<td align="center">虚拟未决中断标志</td>
<td align="center">系统标志</td>
<td align="center">如果有中断挂起，VIP设为1。</td>
</tr>
<tr>
<td align="center">VIF</td>
<td align="center">虚拟中断标志</td>
<td align="center">系统标志</td>
<td align="center">IF位的虚拟镜像。</td>
</tr>
<tr>
<td align="center">AC</td>
<td align="center">对齐检查标志</td>
<td align="center">系统标志</td>
<td align="center">如果对内存引用的对齐检查完成，AC设为1。</td>
</tr>
<tr>
<td align="center"><strong>VM</strong></td>
<td align="center">虚拟8086模式</td>
<td align="center">系统标志</td>
<td align="center">VM为1是表示允许虚拟8086模式（既<strong>实模式</strong>）。</td>
</tr>
<tr>
<td align="center"><strong>RF</strong></td>
<td align="center">恢复标志</td>
<td align="center">系统标志</td>
<td align="center">对调试异常做出反应。具体说就是暂时关闭调试异常（_debug exception_），这样指令可以在出现调试异常后重新执行而不会马上引起另一个调试异常。</td>
</tr>
<tr>
<td align="center"><strong>NT</strong></td>
<td align="center">任务嵌套标志</td>
<td align="center">系统标志</td>
<td align="center">用于控制中断链，如果当前程序或者任务与下一个程序或任务相关联，NT设为1。NT位的设置会影响到<code>IRET</code>指令。</td>
</tr>
<tr>
<td align="center">IOPL</td>
<td align="center">I/O特权级标志</td>
<td align="center">系统标志</td>
<td align="center">表示当前程序或者任务的I/O特权级。只有当前特权级（<em>Current Privilege Level</em>）$\leq$I/O特权级的时候才能够访问该I/O地址空间。</td>
</tr>
<tr>
<td align="center">OF</td>
<td align="center">溢出标记</td>
<td align="center">状态标志</td>
<td align="center">如果运算结果溢出，OF设为1，否则设为0。</td>
</tr>
<tr>
<td align="center">DF</td>
<td align="center">方向标志</td>
<td align="center">控制标志</td>
<td align="center">DF为1时<strong>字符串操作</strong>会从高地址向低地址处理，否则相反。汇编中的<code>STD</code>命令用来讲DF设为1，<code>CLD</code>命令将DF设为0。</td>
</tr>
<tr>
<td align="center"><strong>IF</strong></td>
<td align="center">中断标志</td>
<td align="center">系统标志</td>
<td align="center">IF为1时表示<strong>允许中断</strong>。</td>
</tr>
<tr>
<td align="center"><strong>TF</strong></td>
<td align="center">陷阱标志</td>
<td align="center">系统标志</td>
<td align="center">TF为1时表示<strong>允许单步调试</strong>。单步调试模式下CPU会在执行每个指令后自动产生抛出一个异常，这样就能在执行每条指令后观察程序状态。</td>
</tr>
<tr>
<td align="center">SF</td>
<td align="center">符号位</td>
<td align="center">状态标志</td>
<td align="center">如果计算结果是<strong>负数</strong>，SF设为1，否则设为0。</td>
</tr>
<tr>
<td align="center">ZF</td>
<td align="center">零标记</td>
<td align="center">状态标志</td>
<td align="center">如果计算结果是0，ZF设为1，否则设为0。</td>
</tr>
<tr>
<td align="center">AF</td>
<td align="center">辅助进位标记</td>
<td align="center">状态标志</td>
<td align="center">如果计算时低效半字节（<em>low nibble</em>），也就是最低4位发生了进位或者借位，AF设为1，否则设为0。主要用来辅助BCD码（二进制编码的十进制）的算术计算。</td>
</tr>
<tr>
<td align="center">PF</td>
<td align="center">奇偶位</td>
<td align="center">状态标志</td>
<td align="center">计算结果转化为二进制数，如果最低8位（<em>least significant byte</em>）中1的个数是偶数，PF设为1，否则设为0。</td>
</tr>
<tr>
<td align="center">CF</td>
<td align="center">进位标记</td>
<td align="center">状态标志</td>
<td align="center">如果上次算术运算有<strong>进位</strong>或者<strong>借位</strong>，CF设为1，否者设为0。</td>
</tr>
</tbody></table>
<h2 id="内存管理寄存器——Memory-Management-Registers"><a href="#内存管理寄存器——Memory-Management-Registers" class="headerlink" title="内存管理寄存器——Memory-Management Registers"></a>内存管理寄存器——<em>Memory-Management Registers</em></h2><p>80386处理器中四个寄存器用于<strong>定位</strong>控制段内存管理的数据结构，它们是：</p>
<ol>
<li><p><strong>全局描述符表寄存器</strong> <em>Global Descriptor Table Register</em><br>指向全局描述符表（GDT），GDT中没8bytes代表一个描述符，描述符可以是段描述符、TSS（任务状态段）描述符、门描述符（局部描述符表描述符）。<br>段描述符如下图：</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/OS/SegmentDescriptor.png" alt="SegmentDescriptor"></p>
<p>TSS描述符指向TSS，门描述符指向LDT。</p>
</li>
<li><p><strong>局部描述符表寄存器</strong> <em>Local Descriptor Table Register</em><br>指向局部描述符表（LDT），和GDT不同，LDT只能存放段描述符。</p>
</li>
<li><p><strong>中断描述符表寄存器</strong> <em>Interrupt Descriptor Table Register</em><br>指向中断描述符表（IDT），中断描述符表中记录着中断处理程序的入口。</p>
</li>
<li><p><strong>任务寄存器</strong> <em>Task Register</em><br>指向处理器定义当前任务所需信息。</p>
</li>
</ol>
<h2 id="控制寄存器——Control-Registers"><a href="#控制寄存器——Control-Registers" class="headerlink" title="控制寄存器——Control Registers"></a>控制寄存器——<em>Control Registers</em></h2><p>80386处理器中的控制寄存器有_CR0_、_CR2_、<em>CR3</em>（更新的处理器中有更多的控制寄存器） 。这些寄存器只能通过汇编指令<code>MOV</code>来读写，具体点就是将通用寄存器中的值存储到控制寄存器，或者从控制寄存器中读取值放在通用寄存器。下面我们详细介绍一下这三个寄存器的作用。</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/OS/control_register.gif" alt="80386 CR0-3寄存器"></p>
<ul>
<li><p>CR0控制寄存器：<br>CR0控制寄存器包含系统控制标志，这些标志可以用来控制<strong>整个系统</strong>的状态。我们分别说一下这些控制标志</p>
<table>
<thead>
<tr>
<th align="center">简称</th>
<th align="center">全称</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PG</td>
<td align="center">Paging</td>
<td align="center">指明处理器是否使用<strong>页表</strong>将<strong>线性地址</strong>翻译为<strong>物理地址</strong>。PG为1是处理器使用分页。</td>
</tr>
<tr>
<td align="center">ET</td>
<td align="center">Extension Type</td>
<td align="center">ET指明系统中存在的协处理器的类型。</td>
</tr>
<tr>
<td align="center">TS</td>
<td align="center">Task Switched</td>
<td align="center">每次任务切换处理器都会把TS置1，并且在执行协处理器指令时检查TS位。</td>
</tr>
<tr>
<td align="center">EM</td>
<td align="center">Emulation</td>
<td align="center">EM位指明是否模拟<strong>协处理器</strong>功能。如果EM为1，执行<code>ESC</code>指令时会产生7号异常，让异常处理程序有机会模拟<code>ESC</code>指令。</td>
</tr>
<tr>
<td align="center">MP</td>
<td align="center">Monitor Coprocessor</td>
<td align="center">控制<code>WAIT</code>指令，如果MP为1，当执行<code>WAIT</code>指令时CPU会检查TS位，如果发现TS位是1，则抛出7号异常。</td>
</tr>
<tr>
<td align="center">PE</td>
<td align="center">Protection Enable</td>
<td align="center">PE位置1，处理器会开始执行保护模式。置0会返回实模式。</td>
</tr>
</tbody></table>
</li>
<li><p>CR1控制寄存器（保留，不可用）</p>
</li>
<li><p>CR2控制寄存器：<br>当CR0中的PG位置1时，CR2用于处理<strong>页错误</strong>，处理器将触发页错误的线性地址存入CR2寄存器。</p>
</li>
<li><p>CR3控制寄存器：<br>当CR0中的PG位置1时，CR3寄存器用于存放当前任务<strong>页表目录</strong>（<em>Page Table Directory</em>）的入口。CR3对于环境切换非常重要。</p>
</li>
</ul>
<h2 id="调试寄存器——Debug-Register"><a href="#调试寄存器——Debug-Register" class="headerlink" title="调试寄存器——Debug Register"></a>调试寄存器——<em>Debug Register</em></h2><p>调试寄存器让80386处理器能够在不改变程序代码的情况下实现指令断点等高级调试功能。80386处理器一共有8个调试处理器，如图：</p>
<p><img src="https://my-blog-1256501598.cos.ap-beijing.myqcloud.com/github-page/learn/CS/OS/debug_register.jpg" alt="debug registers"></p>
<p>和控制寄存器类似，用<code>MOV</code>指令操作这些寄存器，另外只有特权级为0是才能操作，其他特权级试图操作为引起异常。</p>
<ol>
<li><p>DR0~3——调试地址寄存器：<br>用于存放与断点条件相应的线性地址。<br>这些调试地址寄存器不管是否使用分页都有效，如果使用分页，寄存器中的线性地址会被转化为物理地址，否者这些线性地址会直接被当作物理地址。<br>需要注意的是，如果使用分页，不同的任务可能有不同的地址映射。如果任务之间的地址映射不同，那么调试寄存器中的地址可能和具体任务有关。</p>
</li>
<li><p>DR4~5——保留不用的寄存器</p>
</li>
<li><p>DR6——调试状态寄存器<br>调试状态寄存器帮助调试人员判断发生了哪些调试条件。<br>如果<em>DR0-3</em>指明的调试条件发生，在进入调试异常处理程序前DR6中相应的的<strong><em>B0-3</em></strong>被置1。<br>DR6中的<strong><em>BT位</em></strong>和TSS（任务状态段）中的<em>T-bit</em>配合，当发生任务切换并且新的TSS中的<em>T-bit</em>为1，那么在进入调试异常处理程序前BT会被置1。<br>DR6中的<strong><em>BS位</em></strong>和EFLAGS寄存器中的TF位配合，如果由于单步执行异常进入异常处理程序，BS会被置1。单步执行陷阱是最高优先级的调试异常，所以当BS为1时，所有的其他调试状态位可能也会被置1。<br>如果下一条指令会读写八个调试寄存器中的任意一个，<strong><em>BD位</em></strong>会被置1。<br>对于DR6有一点需要注意，处理器不会清零DR6，所以<strong>调试异常处理程序在返回前应该将DR6清零</strong>，以避免混乱。</p>
</li>
<li><p>DR7——调试控制寄存器<br>调试控制寄存器用于帮助定义调试条件，选择性的开关这些条件。<br>DR7中的<strong><em>R/W0</em></strong>，<strong><em>R/W1</em></strong>，<strong><em>R/W2</em></strong>，<strong><em>R/W3</em></strong>分别用于指明<em>DR0</em>，<em>DR1</em>，<em>DR2</em>，<em>DR3</em>在什么情况下触发断点。<em>R/W0-3</em>都包含2bit，可能的情况有：</p>
<ul>
<li>00——在指令执行时中断</li>
<li>01——在写数据时中断</li>
<li>10——未定义</li>
<li>11——在数据读写（不包括取指令）时中断</li>
</ul>
<p>当<em>RW0-3</em>为01或者11，DR7中对应的<strong><em>LEN</em></strong>用于指明数据的大小。<em>RW</em>为00时对应的<em>LEN</em>也必须为00。下面是<em>LEN</em>可能的值及对应含义：</p>
<ul>
<li><p>00——1byte</p>
</li>
<li><p>01——2byte</p>
</li>
<li><p>10——未定义</p>
</li>
<li><p>11——4byte</p>
</li>
</ul>
<p>DR7的低8位（<strong><em>L0-3</em></strong>，<strong><em>G0-3</em></strong>）用于是否开启断电条件，是全局（G）还是本地（L）。<em>L0-3</em>位任务切换时会被处理器自动重置，<em>G0-3</em>在任务切换时则不会被重置。</p>
<p>DR7中还有<strong><em>LE</em></strong>和<strong><em>GE</em></strong>两位，用于控制处理器降低执行速度，使得有时间将断点报给触发断点的指令。同样的<em>LE</em>在任务切换时会被重置，<em>GE</em>不会。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>硬件知识</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>寄存器</tag>
        <tag>EFLAGS</tag>
      </tags>
  </entry>
  <entry>
    <title>关于gcc编译器的一些内置宏定义</title>
    <url>/chinese/2019/01/23/%E5%85%B3%E4%BA%8Egcc%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AE%8F%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<h1 id="gcc内置宏"><a href="#gcc内置宏" class="headerlink" title="gcc内置宏"></a>gcc内置宏</h1><p>在看一些c语言代码时经常突然冒出一些宏，比如<code>__FILE__</code>、<code>__TIME__</code>等。前面也没有出现相关的定义，一直都没想着弄清楚是什么。这次又看到了这些宏，花了一点时间看了下是什么。</p>
<p>发现这些其实都是编译器内置的宏定义，所以代码中没有给出定义就能直接使用。这样的宏还不少，列出几个常见的，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"__FILE__ is %s \n"</span>,__FILE__);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"__LINE__ is %d \n"</span>,__LINE__);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"__FUNCTION__ is %s \n"</span>,__FUNCTION__);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"__DATE__ is %s \n"</span>,__DATE__);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"__TIME__ is %s \n"</span>,__TIME__);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"__TIMESTAMP__ is %s \n"</span>,__TIMESTAMP__);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果是：</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__FILE__ is D:\桌面\常用文件\学习文档\专业学习\C++项目\未命名<span class="number">1.</span>cpp</span><br><span class="line">__LINE__ is <span class="number">6</span></span><br><span class="line">__FUNCTION__ is main</span><br><span class="line">__DATE__ is Jan <span class="number">23</span> <span class="number">2019</span></span><br><span class="line">__TIME__ is <span class="number">20</span>:<span class="number">07</span>:<span class="number">46</span></span><br><span class="line">__TIMESTAMP__ is Wed Jan <span class="number">23</span> <span class="number">19</span>:<span class="number">56</span>:<span class="number">53</span> <span class="number">2019</span></span><br><span class="line"></span><br><span class="line">--------------------------------</span><br><span class="line">Process exited after <span class="number">0.09669</span> seconds with <span class="keyword">return</span> value <span class="number">0</span></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure>

<p>从上面的代码和输出结果可以看出</p>
<ul>
<li>__FILE__<br>指本语句所在源文件的名称（绝对路径）。</li>
<li>__LINE__<br>指本语句所在的行号。</li>
<li>__FUNCTION__<br>指本语句所在函数的函数名。</li>
<li>__DATE__<br>指本语句所在源文件<strong>编译时</strong>的日期。</li>
<li>__TIME__<br>指本语句所在源文件<strong>编译时</strong>的时间。</li>
<li>__TIMESTAMP__<br>指本语句所在源文件<strong>创建时</strong>的日期和时间。</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>编译器</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU利用关键字__attribute__设置变量属性</title>
    <url>/chinese/2019/01/23/GNU%E5%88%A9%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97-attribute-%E8%AE%BE%E7%BD%AE%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="GNU利用关键字attribute设置变量的属性"><a href="#GNU利用关键字attribute设置变量的属性" class="headerlink" title="GNU利用关键字attribute设置变量的属性"></a>GNU利用关键字<strong>attribute</strong>设置变量的属性</h1><p>关键字<code>__attribute__</code>可以用来声明变量、函数参数、结构体、共用体或者C++中类成员的特殊属性。使用方法是在关键字<code>__attribute__</code>后跟着用两个小括号包起来的属性声明。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">a</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a1;</span><br><span class="line">	<span class="keyword">int</span> a2;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>

<p>这个例子中声明结构体<code>a</code>的特殊属性——字节对齐，<code>((packed))</code>这个属性声明是指最小的对齐方式，即1Byte对齐。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGSIZE 1024</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">a</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a1;</span><br><span class="line">	<span class="keyword">int</span> a2;</span><br><span class="line">&#125; __attribute__((__aligned__(PGSIZE)));</span><br></pre></td></tr></table></figure>

<p>这个例子也是字节对齐，但是这次是我们自定义的对其方式：按照1024Byte进行字节对齐。</p>
<a id="more"></a>

<p>关于属性的详细介绍请参考：<a href="https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html" target="_blank" rel="noopener">参考资料——GNU官方文档</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C语言</tag>
        <tag>__attribute__</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 162 Find Peak Element</title>
    <url>/chinese/2019/01/23/leetcode-162-Find-Peak-Element/</url>
    <content><![CDATA[<h1 id="leetcode-162-Find-Peak-Element"><a href="#leetcode-162-Find-Peak-Element" class="headerlink" title="leetcode 162 Find Peak Element"></a>leetcode 162 Find Peak Element</h1><p>这个题目是MIT 6.006算法课中提到的第一个问题，也就是一维数组的Peak Finder问题。如果感兴趣看一看一下我的<a href="https://freshmanhaner.github.io/2019/01/20/MIT-6-006-Lecture-1-b-%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">MIT 6.006 Lecture 1-b 笔记</a>。</p>
<p>在对比不同解题思路的同时，我还对比了不同语言（c、C++、Python）。能够非常明显的看出在<strong>效率方面</strong>：c &gt; C++ &gt; Python；时间复杂度最高的<strong>简单算法用c语言写</strong>的效率也要大于C++写的低时间复杂度的算法，更不用说Python。当然如果看简洁程度，Python还是更优。详细情况请看具体实现。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote>
<p>A peak element is an element that is greater than its neighbors.</p>
<p>峰值元素是指比相邻元素大的元素</p>
<p>Given an input array <code>nums</code>, where nums[i] $\neq$ nums[i+1], find a peak element and return its index.</p>
<p>给定输入数组<code>nums</code>，规定nums[i]$\neq$nums[i+1]。从该数组中找到一个峰值元素并返回它的索引值。</p>
<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>
<p>给定的数组中可能含有多个峰值，只需找到其中任意一个即可。</p>
<p>You may imagine that nums[-1] = nums[n] = $-\infty$.</p>
<p>你可以假设nums[-1] = nums[n] = $-\infty$。</p>
</blockquote>
<a id="more"></a>

<h2 id="解体思路"><a href="#解体思路" class="headerlink" title="解体思路"></a>解体思路</h2><p>题目中很多的假设可以用来提升我们算法的效率，比如nums[i]$\neq$nums[i+1]、nums[-1] = nums[n] = $-\infty$。</p>
<h3 id="线性扫描"><a href="#线性扫描" class="headerlink" title="线性扫描"></a>线性扫描</h3><p>从左往右扫描整个数组，找出第一个出现的峰值元素。第一反应是看每个元素的左右两边来判断是否为峰值，其实只需要可能右边邻居，因为左边已经比较过了，一定是小于该元素的。</p>
<ul>
<li><p>时间复杂度<br>最坏情况下（元素自左向右递增）我们要扫描整个数组。所以时间复杂度为$O(n)$。</p>
</li>
<li><p>空间复杂度</p>
<p>只用到了常数额外空间，所以空间复杂度是$O(1)$。</p>
</li>
</ul>
<h3 id="递归二分搜索"><a href="#递归二分搜索" class="headerlink" title="递归二分搜索"></a>递归二分搜索</h3><p>递归二分搜索算法和下面的迭代二分搜索都属于<strong>分治策略</strong>_devide&amp;conquer_的一种。根据题目我们可以看出，考虑中间元素<code>mid</code>，如果<code>nums[mid] &lt; nums[mid+1]</code>，那么<code>mid</code>元素的右边一定存在峰值元素。因为我们只需找出峰值元素中的任意一个，我们就不再需要考虑<code>mid</code>元素的左边一半了，这样问题的规模也就缩小了一半。</p>
<ul>
<li>时间复杂度<br>$T(n) = T(\frac{n}{2}) + \Theta(1) = T(\frac{n}{4}) + 2\Theta(1) = … = log_2(n) \times \Theta(1)=O(log_2(n))$</li>
<li>空间复杂度<br>递归二分搜索中，每次递归表用都会占用上次一半的额外空间，所以总的额外空间是$log_2(n)$。也就是说空间复杂度也是$O(log_2(n))$。</li>
</ul>
<h3 id="迭代二分搜索"><a href="#迭代二分搜索" class="headerlink" title="迭代二分搜索"></a>迭代二分搜索</h3><p>迭代二分搜索和递归二分搜索整体思路一样，<strong>时间复杂度也是相同的</strong>（迭代在常数项上一般优于递归）。差别在于迭代二分搜索不会占用太多的额外空间，所以空间复杂度是$O(1)$。</p>
<p>所以能用迭代的地方尽量不用递归。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="线性扫描算法——c语言实现"><a href="#线性扫描算法——c语言实现" class="headerlink" title="线性扫描算法——c语言实现"></a>线性扫描算法——c语言实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; nums[i + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然是$\Theta(n)$的时间复杂度，但是用c语言编写的话用时为<strong>0ms</strong>。</p>
<h3 id="递归二分搜索——C-实现"><a href="#递归二分搜索——C-实现" class="headerlink" title="递归二分搜索——C++实现"></a>递归二分搜索——C++实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == e)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> mid = (s + e) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[mid + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> search(nums,mid+<span class="number">1</span>,e);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> search(nums,s,mid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">return</span> search(nums,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>用时<strong>4ms</strong></p>
<h3 id="迭代二分搜索——Python3实现"><a href="#迭代二分搜索——Python3实现" class="headerlink" title="迭代二分搜索——Python3实现"></a>迭代二分搜索——Python3实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start = <span class="number">0</span> </span><br><span class="line">        end = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">            <span class="keyword">if</span> start == end:</span><br><span class="line">                <span class="keyword">return</span> start</span><br><span class="line">            mid = (start + end)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid+ <span class="number">1</span>]):</span><br><span class="line">                start = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br></pre></td></tr></table></figure>

<p>单纯按照时间复杂度来比较，迭代二分搜索应该是最快的，但是用Python实现用时却是同样时间复杂度C++实现的8倍，用时<strong>32ms</strong>。</p>
<h2 id="超慢实现"><a href="#超慢实现" class="headerlink" title="超慢实现"></a>超慢实现</h2><p>通过分析超慢实现，我们可以避免影响算法效率的低级错误。</p>
<h3 id="c语言超慢实现"><a href="#c语言超慢实现" class="headerlink" title="c语言超慢实现"></a>c语言超慢实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = numsSize  <span class="number">-1</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt;  nums[m+<span class="number">1</span>]) &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细看这段代码，其实并没有什么低价错误，只不过是在计算中间值m的时候算式稍微复杂些。和最优实现0ms差别也不大，用时4ms。</p>
<h3 id="C-超慢实现"><a href="#C-超慢实现" class="headerlink" title="C++超慢实现"></a>C++超慢实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">2</span>)            </span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//----------------------------------------------</span></span><br><span class="line">        <span class="keyword">int</span> peak = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;            </span><br><span class="line">            <span class="keyword">if</span> (i<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; i+<span class="number">1</span> &lt; nums.size() )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>] &amp;&amp; nums[i] &gt; nums[i+<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i+<span class="number">1</span> == nums.size() &amp;&amp; nums[i] &gt; nums[i<span class="number">-1</span>])                </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> peak;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>和上段代码不同，这段代码就明显犯了<strong>低级错误：在循环代码中加入了低效率因素。</strong>在<code>for</code>循环语句中使用<code>nums.size()</code>，使得每次循环都会调用<code>size()</code>函数，严重影响算法性能，用时8ms。</p>
<p>至于如何优化算法性能，请见<a href="https://freshmanhaner.github.io/2018/10/05/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/#more" target="_blank" rel="noopener">如何优化程序性能</a></p>
<h3 id="Python3超慢实现"><a href="#Python3超慢实现" class="headerlink" title="Python3超慢实现"></a>Python3超慢实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> nums[<span class="number">0</span>] &gt;= nums[<span class="number">1</span>] <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            </span><br><span class="line">            mid = low + (high - low) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">and</span> nums[<span class="number">0</span>] &gt;= nums[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> mid == len(nums)<span class="number">-1</span> <span class="keyword">and</span> nums[<span class="number">-1</span>] &gt;= nums[<span class="number">-2</span>]:</span><br><span class="line">                <span class="keyword">return</span> len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid<span class="number">-1</span>] &lt;= nums[mid] <span class="keyword">and</span> nums[mid] &gt;= nums[mid+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> nums[mid+<span class="number">1</span>] &gt; nums[mid]:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure>

<p>循环中加入了太多的分支，一定程度上拖慢了程序的性能，用时76ms。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Leetcode国际版：<a href="https://leetcode.com/" target="_blank" rel="noopener">https://leetcode.com/</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>使用virtualenv和virtualenvwrapper建立多个独立python环境</title>
    <url>/chinese/2019/01/22/%E4%BD%BF%E7%94%A8virtualenv%E5%92%8Cvirtualenvwrapper%E5%BB%BA%E7%AB%8B%E5%A4%9A/</url>
    <content><![CDATA[<p>Python丰富的库是它的优势之一，但是对于我这样的强迫症来说却多少有些不太友好。安装的库越来越多，加上各种库之间的依赖关系。即使能够方便地查看，也会觉得混乱。更不要说还有安装失败的时候，强迫症心里表示很不舒服。<br>如果你在使用Python，也像我一样是个强迫症，那么救星来了。</p>
<p><img src="https://www.python.org/static/img/python-logo.png" alt="Python"></p>
<a id="more"></a>  

<h1 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h1><p><a href="https://pypi.org/project/virtualenv/" target="_blank" rel="noopener">virtualenv</a>是建立独立Python环境的工具，独立的Python环境在实际中是非常必要的。比如你的某个软件依赖某个库的版本1，另一个软件依赖这个库的版本2，如果你把这个库装在同一个python环境中，你很可能把某些你不想升级的库升级了，从而导致一些软件的失效。<br>搞清楚了有什么用，下面我们来安装吧，这里以Windows环境为例。有了神器pip的帮助，virtualenv的安装很简单，进入cmd，然后只需<code>pip install virtualenv</code>这条命令就能安装成功。如果遇到问题，详细解决请参见<a href="https://virtualenv.pypa.io/en/latest/" target="_blank" rel="noopener">官方文件</a>。<br>安装简单，使用起来还很简答。进入你需要防止独立Python环境的目录下，执行<code>virtualenv your_env_name</code>Python虚拟环境就能创建成功。如果现在就想使用这个环境，只需要<code>cd your_env_name/Scripts</code>，找到<em>Scripts</em>目录下的<em>avtivate.bat</em>这个脚本文件，执行就能进入虚拟环境。你可以像在真实环境下一样通过<code>pip list</code>查看已经看装的库，或者安装/卸载你需要的库，我就不再多说了。当你想要退出的时候，也只需要运行<em>deactivate.bat</em>文件就可以了。<br>这些虚拟环境可以任意放置，而每次使用都要进入虚拟环境目录下来运行脚本文件。管理起来，使用起来未免还是有些麻烦，对晚期强迫症来说还是不够，如果有工具能够帮助我们管理虚拟环境，在任意位置都能使用就好了。  </p>
<h1 id="virtualenvwrapper"><a href="#virtualenvwrapper" class="headerlink" title="virtualenvwrapper"></a>virtualenvwrapper</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://pypi.org/project/virtualenvwrapper/" target="_blank" rel="noopener">virtualenvwrapper</a>就是你需要的管理软件，看名字就可以看出，它主要是对virtualenv的一些功能做了封装，方便我们使用。官方列出的功能如下：</p>
<blockquote>
<ol>
<li>Organizes all of your virtual environments in one place.</li>
<li>Wrappers for creating, copying and deleting environments, including user-configurable hooks.</li>
<li>Use a single command to switch between environments.</li>
<li>Tab completion for commands that take a virtual environment as argument.</li>
<li>User-configurable hooks for all operations.</li>
<li>Plugin system for more creating sharable extensions.</li>
</ol>
</blockquote>
<p>我就不翻译了，反正你知道它很有用就是了。下面介绍安装和简单的使用，还是以Windows环境为例。安装还是依靠咱们的<em>pip</em>神器，<code>pip install virtualenvwrapper-win</code>（linux下是<code>pip install virtualenvwrapper</code>就可以了）。安装成功后的简单使用如下：</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="新建virtualenv"><a href="#新建virtualenv" class="headerlink" title="新建virtualenv"></a>新建virtualenv</h3><p><code>mkvirtualenv your_env_name</code>，所有的Python环境会被集中放置在同一目录下，命令返回的内容会告诉你在哪里。</p>
<h3 id="删除虚拟环境"><a href="#删除虚拟环境" class="headerlink" title="删除虚拟环境"></a>删除虚拟环境</h3><p><code>rmvirtualenv your_env_name</code>，用于删除某个指定的虚拟环境。</p>
<h3 id="查看所有Python环境"><a href="#查看所有Python环境" class="headerlink" title="查看所有Python环境"></a>查看所有Python环境</h3><p><code>workon</code></p>
<h3 id="进入某个Python环境"><a href="#进入某个Python环境" class="headerlink" title="进入某个Python环境"></a>进入某个Python环境</h3><p><code>workon the_env_you_want_enter</code></p>
<h3 id="退出当前Python环境"><a href="#退出当前Python环境" class="headerlink" title="退出当前Python环境"></a>退出当前Python环境</h3><p><code>deactivate</code><br>virtualenvwrapper的功能当然不知于此，更多功能等你探索。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="https://virtualenv.pypa.io/en/latest/" target="_blank" rel="noopener">https://virtualenv.pypa.io/en/latest/</a></li>
<li><a href="https://virtualenvwrapper.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://virtualenvwrapper.readthedocs.io/en/latest/</a></li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>virtualenv</tag>
        <tag>virtualenvwrapper</tag>
        <tag>虚拟python环境</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.006 Lecture 1-b 笔记</title>
    <url>/chinese/2019/01/20/MIT-6-006-Lecture-1-b-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Lecture-1-b-笔记——Peak-finder"><a href="#Lecture-1-b-笔记——Peak-finder" class="headerlink" title="Lecture 1-b 笔记——Peak finder"></a>Lecture 1-b 笔记——Peak finder</h1><p>这节主要讲解”<strong>极值点问题</strong>“（Peak finder），通过不同解决思路之间的对比来理解如何设计高效算法。</p>
<a id="more"></a>

<blockquote>
<p><em>We pick this problem, peak finder, because it’s so easy to understand, and there are fairly straightforward algorithms that are not particularly efficient to solve this problem. And so this is kind of toy problem but like a lot of toy problems, it’s very evocative, and that it points out the issue that involve in designing efficient algorithm.</em></p>
<p>(<em>选择“极值点问题”，是因为它很容易理解，而且有很多虽不高效但简单的方法解决它。它就像一个练习问题，像其他练习问题一样具有启发性，会指出设计高效算法需要注意的点。</em>)</p>
</blockquote>
<h2 id="One-dimensional-version"><a href="#One-dimensional-version" class="headerlink" title="One-dimensional version"></a>One-dimensional version</h2><blockquote>
<p>Position 2 is a peak if and only if b $\geq$ a and b $\geq$ c</p>
<p>Position 11 is a peak if k $\geq​$ j</p>
<p>(<em>位置2是极值点当且仅当</em> b $\geq$ a $\bigwedge$ b $\geq​$ c</p>
<p>位置11是极值点，只需k $\geq​$ j)</p>
</blockquote>
<p><strong>Problem:</strong> Find <strong>a</strong> peak if it exists.（极值点是否存在（值得思考的问题）？如果存在，找到其中一个。）</p>
<h3 id="Straightforward-Algorithm"><a href="#Straightforward-Algorithm" class="headerlink" title="Straightforward Algorithm:"></a>Straightforward Algorithm:</h3><p>从左向右遍历</p>
<ol>
<li>如果位置$\frac{n}{2}​$左边的数从左向右增大，而右边从左向右减小，那位置$\frac{n}{2}​$就是一个极值点。</li>
<li>如果整个数组从左向右一直增大，那位置$n$就是极值点。</li>
</ol>
<p>&emsp;上述第1中情况，我们遍历$\frac{n}{2}$个元素找到极值点。而第2中情况我们要遍历全部$n​$个元素才能找到极值点。</p>
<p>所以<strong>最坏情况</strong>下的时间复杂度是$\Theta(n)​$。</p>
<p><font color=red>注意符号$O(n)$、符号$\Theta(n)$和$\Omega(n)$在算法时间复杂度上的意义。</font></p>
<h3 id="Divide-amp-Conquer-algorithm"><a href="#Divide-amp-Conquer-algorithm" class="headerlink" title="Divide&amp;Conquer algorithm:"></a>Divide&amp;Conquer algorithm:</h3><p>这次我们从$\frac{n}{2}$位置开始分别和左右两个位置比较。</p>
<blockquote>
<p>If $a[\frac{n}{2}] &lt; a[\frac{n}{2}-1]​$ then only look at left half 1 … $\frac{n}{2}-1​$ to look for <strong>a</strong> peak.</p>
<p>Else if $a[\frac{n}{2}] &lt; a[\frac{n}{2}+1]$ then only look at right half $\frac{n}{2}+1$ … $n$ to look for <strong>a</strong> peak.</p>
<p>Otherwise $\frac{n}{2}$ position is a peak.</p>
<p>(<em>如果</em>$a[\frac{n}{2}] &lt; a[\frac{n}{2}-1]$，左半边数组中一定存在极值点。</p>
<p><em>如果</em>$a[\frac{n}{2}] &lt; a[\frac{n}{2}+1]$，右半边数组中一定存在极值点。</p>
<p>如果上述两种情况都不成立，$\frac{n}{2}$就是极值点。)</p>
</blockquote>
<p>下面分析这个算法的时间复杂度：</p>
<p>$T(n) = T(\frac{n}{2}) + \Theta(1)$</p>
<p>从上面的时间复杂度分析可以得到</p>
<p>$T(n) = T(\frac{n}{2}) + \Theta(1) $</p>
<p>&emsp;&emsp;$= T(\frac{n}{4}) + \Theta(1) + \Theta(1)$</p>
<p>&emsp;&emsp;$ = \log_{2}n\times \Theta(1)$</p>
<p>&emsp;&emsp;$=\Theta(\log_{2}n)$</p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>在Python环境下分别编写上面两个算法解决极值点问题，当$n = 10,000,000$时，线性时间复杂度算法用时约13秒，而对数时间复杂度算法用时仅0.001秒。当输入足够大时，两种时间复杂度的差别还是很大的。</p>
<p>对于一维Peak Finder问题的具体解决，将看<a href="https://freshmanhaner.github.io/2019/01/23/leetcode-162-Find-Peak-Element/#more" target="_blank" rel="noopener">传送门</a>。</p>
<p>这种差别在二维的情况下更为明显：</p>
<h2 id="Two-dimensional-version"><a href="#Two-dimensional-version" class="headerlink" title="Two-dimensional version"></a>Two-dimensional version</h2><blockquote>
<p>a is a 2-dimensional peak if and only if $a \geq b,a \geq c,a \geq d,a \geq e​$.</p>
<p><em>二维极值点的定义：当且仅当$a \geq b,a \geq c,a \geq d,a \geq e$时 $a$是一个二维极值点。</em></p>
</blockquote>
<p><strong>Problem:</strong> Find <strong>a</strong> peak if it exists.（极值点是否存在（值得思考的问题）？如果存在，找到其中一个。）</p>
<h3 id="Greedy-Ascent-alorithm"><a href="#Greedy-Ascent-alorithm" class="headerlink" title="Greedy Ascent alorithm:"></a>Greedy Ascent alorithm:</h3><p>需要选择一个开始点，我们假设从二维数组的中间开始向右，当然你也可以选择其他的出发点。</p>
<p>我们从12开始向右，发现右边比12大，所以移动到13，然后是14，到边界转而向下……</p>
<p>（其间如果遇到比当前位置小的，就转向其他方向）</p>
<p>如图，我们一直到20的位置，发现20是一个极值点。不难发现<strong>最坏情况</strong>下的时间复杂度是$\Theta(m\times{n})$。</p>
<h3 id="Extent-1-D-devide-amp-conquer-to-2-D-Attempt-No-1"><a href="#Extent-1-D-devide-amp-conquer-to-2-D-Attempt-No-1" class="headerlink" title="Extent 1-D devide&amp;conquer to 2-D(Attempt No.1)"></a>Extent 1-D devide&amp;conquer to 2-D(Attempt No.1)</h3><blockquote>
<p>Pick middle column $j = \frac{m}{2}$</p>
<p>Find a 1-D peak at $(i,j)$</p>
<p>Use $(i,j)$ as a start point on row $i$ to find 1-D peak on row $i$</p>
<p>（挑选中间列$j$</p>
<p>从$j$列中找出一维极值点$(i,j)$</p>
<p>再在$(i,j)$所在的$i$行找出一维极值，这个就是我们要找的二维极值。）</p>
</blockquote>
<p>如果这个算法是正确的，那么它的时间复杂度是$\Theta(\log_{2}n + \log_{2}m)$。这个算法是高效的，可惜并不正确，因为在第$i$行可能并不存在一个二维极值点。</p>
<p>如上图，假设从第3列开始，算法会结束在14这个位置，因为12是第3列的一维极值点，但是第2行中却不存在一个二维极值点。</p>
<center><font color=red>Attempt Failed</font></center>

<h3 id="Extent-1-D-devide-amp-conquer-to-2-D-Attempt-No-2"><a href="#Extent-1-D-devide-amp-conquer-to-2-D-Attempt-No-2" class="headerlink" title="Extent 1-D devide&amp;conquer to 2-D(Attempt No.2)"></a>Extent 1-D devide&amp;conquer to 2-D(Attempt No.2)</h3><blockquote>
<p>Pick middle column $j = \frac{m}{2}$</p>
<p>Find global maximum on column $j$ at $(i,j)$</p>
<p>Compare $(i,j-1),(i,j),(i,j+1)​$</p>
<p>Pick left columns if $(i,j-1) &gt; (i,j)​$</p>
<p>Else if$(i,j+1) &gt; (i,j)​$  pick right columns</p>
<p>Otherwise $(i,j)$ is a 2-D peak</p>
<p>If you pick left/right columns, you will solve the new problem with half the number of columns</p>
<p>（挑选中间列$j$，找到$j$列中的全局最大值$(i,j)$。</p>
<p>比较$(i,j-1),(i,j),(i,j+1)$，如果$(i,j-1) &gt; (i,j)$则去左边列中找二维极值点，</p>
<p>如果$(i,j+1) &gt; (i,j)$则去右边列中找二维极值点，如果上述两种情况都不成立，$(i,j)$就是一个二维极值点。</p>
<p>如果是去左（或者右）列中找二维极值点，其实就是把问题的列数缩小到了一般。）</p>
</blockquote>
<p>&emsp;在上述的算法中，如果只有1列，我们只需找到这一列中的最大值，这就是二维极值了。</p>
<p>&emsp;下面我们来分析这个算法的时间复杂度：</p>
<p>$T(n,m) = T(n,\frac{m}{2}) + \Theta(n)​$</p>
<p>&emsp;&emsp;$ = \Theta(n) \times \log_{2}m​$</p>
<p>&emsp;&emsp;$ = \Theta(n\log_{2}m)$</p>
<center><font color=red>Attempt Succeed</font></center>

<p><strong>作业：</strong></p>
<p>&emsp;分析上述算法，至少证明其中一个算法的正确性，或者找出例子证明不正确性。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>MIT</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.006 Lecture 1-a 笔记</title>
    <url>/chinese/2019/01/19/MIT-6-006-Lecture-1-a-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="MIT-6-006-Lecture-1-a-笔记"><a href="#MIT-6-006-Lecture-1-a-笔记" class="headerlink" title="MIT 6.006 Lecture 1-a 笔记"></a>MIT 6.006 Lecture 1-a 笔记</h1><p>这是6.006课程的概述部分，主要是对课程的介绍。第一模块的问题讲解从Lecture 1-b开始。</p>
<a id="more"></a>

<h2 id="课程概述"><a href="#课程概述" class="headerlink" title="课程概述"></a>课程概述</h2><p>一句话概括这门课程：</p>
<ul>
<li><strong>Efficient procedures for solving problems on large inputs.</strong></li>
</ul>
<blockquote>
<p><em>The world is moving faster, things get bigger, where have the capability of computing on large inputs. But that doesn’t mean that efficiency isn’t of primary concern.</em></p>
<p>(<em>世界迅速发展，计算机处理大型输入的能力也在变强，但是这不意味着“高效”就变得不重要了。</em>)</p>
</blockquote>
<ul>
<li><strong>Scalability</strong></li>
</ul>
<p>世界会继续发展，输入会继续变大，“large”的意义会继续变迁。所以扩展能力很重要，当输入变大，依然可以“高效”的解决。</p>
<blockquote>
<p><em>We want be able to track how our procedure will gonna to do as input get larger and larger.</em><br><em>(当问题输入变得越来越大时，我们希望依然知道程序会如何执行。</em>)</p>
</blockquote>
<ul>
<li><strong>Classic data structure and elementary algorithms</strong></li>
</ul>
<blockquote>
<p><em>Classic data structures were invented many decades ago, but they stood the test of time, and they continue to be useful</em></p>
<p>经典数据结构是那些被发明了许多年，经受住了时间的考验依旧有用的数据结构。</p>
</blockquote>
<ul>
<li><strong>Real implementaions in Python</strong></li>
</ul>
<p>课程中会要求用Python来实现这些经典数据结构。所以需要有一定的Python基础。</p>
<ul>
<li><strong>Fun problem set</strong></li>
</ul>
<p>有趣不是指简单，而是有挑战性而且有价值的问题。这样你解决这些问题后会觉得学到了一些东西，并且会有成就感。</p>
<h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><p>课程分为8个模块，每个模块都跟随一些问题：</p>
<ol>
<li><strong><em>Algorithmic thinking:</em></strong> <em>Peak finding</em></li>
<li><strong><em>Sorting&amp;Trees:</em></strong> <em>Event simulation</em></li>
<li><strong><em>Hashing:</em></strong> <em>Genome comparison</em></li>
<li><strong><em>Numerics:</em></strong> <em>RSA encrythion</em></li>
<li><strong><em>Graphs:</em></strong> <em>Rubik’s cube</em></li>
<li><strong><em>Shortest paths</em></strong> </li>
<li><strong><em>Dynamic programming:</em></strong>  <em>Image compression</em></li>
<li><strong><em>Advanced topics</em></strong></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>MIT</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.828操作系统工程实验 Lab1 Booting a PC</title>
    <url>/chinese/2018/11/29/MIT6-828%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%AE%9E%E9%AA%8CJOSOS-Lab1-Boot/</url>
    <content><![CDATA[<p>先给出MIT的OS Lab1的网址，详细介绍和相关资源在里面都能找到，开始的配置可能要费些力气。<a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/" target="_blank" rel="noopener">MIT 6.828 Lab1（没被墙）</a><br>这个实验要求你有比较多的预备知识，包括</p>
<ol>
<li>汇编语言——<a href="https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf" target="_blank" rel="noopener">汇编参考资料（注意intel和AT&amp;T语法的不同）</a>/<a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html" target="_blank" rel="noopener">这是AT&amp;T的</a></li>
<li>GDB——<a href="https://www.gnu.org/software/gdb/" target="_blank" rel="noopener">官网</a></li>
</ol>
<p>整个实验1要实现的代码不难，但是要理解的细节非常多。编程难度不大，理解起来颇为费力，所以要有耐心，多花些时间来理解，如果遇到实在不能理解的东西，可以参考一些别人的理解。还是不行的话，我知道一个做的很好的<a href="https://github.com/Clann24/jos" target="_blank" rel="noopener">答案</a>，写的很详细，编码也很好，但是不到万不得已还是不要点的好。废话不多说，开始吧！</p>
<p>要了解操作系统，首先要了解操作系统是怎么被载入的，因为操作系统归根到底也是一个软件。从计算机启动到载入操作系统的大致过程如下：  </p>
<ol>
<li>处理器启动时默认访问特定内存地址，这段地址非易失地储存一些命令，完成一些设备的初始化，然后找到引导设备。</li>
<li>从引导设备中读入第一个block，了解loader的信息。</li>
<li>连续读入block来载入操作系统内核。</li>
</ol>
<p>接下来是关于实验一我的一些理解：</p>
<a id="more"></a>

<p>先给出地址空间的结构，后面是详细介绍：  </p>
<p><img src="https://web-source-1256501598.cos.ap-shanghai.myqcloud.com/image/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.PNG" alt="内存结构示意图"></p>
<p>基于intel 8088处理器的早期个人电脑只能够访问1MB的物理地址，所以地址只能是从0x00000000到0x000FFFFF。但是最多只有640KB可用，从0x000A0000到0x000FFFFF这384KB被硬件保留为特殊用途，<strong>最重要的用途是Basic Input/Output System也就是我们常说的BIOS（基本输入输出系统）</strong>，它占用了从0x000F0000到0x000FFFFF的64KB空间。BIOS的主要作用是基础系统的初始化（包括激活显卡，检查内存条数量等等）和操作系统的载入，后面我们再介绍具体怎么载入操作系统。   </p>
<p>intel 80286处理器的出现打破了1MB的限制，可访问的物理内存增加到了16MB，随后的intel 80386更是直接提升到了4GB。intel为了向下兼容，既让基于早期处理器设计的软件依然可以运行，保留了这1MB的结构。所以我们现在使用的电脑内存中会<strong>有一个“洞”</strong>，就是从0x000F0000到0x000FFFFF这64KB。这个“洞”把内存空间分为“传统内存”和“扩展内存”。   </p>
<p>现在的个人电脑处理器多数已经是64位了，64位处理器理论上支持的物理内存已经达到2^64字节也就是18EB（约180亿GB），当然只是理论上……如果你的电脑是64位处理器，并且内存超过4G的话，那你的内存中就会存在<strong>第二个“洞”</strong>。这是因为在32位的物理空间的最上方的一部分内存被保留，用来映射32位设备。（再次）为了兼容，这部分的地址空间也不能被使用。<br>介绍完了内存空间的结构，我们正式通过MIT的实验操作系统<em>JOS</em>来看操作系统是如何被载入的。</p>
<hr>
<p>讲解细节之前，先来说明一下我们初步目的。MIT给出的JOS操作系统中，kernal的装载主要是由<em>boot.S</em>和<em>main.c</em>这两个文件完成的。其中<em>boot.S</em>由汇编写成，用来初始化设备，将处理器切换为保护模式，最后跳转到<em>main.c</em>。<em>main.c</em>主要是用来装载kernal，在装载完成后跳转到kernal，并且把控制权交给kernal。接下来我们开始讲解这个目的在细节上是如何实现的。<br>按照<strong>实验文档</strong>里的方法顺利用GDB打开了<strong><em>qemu 模拟器</em></strong>上<em>JOS</em>的启动程序。然后我来逐条分析每条汇编语言的目的。<br>起始第一条命令是<code>ljmp</code>跳转指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b</span><br></pre></td></tr></table></figure>
<p>更详细地分析我们知道</p>
<ol>
<li>开始时CS(Code Segment)寄存器 = 0xf000，IP(Instruction Pointer)指令指针寄存器=0xfff0</li>
<li>第一条命令位于地址<em>0x000ffff0</em>处，这是由段地址（CS:IP）转换得到的。而这正是BIOS ROM最高的16bytes。</li>
<li>它要跳转到地址<em>0x000fe05b</em>处。</li>
</ol>
<p>从上面给出的内存地址空间图，我们可以看出0x000ffff0是BIOS的最后16byte，所以他要跳转到0x000fe05b。然后就能够执行BIOS了，BIOS的工作主要是设置中断表，初始化PCI总线和一些设备，最后寻找寻找引导设备（bootable device）。  </p>
<p>如果一个磁盘是bootable的，那它的第一个扇区称为引导扇区（boot sector），里面放置的就是引导装载程序（boot loader）。</p>
<p>BIOS找到引导设备后，会把引导扇区读入内存0x7c00到0x7dff这部分内存中，然后跳转到0x7c00开始执行引导装载程序。</p>
<p>下面是完成这些操作的汇编分析（注意我贴出的都是运行地址，不是链接地址）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[f000:e05b]    0xfe05b:	cmpl   $0x0,%cs:0x6ac8 #(gdb) print&#x2F;x *(0xf6ac8) 结果$1 &#x3D; 0x0</span><br><span class="line">[f000:e062]    0xfe062:	jne    0xfd2e1</span><br><span class="line">[f000:e066]    0xfe066:	xor    %dx,%dx #寄存器dx置零</span><br><span class="line">[f000:e068]    0xfe068:	mov    %dx,%ss #寄存器SS置零</span><br><span class="line">[f000:e06a]    0xfe06a:	mov    $0x7000,%esp #extended stack pointer（扩展栈指针）设置为0x7000</span><br><span class="line">[f000:e070]    0xfe070:	mov    $0xf34c2,%edx</span><br><span class="line">[f000:e076]    0xfe076:	jmp    0xfd15c</span><br><span class="line">[f000:d15c]    0xfd15c:	mov    %eax,%ecx</span><br></pre></td></tr></table></figure>
<p>这一段对然可以理解每句汇编的意思，但是看不出它的目的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[f000:d15f]    0xfd15f:	cli  #关中断</span><br><span class="line">[f000:d160]    0xfd160:	cld  #状态标志寄存器（flag）的第10位（方向标志位）置零，设置地址的变化方向</span><br></pre></td></tr></table></figure>
<p>如果你看反汇编生成的的<em>obj/boot/boot.asm</em>，你会发现这两句的链接地址在0x7c00，正是booter里boot.S开始的地方。这两句的意义也不难理解，整个装载过程肯定不能被中断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[f000:d161]    0xfd161:	mov    $0x8f,%eax #将al寄存器置为0x8f(10001111)</span><br><span class="line">[f000:d167]    0xfd167:	out    %al,$0x70  #讲0x8f写入0x70端口，0x70是变址寄存器端口</span><br><span class="line">[f000:d169]    0xfd169:	in     $0x71,%al  #将端口0x71的内容读入al寄存器，0x71是数据端口</span><br><span class="line">[f000:d16b]    0xfd16b:	in     $0x92,%al  #将端口0x92的内容读入al寄存器，0x92是系统控制端口A</span><br><span class="line">[f000:d16d]    0xfd16d:	or     $0x2,%al   #将al寄存器的第2位（位1）置1</span><br><span class="line">[f000:d16f]    0xfd16f:	out    %al,$0x92  #写回端口0x92</span><br></pre></td></tr></table></figure>

<p>这段命令目的在于初始化设备。</p>
<p>端口0x92各个位的意义：</p>
<ul>
<li>Bit 0 - Setting to 1 causes a fast reset </li>
<li>Bit 1 - 0: disable A20, 1: enable A20</li>
<li>Bit 2 - Manufacturer defined</li>
<li>Bit 3 - power on password bytes. 0: accessible, 1: inaccessible</li>
<li>Bits 4-5 - Manufacturer defined</li>
<li>Bits 6-7 - 00: HDD activity LED off, 01 or any value is “on”</li>
</ul>
<p>我们看到0x92端口的第2位（位1）置1表示激活A20，即第21个地址线被使能，A20地址线被激活，会使系统工作进入保护模式。  我打印出al寄存器，发现值就是2，也就是说除了位1，其他未全部为零。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[f000:d171]    0xfd171:	lidtw  %cs:0x6ab8 </span><br><span class="line">[f000:d177]    0xfd177:	lgdtw  %cs:0x6a74</span><br></pre></td></tr></table></figure>
<p>lidt指令：加载中断向量表寄存器(IDTR)。这个指令会把从地址0xf6ab8起始的后面6个字节的数据读入到中断向量表寄存器(IDTR)中。中断向量表中存放着中断处理程序的首地址，用来处理不同的中断。<br>lgdt指令：加载全局描述符表寄存器 GDT（Global Descriptor Table），在GDT中主要存放段描述符，还有其它描述符，它们都是64-bit长。把从0xf6a74为起始地址处的6个字节的值加载到全局描述符表格寄存器中GDTR中。<br>全局描述符表实现保护模式非常重要的一部分，因为在实模式下的段号（段描述符）只有16位，这对于32位以上的处理器来说就不够用了，为了向下兼容段号长度又不能更改，只能用一个表来存储段号，原先16位的段号来查找这些表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[f000:d17d]    0xfd17d:	mov    %cr0,%eax</span><br><span class="line">[f000:d180]    0xfd180:	or     $0x1,%eax</span><br><span class="line">[f000:d184]    0xfd184:	mov    %eax,%cr0</span><br></pre></td></tr></table></figure>
<p>这三条命令的目的很明显是将控制寄存器CR0的第1位（位0）置1，CR0的位0是启用保护（Protection Enable）标志。当设置该位时即开启了保护模式；当复位时即进入实地址模式。这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么PE和PG标志都要置位。</p>
<p>第一次打开A20地址线是为了检查可用资源，这次是正式进入保护模式了，然后我们需要装载内核了。<br>接下来boot.S会保存寄存器，并调用main.c的函数来实现引导扇区以及后续扇区的装载，等装载完成，操作权就交到操作系统手里了。<em>boot/main.c</em>最后执行的一条语句是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#((void (*)(void)) (ELFHDR-&gt;e_entry))();这次是链接地址</span><br><span class="line">   7d6b:       ff 15 18 00 01 00       call   *0x10018</span><br></pre></td></tr></table></figure>
<p>然后我们就进入了操作系统的entrypoint。<br>关于实验的各个练习及问题，<a href="https://github.com/Clann24/jos/" target="_blank" rel="noopener">这个连接</a>都给出了详细的答案。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>MIT</tag>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery的若干CDN引用</title>
    <url>/chinese/2018/11/22/jQuery%E7%9A%84%E8%8B%A5%E5%B9%B2CDN%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p><img src="https://codecondo.com/wp-content/uploads/2016/12/jQuery.png" alt="jQuery"><br>&emsp;许多人依据直觉认为把<em>jQuery</em>库放在服务器本地会更快，实际上从<em>CDN（Content Distribution Network）</em>引用<em>jQuery</em>往往会有更快的响应。原因有二：</p>
<ol>
<li>同样是要将<em>jQuery</em>发送到用户的浏览器，我们的服务器未必有大公司<em>CDN</em>服务器快。</li>
<li>由于许多网站都引用了大公司<em>CDN</em>提供的<em>jQuery</em>，用户的浏览器中很可能已经缓存了<em>jQuery</em>，当再访问我们的网站中，浏览器从缓存中加载<em>jQuery</em>当然要更快。</li>
</ol>
<p>&emsp;所以<em>CDN</em>引用<em>jQuery</em>不失为一种好的选择，而且各大网络公司都有提供该服务，稳定性也比较高。以下是知名公司的<em>jQuery</em>引用地址，可以根据需求选择适合我们网站的。</p>
<a id="more"></a>

<ul>
<li>首先是官方<em>jQuery CDN</em>，可以通过下面网址查询最新版本:<a href="https://code.jquery.com" target="_blank" rel="noopener">官方jQuery CDN</a></li>
<li>然后是微软的<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://ajax.aspnetcdn.com/ajax/jquery/jquery-1.9.0.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li>接着是度娘的<em>jQuery CDN</em>。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li>再来是Google的，这个在国内不太好用，除非你的用户里国外居多，否则慎选：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li>当然还有几个不错的版本，一起写出来了：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#又拍云的</span><br><span class="line">&lt;script src=<span class="string">"https://upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.2.min.js"</span>&gt;</span><br><span class="line">#新浪的</span><br><span class="line">&lt;script src=<span class="string">"https://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js"</span>&gt;</span><br><span class="line">#Staticfile CDN</span><br><span class="line">&lt;script src=<span class="string">"https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"</span>&gt;</span><br></pre></td></tr></table></figure>
&emsp;当然如果基于某种考虑要把<em>jQuery<em>库放在服务器本地的话，我也准备了</em>jQuery</em><a href="http://jquery.com/download/" target="_blank" rel="noopener">官方下载地址</a>。</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Django的基本用法及数据库连接</title>
    <url>/chinese/2018/11/21/Django%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="创建Django项目"><a href="#创建Django项目" class="headerlink" title="创建Django项目"></a>创建Django项目</h1><p>&emsp;安装 Django 之后，我们就有了管理工具 django-admin.py。我们可以使用 django-admin.py 来创建一个项目：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">django-admin startproject HelloWorld</span><br></pre></td></tr></table></figure>
<p>&emsp;对于旧版本的Django要使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">django-admin.py startproject HelloWorld</span><br></pre></td></tr></table></figure>
<p>&emsp;进入项目目录，执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py runserver 0.0.0.0:8000</span><br></pre></td></tr></table></figure>
<p>来启动项目，然后在浏览器中访问<em>127.0.0.1:8000</em>可知项目是否创建成功。</p>
<a id="more"></a>
<h1 id="URL配置"><a href="#URL配置" class="headerlink" title="URL配置"></a>URL配置</h1><p>&emsp;创建项目后我们必然要添加自己的页面，同时我们也需要配置该页面的URL。在讲Django模板之前我们没办法直接返回<em>html</em>文件，只能直接返回内容，当然你也可以把这些内容组织为<em>html</em>格式。</p>
<ol>
<li><strong>添加页面处理</strong>。在<em>…/HelloWorld/HelloWorld/</em>目录下新建<em>newpage.py</em>文件，文件代码如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="comment">#这是视图函数，配置url时要用到</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HelloWorld</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"&lt;h1&gt;Hello World&lt;/h1&gt;"</span>)</span><br></pre></td></tr></table></figure></li>
<li><strong>配置URL</strong>。编辑<em>…/HelloWorld/HelloWorld/</em>目录下的<em>urls.py</em>，添加两行代码<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#******原有import********</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> newpage</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment">#*****原有url****</span></span><br><span class="line">    url(<span class="string">r'^HelloWorld$'</span>,newpage.HelloWorld),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
访问<em>127.0.0.1:8000/HelloWorld</em>即可得到新建的页面。<blockquote>
<p>url() 函数:<br>Django url() 可以接收四个参数，分别是两个必选参数：regex、view 和两个可选参数：kwargs、name，接下来详细介绍这四个参数。</p>
</blockquote>
</li>
</ol>
<p><em>regex: 正则表达式，与之匹配的 URL 会执行对应的第二个参数 view。<br>view: 用于执行与正则表达式匹配的 URL 请求。<br>kwargs: 视图使用的字典类型的参数。<br>name: 用来反向获取 URL。</em></p>
<h1 id="Django模板"><a href="#Django模板" class="headerlink" title="Django模板"></a>Django模板</h1><p>&emsp;若想返回<em>html</em>文件，需要先指定<em>…/HelloWorld/HelloWorld/setting.py</em>中的<em>TEMPLATES</em>，将其<em>DIRS</em>指定为某个文件夹（一般为templates），然后讲html文件放入该文件夹调用。<br>&emsp;我们可以在讲<em>TEMPLATES</em>的<em>DIRS</em>指定为<code>&#39;DIRS&#39;: [BASE_DIR+&quot;/templates&quot;,],</code>，然后在<em>…/HelloWorld/templates/</em>目录下新建<em>HelloWorld.html</em>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World From html<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;最后将<em>newpage.py</em>的内容改为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># from django.http import render</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render_to_response</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HelloWorld</span><span class="params">(request)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> render_to_response(<span class="string">'HelloWorld.html'</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;因为url已经配置过了，所以直接访问<em>127.0.0.1:8000/HelloWorld</em>即可得到新的页面内容。  </p>
<hr>
<p>&emsp;如果只是这样使用Django模板的话，就真的是浪费了。<strong>Django模板的方便之处在于可以将文档的表现形式和内容分开</strong>。我们在<em>…/HelloWorld/templates/</em>目录下建立<em>pattern.html</em>用于存储文档的表现形式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>pattern name<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Django 模板<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% block mainbody %&#125;</span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span>default contents<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% endblock %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;然后在用以目录下建立<em>content.html</em>用于存储要展示的内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;%extends "pattern.html" %&#125;</span><br><span class="line"> </span><br><span class="line">&#123;% block mainbody %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>继承了pattern.html的排版，展示我自己的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;接下来配置URL，在<em>…/HelloWorld/HelloWorld/</em>目录下新建<em>template.py</em>文件，文件代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># from django.http import render</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">template</span><span class="params">(request)</span>:</span></span><br><span class="line">    title = &#123;&#125;</span><br><span class="line">    title[<span class="string">'title'</span>] = <span class="string">'I am title'</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'content.html'</span>, title)</span><br></pre></td></tr></table></figure>
<p>在<em>urls.py</em>中添加<code>url(r&#39;^template$&#39;,template.template),</code>就能访问<em>127.0.0.1:8000/template</em>看到效果了。</p>
<h1 id="Django之App"><a href="#Django之App" class="headerlink" title="Django之App"></a>Django之App</h1><p>&emsp;Django是一个比较重型的Web框架，一个比较大型的网站下可能有许多个分支，为了实现隔离可以创建多个用<code>django-admin startapp appName</code>命令来创建多个APP。有了APP我们就可以使用<strong>Django模型</strong>_（注意不是模板）_，进而使用数据库。</p>
<h1 id="Django的数据库连接"><a href="#Django的数据库连接" class="headerlink" title="Django的数据库连接"></a>Django的数据库连接</h1><p>&emsp;Django 对各种数据库提供了很好的支持，包括：PostgreSQL、MySQL、SQLite、Oracle。Django 为这些数据库提供了统一的调用API。 我们可以根据自己业务需求选择不同的数据库。<br>&emsp;Django的默认数据库是<em>SQLite3</em>，想要转换为其他数据库需要调整一些参数。我们以Mysql为例做讲解数据库的连接。<br>&emsp;Django规定，如果要使用<em>模型</em>进而对数据库进行操作，就必须创建一个app。连接并操作Mysql数据库的步骤如下：</p>
<ol>
<li>在Mysql中建立一个database</li>
<li>创建一个新APP</li>
<li>在<em>setting.py</em>的<em>INSTALLED_APPS</em>中加入新的APP</li>
<li>填写<em>setting.py</em>的<em>DATABASES</em>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,  <span class="comment"># 或者使用 mysql.connector.django</span></span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'test'</span>,<span class="comment">#数据库名</span></span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'test'</span>,<span class="comment">#用户名</span></span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'test123'</span>,<span class="comment">#用户密码</span></span><br><span class="line">        <span class="string">'HOST'</span>:<span class="string">'localhost'</span>,<span class="comment">#数据库所在主机地址</span></span><br><span class="line">        <span class="string">'PORT'</span>:<span class="string">'3306'</span>,<span class="comment">#mysql服务端口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>填写APP目录下<em>__int__.py</em>文件<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure>
&emsp;这一步非常重要，我因为不知道要修改<em>__int__.py</em>文件，导致Django不能运行，最后才知道是数据库连接失败的原因。<br>具体的连接细节和操作方法网上有很多教程，可以参见<a href="http://www.runoob.com/django/django-model.html" target="_blank" rel="noopener">菜鸟教程</a></li>
</ol>
]]></content>
      <categories>
        <category>web</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Django</tag>
        <tag>web</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 7 ReverseInteger</title>
    <url>/chinese/2018/11/19/leetcode-7-ReverseInteger/</url>
    <content><![CDATA[<h1 id="Reverse-Integer"><a href="#Reverse-Integer" class="headerlink" title="Reverse Integer"></a>Reverse Integer</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Given a 32-bit signed integer, reverse digits of an integer.</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: 123</span><br><span class="line">Output: 321  </span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: -123</span><br><span class="line">Output: -321  </span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong><br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range:$[-2^{31},2^{31}-1]$ . For the purpose of this problem, assume that your function <em>returns 0 when the reversed integer overflows</em>.</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个题目比较简单，也没有太多发挥的空间，主要的性能差异产生于实现的细节上。<br>大部分人的思路思路都是利用求余的方法从右往左取出x中的数字，然后在将他们组成结果。当然要记得处理超出范围的情况。<br>那么同样的思路在实现时可以产生许多的差异。比如：</p>
<ul>
<li>如何处理x的正负情况<ul>
<li><code>if/else</code>分别处理两种情况</li>
<li>利用编程语言的特性同时处理两种情况</li>
</ul>
</li>
<li>如何存储提取出的数字<ul>
<li>存储在<strong>队列</strong>中</li>
<li>边提取边处理，不做存储</li>
</ul>
</li>
<li>如何判断超出范围的情况<ul>
<li>在溢出前做处理</li>
<li>用范围更大的数据类型存储结果，最后再判断是否超出范围</li>
</ul>
</li>
</ul>
<p>这些细节对结果不会产生太大的影响，但是当大家的性能非常接近时，每1ms的提升都可以超越许多人。  </p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>我选择了大多数人能实现的，较快的实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//leetcode表现：用时12ms</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(INT_MAX / <span class="number">10</span> &lt; result || INT_MIN/<span class="number">10</span> &gt; result)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            result = result*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="超慢实现"><a href="#超慢实现" class="headerlink" title="超慢实现"></a>超慢实现</h2><p>虽然这一题大家的实现在效率差不许多，我们还是来试着分析一下最慢的实现是怎么造成的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//leetcode表现：用时32ms</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">            res = res*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( (res&gt;=INT_MIN) &amp;&amp; (res&lt;=INT_MAX)) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个较慢实现看上去和较好的实现差别不大，唯二的差别是：</p>
<ul>
<li>较慢实现采用计算完成后再判断是否溢出</li>
<li>结果的数据类型一个是int一个是long long</li>
</ul>
<p>上述两点差别在这个题目中并不会造成多大影响。如果非要区别的话，第一个区别在溢出的情况下会多花时间；第二个区别则会造成一点空间上的浪费。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Leetcode国际版：<a href="https://leetcode.com/" target="_blank" rel="noopener">https://leetcode.com/</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ STL之map与unordered_map对比</title>
    <url>/chinese/2018/11/15/C-STL%E4%B9%8Bmap%E4%B8%8Eunordered-map%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>map和unordered_map都是STL中的容器，它们虽然用法相似，但是背后的原理值得了解，进而在不同场景中有针对性的应用它们。</p>
<a id="more"></a>
<h1 id="STL之map"><a href="#STL之map" class="headerlink" title="STL之map"></a>STL之map</h1><p>&emsp;<a href="http://www.cplusplus.com/reference/map/map/" target="_blank" rel="noopener">map</a>是C++标准模板库（<em>Standard Template Library</em>）中常用的关联容器（<em>associative container</em>），元素由键值（<em>key value</em>）和映射值（<em>mapped value</em>）组成，通过<strong>唯一键值</strong>来查找映射值。map中可以通过键值直接得到映射值，例如：  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="built_in">std</span>::<span class="built_in">string</span>&gt; name2description;</span><br><span class="line">    name2description[<span class="string">"Tom"</span>]=<span class="string">"A dumb cat"</span>;</span><br><span class="line">    name2description[<span class="string">"Jerry"</span>]=<span class="string">"A cunning mouse"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Tom is "</span> &lt;&lt; name2description[<span class="string">"Tom"</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="STL之unordered-map"><a href="#STL之unordered-map" class="headerlink" title="STL之unordered_map"></a>STL之unordered_map</h1><p>&emsp;<a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/" target="_blank" rel="noopener">unordered_map</a>也是C++标准模板库中的容器，但是不像map那样常用。unordered_map的基本用法和map几乎完全一样，只是不存在反向迭代器（<em>iterator</em>）。  </p>
<h1 id="map与unordered-map的区别"><a href="#map与unordered-map的区别" class="headerlink" title="map与unordered_map的区别"></a>map与unordered_map的区别</h1><p>&emsp;虽然两者在使用上几乎没什么区别，但是在用途上却有不小的差别。原因在于<strong>map的内部实现是二叉搜索树（<em>Binary Search Tree</em>）</strong>，而且是按键值有序的（可以自定义排序方法）。相对的<strong>unordered_map的内部实现是哈希表</strong>，而且是无序的。它们的内部实现让它们具有了各自的优缺点。<br>&emsp;我们知道二叉搜索树各种操作上的性能比较平均也可以接受。不管是查找的O（log N），插入的O（N）还是删除的O（N），虽然都不是最好的情况，但也都是不错的时间复杂度，再加上它是有序的。这使得map容器很常用。<br>&emsp;相比于BST的平均，哈希表则更擅长搜索，搜索的摊分时间复杂度达到O（1）。但是它的无序性影响了他的通用性。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_1_TwoSum</title>
    <url>/chinese/2018/11/15/leetcode/</url>
    <content><![CDATA[<h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.<br>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the same element twice.  </p>
<a id="more"></a>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="Brute-Force——暴力法"><a href="#Brute-Force——暴力法" class="headerlink" title="Brute Force——暴力法"></a>Brute Force——暴力法</h3><p>直接采用两层循环扫描所有元素，找到和为target的两个数，然后返回。<br><strong>时间复杂度：$O(N^2)$，空间复杂度：$O(1)$</strong>  </p>
<h3 id="Two-pass-Hash-Table——两遍哈希表法"><a href="#Two-pass-Hash-Table——两遍哈希表法" class="headerlink" title="Two-pass Hash Table——两遍哈希表法"></a>Two-pass Hash Table——两遍哈希表法</h3><p>算法在很多时候就是在时间复杂度与空间复杂度的权衡（trade-off）。暴力法空间复杂度很小，时间复杂度却比较大，显然不适用于对时间要求较高的应用。两遍哈希表法就是牺牲一点空间来换取一些时间。之所以叫两遍哈希表法（Hash Table），是因为要循环（iteration）两遍。第一遍建立哈希表存储每个元素的值和索引（Index）。第二遍循环利用建好的哈希表快速查找（Look Up）每个元素是否存在互补元素（即与之相加和为target的元素），就能在$O(N)$的时间复杂度下找到答案。<br><strong>时间复杂度：$O(N)$，空间复杂度$O(N)$</strong><br>&emsp;注意：哈希表的查找速度接近$O(1)$的时间复杂度，但具有不确定性。如果哈希表构建的不够好，碰撞（Collision）很多的话，查找速度也可能退化(Degenerate)为$O(N)$，但是一般而言，哈希表的摊分时间复杂度（Amortized Time Complexity）可以达到$O(1)$。  </p>
<h3 id="One-pass-Hash-Table——一遍哈希表法。"><a href="#One-pass-Hash-Table——一遍哈希表法。" class="headerlink" title="One-pass Hash Table——一遍哈希表法。"></a>One-pass Hash Table——一遍哈希表法。</h3><p>其实我们深入研究一下两遍哈希表法会发现，其实可以一次遍历做完<strong>插入</strong>和<strong>查找</strong>两件事。插入之前先看一下现在的哈希表中有没有待插入值的互补值，如果有，后面就不用继续执行了。既减少了遍历的次数，也减少了遍历的长度。当然，这两点只能影响到系数，并不会真正提升时间复杂度。<br><strong>时间复杂度：$O(N)$，空间复杂度：$O(N)$</strong></p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Brute Force</span></span><br><span class="line"><span class="comment">//leetcode表现：用时76ms</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">         <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = i + <span class="number">1</span>;j &lt; length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    result.push_back(i);</span><br><span class="line">                    result.push_back(j);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="两遍哈希表法"><a href="#两遍哈希表法" class="headerlink" title="两遍哈希表法"></a>两遍哈希表法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Two-pass Hash Table</span></span><br><span class="line"><span class="comment">//Leetcode表现：用时4ms</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">         <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash_table;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">            hash_table.insert(&#123;nums[i],i&#125;);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            it = hash_table.find(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it != hash_table.end() &amp;&amp; (*it).second != i)</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(i);</span><br><span class="line">                result.push_back((*it).second);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="一遍哈希表法"><a href="#一遍哈希表法" class="headerlink" title="一遍哈希表法"></a>一遍哈希表法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;One-pass</span><br><span class="line">&#x2F;&#x2F;leetcode表现：用时4ms</span><br><span class="line">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">         vector&lt;int&gt; result;</span><br><span class="line">        unordered_map&lt;int,int&gt; hash_table;</span><br><span class="line">        int len &#x3D; nums.size();</span><br><span class="line">        unordered_map&lt;int,int&gt;::iterator it;</span><br><span class="line">        int i;</span><br><span class="line">        for(i &#x3D; 0;i &lt; len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            it &#x3D; hash_table.find(target - nums[i]);</span><br><span class="line">            if(it !&#x3D; hash_table.end())</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(i);</span><br><span class="line">                result.push_back((*it).second);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                hash_table.insert(&#123;nums[i],i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="超慢实现"><a href="#超慢实现" class="headerlink" title="超慢实现"></a>超慢实现</h2><ol>
<li>其一：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//leetcode表现：用时288ms</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; answer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j &amp;&amp; (nums[i] + nums[j]) == target) &#123;</span><br><span class="line">                    answer.push_back(i);</span><br><span class="line">                    answer.push_back(j);</span><br><span class="line">                    <span class="keyword">return</span> answer;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
同样是暴力法解决问题，却花费了上一种暴力法接近<strong>四倍</strong>的时间。其中原由我在啊<a href="https://freshmanhaner.github.io/2018/10/05/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/#more" target="_blank" rel="noopener">如何优化程序性能</a>一文中已经提过，这里简单说一下原因。主要原因是在<strong>循环中出现了低效代码*</strong>nums.size()*，每次循环（而且还是两层循环）都要调用这个函数，造成了时间上的浪费。这种浪费是非常可怕的，尤其是对于大型程序来说，这样一个简单算法就有数倍的差别，可想而知对于大量数据或者大型程序将有多么大的差别。如果提前把他赋予一个常量，就可以避免这种浪费。<br>你以为这已经差到不能更差了？你错了！</li>
<li>其二：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//leetcode表现：用时292ms</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i!=j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]+nums[j]==target)</span><br><span class="line">                    &#123;</span><br><span class="line">                        d.emplace_back(i);</span><br><span class="line">                        d.emplace_back(j);</span><br><span class="line">                        <span class="keyword">return</span> d;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
你能找出这个解决方案比“最差”更差的原因吗？要知道<em>emplace_back()</em>是比<em>push_back()</em>要高效的。<br>上一种解决方案能别这一种快4ms，在于上一种解决方案少了一些判断。对于<em>if（断言1 &amp;&amp; 断言2）</em>这种形式，如果断言1不满足，后面的断言二就不会被判断了。上一种解决方案的一些情况中断言2不会被判断，一定程度上节省了时间，二这个解决方案无论什么情况下都会完成两个断言的判断。</li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Leetcode国际版：<a href="https://leetcode.com/" target="_blank" rel="noopener">https://leetcode.com/</a></li>
<li>可能漏掉某些参考文档，请作者联系添加引用或删除相关内容。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>CSE Lab2 RPC and Lock Server</title>
    <url>/chinese/2018/11/10/CSE-Lab2-RPC-and-Lock-Server/</url>
    <content><![CDATA[<p>从这个实验中我们可以学到：    </p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank" rel="noopener">远程过程调用（Remote procedure call）——RPC</a></li>
<li>多线程并发，主要是下面四个函数：<ul>
<li><em>pthread_mutex_lock(&amp;mutex)</em>&amp;<em>pthread_mutex_unlock(&amp;mutex)</em></li>
<li><em>pthread_cond_wait(&amp;cond, &amp;mutex)</em>&amp;<em>pthread_cond_signal(&amp;cond)</em></li>
</ul>
</li>
<li>用上面四个函数实现<em>acquire(lock_id)</em>&amp;_release(lock_id)_两个函数，用来实现互斥。</li>
</ol>
<a id="more"></a>

<h2 id="学习材料"><a href="#学习材料" class="headerlink" title="学习材料"></a>学习材料</h2><ul>
<li>上面四个函数是在_pthread.h_中实现的，详见<a href="http://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread.h.html" target="_blank" rel="noopener">传送门</a>  </li>
<li><a href="https://ipads.se.sjtu.edu.cn/courses/cse/labs/Lab-2.html" target="_blank" rel="noopener">lab2: RPC&amp;Lock Server</a>  </li>
<li><a href="https://github.com/kururu002/CSE_Lab-MIT" target="_blank" rel="noopener">代码参考</a></li>
</ul>
<h2 id="远程过程调用-Remote-Procedure-Call"><a href="#远程过程调用-Remote-Procedure-Call" class="headerlink" title="远程过程调用 Remote Procedure Call"></a>远程过程调用 Remote Procedure Call</h2><p>&emsp;远程过程调用其实是一种进程间的通讯，它让进程可以像调用本地过程那样调用网路中另一地址空间中的过程。RPC是分布式计算的基础之一，简单易用，但是收到网络的影响。<br>&emsp;RPC 系统包含一下五个部分：</p>
<ol>
<li>RPC数据和信息的<strong>报文格式标准</strong></li>
<li>打包(marshal)/解包(unmarshal)工具库</li>
<li>RPC编译器</li>
<li>服务端框架</li>
<li>客户端框架</li>
<li>捆绑方法</li>
</ol>
<p>&emsp;下图描绘了RPC的调用过程：<br><img src="https://upload-images.jianshu.io/upload_images/7143349-a9db3c3c85194c6e.png" alt="RPC_call"><br>&emsp;这里我们不讨论RPC的实现细节，知识了解RPC以及它的简单实用。RPC的使用如下</p>
<ul>
<li>RPC server使用RPC library创建一个RPC server对象去监听某个端口，并且用reg()函数记录不同的RPC handler。</li>
<li>RPC client创建一个RPC client对象连接RPC server（利用地址+端口），然后调用RPC server上的远程过程。</li>
<li>RPC有接口标准规定server和client之间参数的传递。</li>
<li>server和client之间的数据传输需要经过mashal（发送端）和unmashal（接收端）。</li>
</ul>
<p>&emsp;因为实验对RPC不要求理解原理，大部分的代码已经实现，只需在extent_client.cc中去调用extent_server.cc中的函数就可以了。注意参数的类型和顺序，因为RPC库并不会检查传入参数的类型，如果传递了错误的类型也会被接受，进而出错。</p>
<h2 id="Lock-Server-amp-Locking"><a href="#Lock-Server-amp-Locking" class="headerlink" title="Lock Server&amp;Locking"></a>Lock Server&amp;Locking</h2><h3 id="Lock-Server"><a href="#Lock-Server" class="headerlink" title="Lock Server"></a>Lock Server</h3><p>&emsp;Lock Server主要是由<em>acquire(lock_id)</em>&amp;<em>release(lock_id)_这两个函数组成的，Lock Server可以管理许多个“锁”每个“锁”有唯一的整数id，而且每把”锁“在同一时间只能分配给一个client。“锁”的数量是不限制的，如果传入_acquire(lock_id)_的lock_id之前没有出现过，Locker Server会默认加入管理。_acquire(lock_id)</em>&amp;_release(lock_id)_两个函数的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">lockid_t</span>,<span class="keyword">bool</span>&gt; lock_table;<span class="comment">//全局变量，用来管理“锁”</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;<span class="comment">//条件变量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;<span class="comment">//互斥变量</span></span><br><span class="line"></span><br><span class="line">lock_protocol::status</span><br><span class="line">lock_server::acquire(<span class="keyword">int</span> clt, lock_protocol::<span class="keyword">lockid_t</span> lid, <span class="keyword">int</span> &amp;r)</span><br><span class="line">&#123;<span class="comment">//clt是client_id</span></span><br><span class="line">  lock_protocol::status ret = lock_protocol::OK;</span><br><span class="line">        <span class="comment">// Your lab2 part2 code goes here</span></span><br><span class="line">  pthread_mutex_lock(&amp;mutex);<span class="comment">//用于对锁操作的互斥</span></span><br><span class="line">  <span class="keyword">if</span>(lock_table.find(lid) != lock_table.end())</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="keyword">while</span>(lock_table[lid] == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_cond_wait(&amp;cond,&amp;mutex);</span><br><span class="line">      <span class="comment">//这个函数需要理解一下，它是带锁wait的吗？它可以带锁wait吗？</span></span><br><span class="line">    &#125;</span><br><span class="line">    lock_table[lid] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    lock_table.insert(<span class="built_in">std</span>::pair&lt;lock_protocol::<span class="keyword">lockid_t</span>,<span class="keyword">bool</span>&gt;(lid,<span class="literal">true</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock_protocol::status</span><br><span class="line">lock_server::release(<span class="keyword">int</span> clt, lock_protocol::<span class="keyword">lockid_t</span> lid, <span class="keyword">int</span> &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">  lock_protocol::status ret = lock_protocol::OK;</span><br><span class="line">        <span class="comment">// Your lab2 part2 code goes here</span></span><br><span class="line">  pthread_mutex_lock(&amp;mutex);</span><br><span class="line">  <span class="keyword">if</span>(lock_table.find(lid) != lock_table.end())</span><br><span class="line">  &#123;</span><br><span class="line">    lock_table[lid] = <span class="literal">false</span>;</span><br><span class="line">    pthread_cond_signal(&amp;cond);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> lock_protocol::NOENT;</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;mutex);<span class="comment">//对于互斥变量的操作一定要非常小心，不然容易造成饥饿或死锁。</span></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h3><p>&emsp;有了<em>acquire(lock_id)</em>&amp;_release(lock_id)_这两个函数，我们就可以对yfs_client.cc中的函数（读写磁盘）的函数加锁以实现并行操作了。需要注意的是，有调用关系的函数在加锁是要格外注意。考虑下面两个函数的加锁情况，会出现死锁吗？    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isFileExist</span><span class="params">(<span class="keyword">int</span> inode_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    acquire(inode_id);<span class="comment">//对inode的加锁，一般直接用inode number做id</span></span><br><span class="line">    Read(inode_id);</span><br><span class="line">    WriteDisk(inode_id);</span><br><span class="line">    release(inod_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFile</span><span class="params">(<span class="keyword">int</span> inode_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    acquire(inode_id);</span><br><span class="line">    isFileExist(inode_id);</span><br><span class="line">    release(inode_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;上面的代码明显是不可以的，readFile里已经对inode_id对应的锁加了锁，去查看该文件是否存在时又要这把锁的花，就已经被占用了，isFileExist()会等待readFile()放开这把锁，这在isFileExist()函数返回之前，明显是不可能发生的，这就造成了死锁。<br>&emsp;所以<strong>对于需要加锁的函数，应该尽量避免相互调用</strong>。因为这会是的加锁关系相当的复杂，要么不能保证互斥，要么会产生死锁。如果一定要存在调用关系的话，被调用的函数一般是不加锁的。当然你要仔细考量，保证互斥。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>RPC</tag>
        <tag>Lock</tag>
        <tag>并发</tag>
        <tag>分布式计算</tag>
      </tags>
  </entry>
  <entry>
    <title>Two-Dimensional Array & Pointer to Pointer</title>
    <url>/chinese/2018/10/29/Two-Dimensional-Array-Pointer-to-Pointer/</url>
    <content><![CDATA[<p>&emsp;First of all, let’s consider the difference of three functions as follow:    </p>
<ol>
<li><p>void write(char a)</p>
</li>
<li><p>void write(char *a)</p>
</li>
<li><p>void write(char **a)    </p>
<a id="more"></a>
<p>&emsp;I am sure you have seen 1 and 2 functions, they respectively are <strong>passing-by-value</strong> and <strong>passing-by-address</strong>. The input of 1 can only be a <strong>char</strong>, the input of 2 can be a <strong>pointer to char</strong> or a <strong>char array</strong>. Both of them are easy to understand. But have you seen function 3? It’s confusing some times, because the input of 3 can be a <strong>pointer to pointer that point to char</strong> or a <strong>pointer to char array</strong> or a <strong>two dimensional char array</strong>. It is different when you code a function like 3, the difference as follows:</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bm-&gt;read_block(unint32_t block_num,char *buf)</span></span><br><span class="line"><span class="comment">//copy memory from char blocks[block_num][] by memcpy()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//case 1</span></span><br><span class="line"><span class="keyword">void</span> inode_manager::read_file(<span class="keyword">uint32_t</span> inum, <span class="keyword">char</span> **buf_out, <span class="keyword">int</span> *size)</span><br><span class="line">&#123;<span class="comment">//when input of char **buf_out is two-dimensional char array which is declaration as char buf_out[BLOCK_NUM][BLOCK_SIZE]</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">file_inode</span> = <span class="title">get_inode</span>(<span class="title">inum</span>);</span></span><br><span class="line">        *size =file_inode-&gt;size;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        len = getFileBlockNum(*size);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            bm-&gt;read_block(file_inode-&gt;blocks[i],buf_out[i]);<span class="comment">//or</span></span><br><span class="line">            <span class="comment">//bm-&gt;read_block(file_inode-&gt;blocks[i],(char *)buf_out + (i * BLOCK_SIZE));</span></span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//case 2</span></span><br><span class="line"><span class="keyword">void</span> inode_manager::read_file(<span class="keyword">uint32_t</span> inum, <span class="keyword">char</span> **buf_out, <span class="keyword">int</span> *size)</span><br><span class="line">&#123;<span class="comment">//when input of char **buf_out is pointer to char array which is declaration as char *buf_out; and call this function like read_file(id,&amp;buf_out,size)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">file_inode</span> = <span class="title">get_inode</span>(<span class="title">inum</span>);</span></span><br><span class="line">    *size =file_inode-&gt;size;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    len = getFileBlockNum(*size);</span><br><span class="line">    *buf_out = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(MAXFILE * BLOCK_SIZE);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      bm-&gt;read_block(file_i-&gt;blocks[i],((*buf_out) + i*BLOCK_SIZE));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//case 3</span></span><br><span class="line"><span class="comment">//when the input of char **buf_out is pointer to pointer that pointe to char,which is declaration as char **buf_out. What you can do to the input is rare.</span></span><br></pre></td></tr></table></figure>

<p>&emsp;As to case 2,do you think the following code is correct?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> inode_manager::read_file(<span class="keyword">uint32_t</span> inum, <span class="keyword">char</span> **buf_out, <span class="keyword">int</span> *size)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">file_inode</span> = <span class="title">get_inode</span>(<span class="title">inum</span>);</span></span><br><span class="line">        *size =file_inode-&gt;size;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        len = getFileBlockNum(*size);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            buf_out[i] = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * BLOCK_SIZE);</span><br><span class="line">            bm-&gt;read_block(file_inode-&gt;blocks[i],buf_out[i]);<span class="comment">//the following line is alse wrong</span></span><br><span class="line">            <span class="comment">//bm-&gt;read_block(file_inode-&gt;blocks[i],(char *)buf_out + (i * BLOCK_SIZE));</span></span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bm-&gt;read_block(unint32_t block_num,char *buf)//copy memory from char blocks[block_num][] by memcpy()</span></span><br></pre></td></tr></table></figure>

<p>&emsp;The answer is incorrect. Do you know the reason?</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优化程序性能</title>
    <url>/chinese/2018/10/05/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong><em>代码的简单改变，可能带来程序性能上的飞跃</em></strong><br>&emsp;我们用高级语言编出的代码都要经过编译器的编译才能形成可以执行的程序，如今的编译器已经比较成熟，但由于编译问题的复杂性而<strong>难以做到完美</strong>。编译器会对程序自动做出优化，但要在保证正确性的前提下。如果我们<strong>在编程中给与编译器更多提示</strong>，那编译器就能更好的优化程序。那我们如何跟编译器一起编写出更加高效的程序呢？</p>
<a id="more"></a>
<h3 id="消除循环代码中的低效率"><a href="#消除循环代码中的低效率" class="headerlink" title="消除循环代码中的低效率"></a>消除循环代码中的低效率</h3><hr>
<p>通过<strong><em>代码移动</em></strong>优化来消除循环代码中的低效率。</p>
<blockquote>
<p><strong><em>代码移动</em></strong>优化包括识别要执行多次但是计算结果不会改变的计算，因而可以将计算移动到不会被多次求值的部分。    </p>
</blockquote>
<p>优化编译器会试着进行代码移动，但是会非常小心，当它不能发现这种优化是否会有副作用时，它会假设是有副作用的，因而放弃优化。而编译器又不可能可靠地发现一个函数是否有副作用。所以我们必须帮助编译器显示地完成<strong><em>代码移动</em></strong>优化。下面是一个比较极端的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Convert string to lowercase: slow *&#x2F;</span><br><span class="line">void lower1(char *s)</span><br><span class="line">&#123;</span><br><span class="line">    long i;</span><br><span class="line">    </span><br><span class="line">    for(i &#x3D; 0;i &lt; strlen(s); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i] &gt;&#x3D; &#39;A&#39; &amp;&amp; s[i] &lt;&#x3D; &#39;Z&#39;)</span><br><span class="line">            s[i] -&#x3D; (&#39;A&#39; - &#39;a&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Convert string to lowercase: faster *&#x2F;</span><br><span class="line">void lower2(char *s)</span><br><span class="line">&#123;</span><br><span class="line">    long i;</span><br><span class="line">    long len &#x3D; strlen(s);</span><br><span class="line">    </span><br><span class="line">    for(i &#x3D; 0;i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i] &gt;&#x3D; &#39;A&#39; &amp;&amp; s[i] &lt;&#x3D; &#39;Z&#39;)</span><br><span class="line">            s[i] -&#x3D; (&#39;A&#39; - &#39;a&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*Sample implementation of library function strlen*&#x2F;</span><br><span class="line">&#x2F;*Compute length of string*&#x2F;</span><br><span class="line">size_t strlen(const char *s)</span><br><span class="line">&#123;</span><br><span class="line">    long length &#x3D; 0;</span><br><span class="line">    while(*s !&#x3D; &#39;\0&#39;)</span><br><span class="line">    &#123;</span><br><span class="line">        s++;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中当字符床s长度超过十万时，lower2()比lower1()快500000多倍。这是因为后者代码中隐藏着<strong><em>渐近低效率(asymptotic inefficiency)</em></strong>，一个有经验的程序猿会在编程中会尽力避免引入这样的渐近低效率。</p>
<h3 id="减少过程（函数）调用"><a href="#减少过程（函数）调用" class="headerlink" title="减少过程（函数）调用"></a>减少过程（函数）调用</h3><hr>
<p>过程（函数）调用是会带来开销的，而且会阻碍编译器进行程序优化，对于一些简单操作，直接操作比写成函数更高效。当然这样就一定程度上破坏了程序的<em>模块性</em>，需要我们根据实际情况进行权衡。当然<strong><em>内联函数</em></strong>是个不错的折中。</p>
<h3 id="消除不必要的内存访问"><a href="#消除不必要的内存访问" class="headerlink" title="消除不必要的内存访问"></a>消除不必要的内存访问</h3><hr>
<p>我们先来看一段c代码和它对应的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*result &#x3D; 1;</span><br><span class="line">for(i &#x3D; 0;i &lt; length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    *result &#x3D; *result * data[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result in %rbx,data + i in %rdx,data + length in %rax</span><br><span class="line">1 .L17:</span><br><span class="line">2   vmovsd (%rbx), %xmm0</span><br><span class="line">3   vmulsd (%rbx), %xmm0, %xmm0</span><br><span class="line">4   vmovsd %xmm0, (%rbx)</span><br><span class="line">5   addq   $8, %rdx</span><br><span class="line">6   cmpq   %rax, %rdx</span><br><span class="line">7   jne    .L17</span><br></pre></td></tr></table></figure>
<p>&emsp;从汇编代码中我们可以看到每次迭代时，累积变量的数值都要从<strong><em>内存读出再写入内存</em></strong>，这样的读写是很浪费的，因为每次迭代开始时从result 读出的值和上次循环最后写入的值是一样的。<br>&emsp;我们可以通过引入一个临时变量（局部变量）来累计计算出的值，只有在计算完成后才存入result。这样就能消除这种不必要的内存读写了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int acc &#x3D; 1;</span><br><span class="line">for(i &#x3D; 0;i &lt; length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    acc &#x3D; acc * data[i];</span><br><span class="line">&#125;</span><br><span class="line">*result &#x3D; acc;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">acc in %xmm0 ,data + i in %rdx,data + length in %rax</span><br><span class="line">1 .L25:</span><br><span class="line">2   vmulsd (%rdx), %xmm0, %xmm0</span><br><span class="line">3   addq   $8, %rdx</span><br><span class="line">6   cmpq   %rax, %rdx</span><br><span class="line">7   jne    .L25</span><br></pre></td></tr></table></figure>
<p>由于<strong><em>内存别名</em></strong>的使用，这种优化编译器很难自动完成。而一旦我们主动实现这种优化，程序性能可以得到不小的优化。</p>
<h3 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h3><hr>
<blockquote>
<p><strong><em>循环展开</em></strong>是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。    </p>
</blockquote>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sum(int a[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    for(i &#x3D; 0;i&lt; n;i++)</span><br><span class="line">        sum +&#x3D; a[i];</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;2×1循环展开</span><br><span class="line">int sum(int a[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    for(i &#x3D; 0;i &lt; n - 1;i+&#x3D;2)</span><br><span class="line">        sum +&#x3D; a[i] + a[i+1];</span><br><span class="line">        </span><br><span class="line">    for(;i&lt;n;i++)&#x2F;&#x2F;处理最后一（几）个元素</span><br><span class="line">        sum +&#x3D; a[i];</span><br><span class="line">        </span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><em>循环展开</em></strong>能够在两个方面改进程序的性能。首先它减少了不直接有助于程序结果的操作的数量。第二，它提供了一些方法进一步改变代码从而减少整个计算中<strong><em>关键路径</em></strong>上的操作数量。</p>
</blockquote>
<h3 id="提高并行性"><a href="#提高并行性" class="headerlink" title="提高并行性"></a>提高并行性</h3><hr>
<p>流水线中的<strong><em>数据相关</em></strong>在一定程度上限值了程序的性能，但是我们在编程中又貌似对此无能为力。实际上我们确实可以采用一些方法来提高并行性来缓解数据相关。<br>比如我们可以将一组合并运算分割为两部分或者更多，并在最后讲结果合并来提高性能。比如对于上一部分的sum()例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;2×2循环展开</span><br><span class="line">int sum(int a[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int sum1 &#x3D; 0;</span><br><span class="line">    int sum2 &#x3D; 0</span><br><span class="line">    for(i &#x3D; 0;i &lt; n - 1;i+&#x3D;2)</span><br><span class="line">    &#123;</span><br><span class="line">        sum1 +&#x3D; a[i];</span><br><span class="line">        sum2 +&#x3D; a[i+1];</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    for(;i&lt;n;i++)&#x2F;&#x2F;处理最后一（几）个元素</span><br><span class="line">        sum1 +&#x3D; a[i];</span><br><span class="line">        </span><br><span class="line">    return sum1 + sum2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法既使用了两次循环展开，以使每次迭代完成更多的计算，也使用两路并行，提高了并行性。我们称这种方法为<strong><em>2×2循环展开</em></strong>。</p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>程序优化</tag>
      </tags>
  </entry>
</search>
